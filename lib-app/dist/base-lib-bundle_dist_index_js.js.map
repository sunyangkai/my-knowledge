{"version":3,"file":"base-lib-bundle_dist_index_js.js","mappings":";;;;;;;;;;AAAA;AACA;AACA;AACA,kHAAkH;AAClH,CAAC,EAAE,SAAI,wBAAwB;;AAE/B;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,sBAAsB;AACxC,mBAAmB,mBAAmB;AACtC;;AAEA;AACA;AACA,kBAAkB,kCAAkC;AACpD,mBAAmB,+BAA+B;AAClD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA,0BAA0B;;AAE1B;AACA;AACA,YAAY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,kCAAkC;AAClC;AACA,2CAA2C;;AAE3C,sCAAsC;AACtC;AACA;;AAEA,sCAAsC;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mGAAmG,aAAa;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uGAAuG,eAAe;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;;AAEZ;AACA;AACA,WAAW,GAAG;;AAEd,wDAAwD;AACxD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oNAAoN;AACpN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B,mBAAmB,WAAW;AAC9B,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B,mBAAmB,QAAQ;AAC3B,mBAAmB,WAAW;AAC9B,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B,mBAAmB,QAAQ;AAC3B,mBAAmB,WAAW;AAC9B,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gCAAgC;;AAEhC,iCAAiC;AACjC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gCAAgC;;AAEhC;AACA;AACA;AACA;AACA,0DAA0D;;AAE1D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;;AAEvC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;;AAER;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;;AAER;AACA;AACA,QAAQ;;AAER;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,GAAG;AACpB,iBAAiB,GAAG;AACpB,iBAAiB,GAAG;AACpB,iBAAiB,eAAe;AAChC,iBAAiB,GAAG;AACpB,iBAAiB,GAAG;AACpB;AACA;AACA;AACA;AACA,iBAAiB,GAAG;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;;AAEd;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E;;AAE3E;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA,0BAA0B,oBAAoB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB;;AAEtB,6BAA6B,kBAAkB;;AAE/C;AACA,+BAA+B;;AAE/B,kCAAkC;AAClC;AACA;;AAEA,sCAAsC;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA,0BAA0B,oBAAoB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B,kBAAkB,SAAS;AAC3B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB,kBAAkB,QAAQ;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,GAAG;AACpB,iBAAiB,QAAQ;AACzB,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;;AAE9B;AACA;AACA,0BAA0B,qBAAqB;AAC/C;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,2IAA2I,yCAAyC;AACpL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,IAAI;AACrB,iBAAiB,kBAAkB;AACnC,iBAAiB,GAAG;AACpB,kBAAkB,QAAQ;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,IAAI;AACrB,kBAAkB,QAAQ;AAC1B;;AAEA;AACA;AACA;AACA,eAAe;AACf,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,IAAI;AACrB,iBAAiB,kBAAkB;AACnC,iBAAiB,GAAG;AACpB;AACA;AACA;AACA,8CAA8C;AAC9C,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B,kBAAkB,cAAc;AAChC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;;AAEd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;;AAEzB;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,gDAAgD;AAChD;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,0CAA0C;AAC1C;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA,qDAAqD,IAAI;AACzD;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA,0CAA0C,IAAI;AAC9C;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;;AAE7C;AACA;AACA;AACA;AACA;AACA,eAAe;;AAEf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;;AAEf;AACA,4BAA4B;AAC5B;AACA,eAAe;AACf,6BAA6B;AAC7B;AACA,eAAe;AACf,6BAA6B;AAC7B;AACA,eAAe;AACf,8BAA8B;AAC9B;AACA,eAAe;AACf,8BAA8B;AAC9B;AACA,eAAe;AACf,uCAAuC;AACvC;AACA,eAAe;AACf,iCAAiC;AACjC;AACA,eAAe;AACf,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,YAAY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE;;AAEjE;AACA;AACA;AACA,iEAAiE;AACjE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;;AAEf;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;;AAEA;AACA;AACA,sFAAsF;AACtF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;;AAExB;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iIAAiI;AACjI;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,0EAA0E;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B,iBAAiB,GAAG;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE;AACjE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,WAAW;AAC5B,iBAAiB,GAAG;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA,0BAA0B,iBAAiB;AAC3C;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,kDAAkD;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;;AAEA;AACA;AACA;AACA,0BAA0B,iBAAiB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,sBAAsB;AAChD;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;;AAEA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,yCAAyC;AACzC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA,gPAAgP;AAChP;AACA,iBAAiB;AACjB;AACA;AACA;AACA,YAAY;AACZ,sCAAsC;AACtC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,eAAe;AACf,cAAc;AACd;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA,kBAAkB,yBAAyB;AAC3C,mBAAmB,sBAAsB;AACzC;;AAEA;;AAEA;AACA;AACA,kBAAkB,0BAA0B;AAC5C,mBAAmB,uBAAuB;AAC1C;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;;AAExC;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA,0CAA0C;;AAE1C,2CAA2C;;AAE3C;AACA;AACA,wCAAwC;;AAExC,qDAAqD;;AAErD;AACA,2BAA2B;;AAE3B,6BAA6B;AAC7B;AACA,iDAAiD;;AAEjD;AACA;AACA,0CAA0C;;AAE1C;AACA;AACA,yFAAyF;;AAEzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,uBAAuB;AAClD;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;;AAEd;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA,mCAAmC;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;;AAEA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA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","sources":["webpack://lib-app/../base-lib-bundle/dist/index.js"],"sourcesContent":["(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global[\"base-lib-bundle\"] = {}));\n})(this, (function (exports) { 'use strict';\n\n\tfunction getDefaultExportFromCjs (x) {\n\t\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n\t}\n\n\tvar reactExports = {};\n\tvar react = {\n\t  get exports(){ return reactExports; },\n\t  set exports(v){ reactExports = v; },\n\t};\n\n\tvar react_developmentExports = {};\n\tvar react_development = {\n\t  get exports(){ return react_developmentExports; },\n\t  set exports(v){ react_developmentExports = v; },\n\t};\n\n\t/**\n\t * @license React\n\t * react.development.js\n\t *\n\t * Copyright (c) Facebook, Inc. and its affiliates.\n\t *\n\t * This source code is licensed under the MIT license found in the\n\t * LICENSE file in the root directory of this source tree.\n\t */\n\n\t(function (module, exports) {\n\n\t\t{\n\t\t  (function () {\n\n\t\t    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n\t\t    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === 'function') {\n\t\t      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n\t\t    }\n\t\t    var ReactVersion = '18.2.0';\n\n\t\t    // ATTENTION\n\t\t    // When adding new symbols to this file,\n\t\t    // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n\t\t    // The Symbol used to tag the ReactElement-like types.\n\t\t    var REACT_ELEMENT_TYPE = Symbol.for('react.element');\n\t\t    var REACT_PORTAL_TYPE = Symbol.for('react.portal');\n\t\t    var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\n\t\t    var REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\n\t\t    var REACT_PROFILER_TYPE = Symbol.for('react.profiler');\n\t\t    var REACT_PROVIDER_TYPE = Symbol.for('react.provider');\n\t\t    var REACT_CONTEXT_TYPE = Symbol.for('react.context');\n\t\t    var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\n\t\t    var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\n\t\t    var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\n\t\t    var REACT_MEMO_TYPE = Symbol.for('react.memo');\n\t\t    var REACT_LAZY_TYPE = Symbol.for('react.lazy');\n\t\t    var REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\n\t\t    var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n\t\t    var FAUX_ITERATOR_SYMBOL = '@@iterator';\n\t\t    function getIteratorFn(maybeIterable) {\n\t\t      if (maybeIterable === null || typeof maybeIterable !== 'object') {\n\t\t        return null;\n\t\t      }\n\t\t      var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\t\t      if (typeof maybeIterator === 'function') {\n\t\t        return maybeIterator;\n\t\t      }\n\t\t      return null;\n\t\t    }\n\n\t\t    /**\n\t\t     * Keeps track of the current dispatcher.\n\t\t     */\n\t\t    var ReactCurrentDispatcher = {\n\t\t      /**\n\t\t       * @internal\n\t\t       * @type {ReactComponent}\n\t\t       */\n\t\t      current: null\n\t\t    };\n\n\t\t    /**\n\t\t     * Keeps track of the current batch's configuration such as how long an update\n\t\t     * should suspend for if it needs to.\n\t\t     */\n\t\t    var ReactCurrentBatchConfig = {\n\t\t      transition: null\n\t\t    };\n\t\t    var ReactCurrentActQueue = {\n\t\t      current: null,\n\t\t      // Used to reproduce behavior of `batchedUpdates` in legacy mode.\n\t\t      isBatchingLegacy: false,\n\t\t      didScheduleLegacyUpdate: false\n\t\t    };\n\n\t\t    /**\n\t\t     * Keeps track of the current owner.\n\t\t     *\n\t\t     * The current owner is the component who should own any components that are\n\t\t     * currently being constructed.\n\t\t     */\n\t\t    var ReactCurrentOwner = {\n\t\t      /**\n\t\t       * @internal\n\t\t       * @type {ReactComponent}\n\t\t       */\n\t\t      current: null\n\t\t    };\n\t\t    var ReactDebugCurrentFrame = {};\n\t\t    var currentExtraStackFrame = null;\n\t\t    function setExtraStackFrame(stack) {\n\t\t      {\n\t\t        currentExtraStackFrame = stack;\n\t\t      }\n\t\t    }\n\t\t    {\n\t\t      ReactDebugCurrentFrame.setExtraStackFrame = function (stack) {\n\t\t        {\n\t\t          currentExtraStackFrame = stack;\n\t\t        }\n\t\t      }; // Stack implementation injected by the current renderer.\n\n\t\t      ReactDebugCurrentFrame.getCurrentStack = null;\n\t\t      ReactDebugCurrentFrame.getStackAddendum = function () {\n\t\t        var stack = ''; // Add an extra top frame while an element is being validated\n\n\t\t        if (currentExtraStackFrame) {\n\t\t          stack += currentExtraStackFrame;\n\t\t        } // Delegate to the injected renderer-specific implementation\n\n\t\t        var impl = ReactDebugCurrentFrame.getCurrentStack;\n\t\t        if (impl) {\n\t\t          stack += impl() || '';\n\t\t        }\n\t\t        return stack;\n\t\t      };\n\t\t    }\n\n\t\t    // -----------------------------------------------------------------------------\n\n\t\t    var enableScopeAPI = false; // Experimental Create Event Handle API.\n\t\t    var enableCacheElement = false;\n\t\t    var enableTransitionTracing = false; // No known bugs, but needs performance testing\n\n\t\t    var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n\t\t    // stuff. Intended to enable React core members to more easily debug scheduling\n\t\t    // issues in DEV builds.\n\n\t\t    var enableDebugTracing = false; // Track which Fiber(s) schedule render work.\n\n\t\t    var ReactSharedInternals = {\n\t\t      ReactCurrentDispatcher: ReactCurrentDispatcher,\n\t\t      ReactCurrentBatchConfig: ReactCurrentBatchConfig,\n\t\t      ReactCurrentOwner: ReactCurrentOwner\n\t\t    };\n\t\t    {\n\t\t      ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;\n\t\t      ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;\n\t\t    }\n\n\t\t    // by calls to these methods by a Babel plugin.\n\t\t    //\n\t\t    // In PROD (or in packages without access to React internals),\n\t\t    // they are left as they are instead.\n\n\t\t    function warn(format) {\n\t\t      {\n\t\t        {\n\t\t          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t\t            args[_key - 1] = arguments[_key];\n\t\t          }\n\t\t          printWarning('warn', format, args);\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t    function error(format) {\n\t\t      {\n\t\t        {\n\t\t          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n\t\t            args[_key2 - 1] = arguments[_key2];\n\t\t          }\n\t\t          printWarning('error', format, args);\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t    function printWarning(level, format, args) {\n\t\t      // When changing this logic, you might want to also\n\t\t      // update consoleWithStackDev.www.js as well.\n\t\t      {\n\t\t        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n\t\t        var stack = ReactDebugCurrentFrame.getStackAddendum();\n\t\t        if (stack !== '') {\n\t\t          format += '%s';\n\t\t          args = args.concat([stack]);\n\t\t        } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\t\t        var argsWithFormat = args.map(function (item) {\n\t\t          return String(item);\n\t\t        }); // Careful: RN currently depends on this prefix\n\n\t\t        argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n\t\t        // breaks IE9: https://github.com/facebook/react/issues/13610\n\t\t        // eslint-disable-next-line react-internal/no-production-logging\n\n\t\t        Function.prototype.apply.call(console[level], console, argsWithFormat);\n\t\t      }\n\t\t    }\n\t\t    var didWarnStateUpdateForUnmountedComponent = {};\n\t\t    function warnNoop(publicInstance, callerName) {\n\t\t      {\n\t\t        var _constructor = publicInstance.constructor;\n\t\t        var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';\n\t\t        var warningKey = componentName + \".\" + callerName;\n\t\t        if (didWarnStateUpdateForUnmountedComponent[warningKey]) {\n\t\t          return;\n\t\t        }\n\t\t        error(\"Can't call %s on a component that is not yet mounted. \" + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = {};` ' + 'class property with the desired state in the %s component.', callerName, componentName);\n\t\t        didWarnStateUpdateForUnmountedComponent[warningKey] = true;\n\t\t      }\n\t\t    }\n\t\t    /**\n\t\t     * This is the abstract API for an update queue.\n\t\t     */\n\n\t\t    var ReactNoopUpdateQueue = {\n\t\t      /**\n\t\t       * Checks whether or not this composite component is mounted.\n\t\t       * @param {ReactClass} publicInstance The instance we want to test.\n\t\t       * @return {boolean} True if mounted, false otherwise.\n\t\t       * @protected\n\t\t       * @final\n\t\t       */\n\t\t      isMounted: function (publicInstance) {\n\t\t        return false;\n\t\t      },\n\t\t      /**\n\t\t       * Forces an update. This should only be invoked when it is known with\n\t\t       * certainty that we are **not** in a DOM transaction.\n\t\t       *\n\t\t       * You may want to call this when you know that some deeper aspect of the\n\t\t       * component's state has changed but `setState` was not called.\n\t\t       *\n\t\t       * This will not invoke `shouldComponentUpdate`, but it will invoke\n\t\t       * `componentWillUpdate` and `componentDidUpdate`.\n\t\t       *\n\t\t       * @param {ReactClass} publicInstance The instance that should rerender.\n\t\t       * @param {?function} callback Called after component is updated.\n\t\t       * @param {?string} callerName name of the calling function in the public API.\n\t\t       * @internal\n\t\t       */\n\t\t      enqueueForceUpdate: function (publicInstance, callback, callerName) {\n\t\t        warnNoop(publicInstance, 'forceUpdate');\n\t\t      },\n\t\t      /**\n\t\t       * Replaces all of the state. Always use this or `setState` to mutate state.\n\t\t       * You should treat `this.state` as immutable.\n\t\t       *\n\t\t       * There is no guarantee that `this.state` will be immediately updated, so\n\t\t       * accessing `this.state` after calling this method may return the old value.\n\t\t       *\n\t\t       * @param {ReactClass} publicInstance The instance that should rerender.\n\t\t       * @param {object} completeState Next state.\n\t\t       * @param {?function} callback Called after component is updated.\n\t\t       * @param {?string} callerName name of the calling function in the public API.\n\t\t       * @internal\n\t\t       */\n\t\t      enqueueReplaceState: function (publicInstance, completeState, callback, callerName) {\n\t\t        warnNoop(publicInstance, 'replaceState');\n\t\t      },\n\t\t      /**\n\t\t       * Sets a subset of the state. This only exists because _pendingState is\n\t\t       * internal. This provides a merging strategy that is not available to deep\n\t\t       * properties which is confusing. TODO: Expose pendingState or don't use it\n\t\t       * during the merge.\n\t\t       *\n\t\t       * @param {ReactClass} publicInstance The instance that should rerender.\n\t\t       * @param {object} partialState Next partial state to be merged with state.\n\t\t       * @param {?function} callback Called after component is updated.\n\t\t       * @param {?string} Name of the calling function in the public API.\n\t\t       * @internal\n\t\t       */\n\t\t      enqueueSetState: function (publicInstance, partialState, callback, callerName) {\n\t\t        warnNoop(publicInstance, 'setState');\n\t\t      }\n\t\t    };\n\t\t    var assign = Object.assign;\n\t\t    var emptyObject = {};\n\t\t    {\n\t\t      Object.freeze(emptyObject);\n\t\t    }\n\t\t    /**\n\t\t     * Base class helpers for the updating state of a component.\n\t\t     */\n\n\t\t    function Component(props, context, updater) {\n\t\t      this.props = props;\n\t\t      this.context = context; // If a component has string refs, we will assign a different object later.\n\n\t\t      this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the\n\t\t      // renderer.\n\n\t\t      this.updater = updater || ReactNoopUpdateQueue;\n\t\t    }\n\t\t    Component.prototype.isReactComponent = {};\n\t\t    /**\n\t\t     * Sets a subset of the state. Always use this to mutate\n\t\t     * state. You should treat `this.state` as immutable.\n\t\t     *\n\t\t     * There is no guarantee that `this.state` will be immediately updated, so\n\t\t     * accessing `this.state` after calling this method may return the old value.\n\t\t     *\n\t\t     * There is no guarantee that calls to `setState` will run synchronously,\n\t\t     * as they may eventually be batched together.  You can provide an optional\n\t\t     * callback that will be executed when the call to setState is actually\n\t\t     * completed.\n\t\t     *\n\t\t     * When a function is provided to setState, it will be called at some point in\n\t\t     * the future (not synchronously). It will be called with the up to date\n\t\t     * component arguments (state, props, context). These values can be different\n\t\t     * from this.* because your function may be called after receiveProps but before\n\t\t     * shouldComponentUpdate, and this new state, props, and context will not yet be\n\t\t     * assigned to this.\n\t\t     *\n\t\t     * @param {object|function} partialState Next partial state or function to\n\t\t     *        produce next partial state to be merged with current state.\n\t\t     * @param {?function} callback Called after state is updated.\n\t\t     * @final\n\t\t     * @protected\n\t\t     */\n\n\t\t    Component.prototype.setState = function (partialState, callback) {\n\t\t      if (typeof partialState !== 'object' && typeof partialState !== 'function' && partialState != null) {\n\t\t        throw new Error('setState(...): takes an object of state variables to update or a ' + 'function which returns an object of state variables.');\n\t\t      }\n\t\t      this.updater.enqueueSetState(this, partialState, callback, 'setState');\n\t\t    };\n\t\t    /**\n\t\t     * Forces an update. This should only be invoked when it is known with\n\t\t     * certainty that we are **not** in a DOM transaction.\n\t\t     *\n\t\t     * You may want to call this when you know that some deeper aspect of the\n\t\t     * component's state has changed but `setState` was not called.\n\t\t     *\n\t\t     * This will not invoke `shouldComponentUpdate`, but it will invoke\n\t\t     * `componentWillUpdate` and `componentDidUpdate`.\n\t\t     *\n\t\t     * @param {?function} callback Called after update is complete.\n\t\t     * @final\n\t\t     * @protected\n\t\t     */\n\n\t\t    Component.prototype.forceUpdate = function (callback) {\n\t\t      this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');\n\t\t    };\n\t\t    /**\n\t\t     * Deprecated APIs. These APIs used to exist on classic React classes but since\n\t\t     * we would like to deprecate them, we're not going to move them over to this\n\t\t     * modern base class. Instead, we define a getter that warns if it's accessed.\n\t\t     */\n\n\t\t    {\n\t\t      var deprecatedAPIs = {\n\t\t        isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],\n\t\t        replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']\n\t\t      };\n\t\t      var defineDeprecationWarning = function (methodName, info) {\n\t\t        Object.defineProperty(Component.prototype, methodName, {\n\t\t          get: function () {\n\t\t            warn('%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);\n\t\t            return undefined;\n\t\t          }\n\t\t        });\n\t\t      };\n\t\t      for (var fnName in deprecatedAPIs) {\n\t\t        if (deprecatedAPIs.hasOwnProperty(fnName)) {\n\t\t          defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t    function ComponentDummy() {}\n\t\t    ComponentDummy.prototype = Component.prototype;\n\t\t    /**\n\t\t     * Convenience component with default shallow equality check for sCU.\n\t\t     */\n\n\t\t    function PureComponent(props, context, updater) {\n\t\t      this.props = props;\n\t\t      this.context = context; // If a component has string refs, we will assign a different object later.\n\n\t\t      this.refs = emptyObject;\n\t\t      this.updater = updater || ReactNoopUpdateQueue;\n\t\t    }\n\t\t    var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();\n\t\t    pureComponentPrototype.constructor = PureComponent; // Avoid an extra prototype jump for these methods.\n\n\t\t    assign(pureComponentPrototype, Component.prototype);\n\t\t    pureComponentPrototype.isPureReactComponent = true;\n\n\t\t    // an immutable object with a single mutable value\n\t\t    function createRef() {\n\t\t      var refObject = {\n\t\t        current: null\n\t\t      };\n\t\t      {\n\t\t        Object.seal(refObject);\n\t\t      }\n\t\t      return refObject;\n\t\t    }\n\t\t    var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\n\t\t    function isArray(a) {\n\t\t      return isArrayImpl(a);\n\t\t    }\n\n\t\t    /*\n\t\t     * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol\n\t\t     * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n\t\t     *\n\t\t     * The functions in this module will throw an easier-to-understand,\n\t\t     * easier-to-debug exception with a clear errors message message explaining the\n\t\t     * problem. (Instead of a confusing exception thrown inside the implementation\n\t\t     * of the `value` object).\n\t\t     */\n\t\t    // $FlowFixMe only called in DEV, so void return is not possible.\n\t\t    function typeName(value) {\n\t\t      {\n\t\t        // toStringTag is needed for namespaced types like Temporal.Instant\n\t\t        var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n\t\t        var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';\n\t\t        return type;\n\t\t      }\n\t\t    } // $FlowFixMe only called in DEV, so void return is not possible.\n\n\t\t    function willCoercionThrow(value) {\n\t\t      {\n\t\t        try {\n\t\t          testStringCoercion(value);\n\t\t          return false;\n\t\t        } catch (e) {\n\t\t          return true;\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t    function testStringCoercion(value) {\n\t\t      // If you ended up here by following an exception call stack, here's what's\n\t\t      // happened: you supplied an object or symbol value to React (as a prop, key,\n\t\t      // DOM attribute, CSS property, string ref, etc.) and when React tried to\n\t\t      // coerce it to a string using `'' + value`, an exception was thrown.\n\t\t      //\n\t\t      // The most common types that will cause this exception are `Symbol` instances\n\t\t      // and Temporal objects like `Temporal.Instant`. But any object that has a\n\t\t      // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n\t\t      // exception. (Library authors do this to prevent users from using built-in\n\t\t      // numeric operators like `+` or comparison operators like `>=` because custom\n\t\t      // methods are needed to perform accurate arithmetic or comparison.)\n\t\t      //\n\t\t      // To fix the problem, coerce this object or symbol value to a string before\n\t\t      // passing it to React. The most reliable way is usually `String(value)`.\n\t\t      //\n\t\t      // To find which value is throwing, check the browser or debugger console.\n\t\t      // Before this exception was thrown, there should be `console.error` output\n\t\t      // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n\t\t      // problem and how that type was used: key, atrribute, input value prop, etc.\n\t\t      // In most cases, this console output also shows the component and its\n\t\t      // ancestor components where the exception happened.\n\t\t      //\n\t\t      // eslint-disable-next-line react-internal/safe-string-coercion\n\t\t      return '' + value;\n\t\t    }\n\t\t    function checkKeyStringCoercion(value) {\n\t\t      {\n\t\t        if (willCoercionThrow(value)) {\n\t\t          error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));\n\t\t          return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n\t\t        }\n\t\t      }\n\t\t    }\n\n\t\t    function getWrappedName(outerType, innerType, wrapperName) {\n\t\t      var displayName = outerType.displayName;\n\t\t      if (displayName) {\n\t\t        return displayName;\n\t\t      }\n\t\t      var functionName = innerType.displayName || innerType.name || '';\n\t\t      return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n\t\t    } // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\t\t    function getContextName(type) {\n\t\t      return type.displayName || 'Context';\n\t\t    } // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\n\t\t    function getComponentNameFromType(type) {\n\t\t      if (type == null) {\n\t\t        // Host root, text node or just invalid type.\n\t\t        return null;\n\t\t      }\n\t\t      {\n\t\t        if (typeof type.tag === 'number') {\n\t\t          error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n\t\t        }\n\t\t      }\n\t\t      if (typeof type === 'function') {\n\t\t        return type.displayName || type.name || null;\n\t\t      }\n\t\t      if (typeof type === 'string') {\n\t\t        return type;\n\t\t      }\n\t\t      switch (type) {\n\t\t        case REACT_FRAGMENT_TYPE:\n\t\t          return 'Fragment';\n\t\t        case REACT_PORTAL_TYPE:\n\t\t          return 'Portal';\n\t\t        case REACT_PROFILER_TYPE:\n\t\t          return 'Profiler';\n\t\t        case REACT_STRICT_MODE_TYPE:\n\t\t          return 'StrictMode';\n\t\t        case REACT_SUSPENSE_TYPE:\n\t\t          return 'Suspense';\n\t\t        case REACT_SUSPENSE_LIST_TYPE:\n\t\t          return 'SuspenseList';\n\t\t      }\n\t\t      if (typeof type === 'object') {\n\t\t        switch (type.$$typeof) {\n\t\t          case REACT_CONTEXT_TYPE:\n\t\t            var context = type;\n\t\t            return getContextName(context) + '.Consumer';\n\t\t          case REACT_PROVIDER_TYPE:\n\t\t            var provider = type;\n\t\t            return getContextName(provider._context) + '.Provider';\n\t\t          case REACT_FORWARD_REF_TYPE:\n\t\t            return getWrappedName(type, type.render, 'ForwardRef');\n\t\t          case REACT_MEMO_TYPE:\n\t\t            var outerName = type.displayName || null;\n\t\t            if (outerName !== null) {\n\t\t              return outerName;\n\t\t            }\n\t\t            return getComponentNameFromType(type.type) || 'Memo';\n\t\t          case REACT_LAZY_TYPE:\n\t\t            {\n\t\t              var lazyComponent = type;\n\t\t              var payload = lazyComponent._payload;\n\t\t              var init = lazyComponent._init;\n\t\t              try {\n\t\t                return getComponentNameFromType(init(payload));\n\t\t              } catch (x) {\n\t\t                return null;\n\t\t              }\n\t\t            }\n\n\t\t          // eslint-disable-next-line no-fallthrough\n\t\t        }\n\t\t      }\n\n\t\t      return null;\n\t\t    }\n\t\t    var hasOwnProperty = Object.prototype.hasOwnProperty;\n\t\t    var RESERVED_PROPS = {\n\t\t      key: true,\n\t\t      ref: true,\n\t\t      __self: true,\n\t\t      __source: true\n\t\t    };\n\t\t    var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;\n\t\t    {\n\t\t      didWarnAboutStringRefs = {};\n\t\t    }\n\t\t    function hasValidRef(config) {\n\t\t      {\n\t\t        if (hasOwnProperty.call(config, 'ref')) {\n\t\t          var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\t\t          if (getter && getter.isReactWarning) {\n\t\t            return false;\n\t\t          }\n\t\t        }\n\t\t      }\n\t\t      return config.ref !== undefined;\n\t\t    }\n\t\t    function hasValidKey(config) {\n\t\t      {\n\t\t        if (hasOwnProperty.call(config, 'key')) {\n\t\t          var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\t\t          if (getter && getter.isReactWarning) {\n\t\t            return false;\n\t\t          }\n\t\t        }\n\t\t      }\n\t\t      return config.key !== undefined;\n\t\t    }\n\t\t    function defineKeyPropWarningGetter(props, displayName) {\n\t\t      var warnAboutAccessingKey = function () {\n\t\t        {\n\t\t          if (!specialPropKeyWarningShown) {\n\t\t            specialPropKeyWarningShown = true;\n\t\t            error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n\t\t          }\n\t\t        }\n\t\t      };\n\t\t      warnAboutAccessingKey.isReactWarning = true;\n\t\t      Object.defineProperty(props, 'key', {\n\t\t        get: warnAboutAccessingKey,\n\t\t        configurable: true\n\t\t      });\n\t\t    }\n\t\t    function defineRefPropWarningGetter(props, displayName) {\n\t\t      var warnAboutAccessingRef = function () {\n\t\t        {\n\t\t          if (!specialPropRefWarningShown) {\n\t\t            specialPropRefWarningShown = true;\n\t\t            error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n\t\t          }\n\t\t        }\n\t\t      };\n\t\t      warnAboutAccessingRef.isReactWarning = true;\n\t\t      Object.defineProperty(props, 'ref', {\n\t\t        get: warnAboutAccessingRef,\n\t\t        configurable: true\n\t\t      });\n\t\t    }\n\t\t    function warnIfStringRefCannotBeAutoConverted(config) {\n\t\t      {\n\t\t        if (typeof config.ref === 'string' && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {\n\t\t          var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n\t\t          if (!didWarnAboutStringRefs[componentName]) {\n\t\t            error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);\n\t\t            didWarnAboutStringRefs[componentName] = true;\n\t\t          }\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t    /**\n\t\t     * Factory method to create a new React element. This no longer adheres to\n\t\t     * the class pattern, so do not use new to call it. Also, instanceof check\n\t\t     * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n\t\t     * if something is a React Element.\n\t\t     *\n\t\t     * @param {*} type\n\t\t     * @param {*} props\n\t\t     * @param {*} key\n\t\t     * @param {string|object} ref\n\t\t     * @param {*} owner\n\t\t     * @param {*} self A *temporary* helper to detect places where `this` is\n\t\t     * different from the `owner` when React.createElement is called, so that we\n\t\t     * can warn. We want to get rid of owner and replace string `ref`s with arrow\n\t\t     * functions, and as long as `this` and owner are the same, there will be no\n\t\t     * change in behavior.\n\t\t     * @param {*} source An annotation object (added by a transpiler or otherwise)\n\t\t     * indicating filename, line number, and/or other information.\n\t\t     * @internal\n\t\t     */\n\n\t\t    var ReactElement = function (type, key, ref, self, source, owner, props) {\n\t\t      var element = {\n\t\t        // This tag allows us to uniquely identify this as a React Element\n\t\t        $$typeof: REACT_ELEMENT_TYPE,\n\t\t        // Built-in properties that belong on the element\n\t\t        type: type,\n\t\t        key: key,\n\t\t        ref: ref,\n\t\t        props: props,\n\t\t        // Record the component responsible for creating this element.\n\t\t        _owner: owner\n\t\t      };\n\t\t      {\n\t\t        // The validation flag is currently mutative. We put it on\n\t\t        // an external backing store so that we can freeze the whole object.\n\t\t        // This can be replaced with a WeakMap once they are implemented in\n\t\t        // commonly used development environments.\n\t\t        element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n\t\t        // the validation flag non-enumerable (where possible, which should\n\t\t        // include every environment we run tests in), so the test framework\n\t\t        // ignores it.\n\n\t\t        Object.defineProperty(element._store, 'validated', {\n\t\t          configurable: false,\n\t\t          enumerable: false,\n\t\t          writable: true,\n\t\t          value: false\n\t\t        }); // self and source are DEV only properties.\n\n\t\t        Object.defineProperty(element, '_self', {\n\t\t          configurable: false,\n\t\t          enumerable: false,\n\t\t          writable: false,\n\t\t          value: self\n\t\t        }); // Two elements created in two different places should be considered\n\t\t        // equal for testing purposes and therefore we hide it from enumeration.\n\n\t\t        Object.defineProperty(element, '_source', {\n\t\t          configurable: false,\n\t\t          enumerable: false,\n\t\t          writable: false,\n\t\t          value: source\n\t\t        });\n\t\t        if (Object.freeze) {\n\t\t          Object.freeze(element.props);\n\t\t          Object.freeze(element);\n\t\t        }\n\t\t      }\n\t\t      return element;\n\t\t    };\n\t\t    /**\n\t\t     * Create and return a new ReactElement of the given type.\n\t\t     * See https://reactjs.org/docs/react-api.html#createelement\n\t\t     */\n\n\t\t    function createElement(type, config, children) {\n\t\t      var propName; // Reserved names are extracted\n\n\t\t      var props = {};\n\t\t      var key = null;\n\t\t      var ref = null;\n\t\t      var self = null;\n\t\t      var source = null;\n\t\t      if (config != null) {\n\t\t        if (hasValidRef(config)) {\n\t\t          ref = config.ref;\n\t\t          {\n\t\t            warnIfStringRefCannotBeAutoConverted(config);\n\t\t          }\n\t\t        }\n\t\t        if (hasValidKey(config)) {\n\t\t          {\n\t\t            checkKeyStringCoercion(config.key);\n\t\t          }\n\t\t          key = '' + config.key;\n\t\t        }\n\t\t        self = config.__self === undefined ? null : config.__self;\n\t\t        source = config.__source === undefined ? null : config.__source; // Remaining properties are added to a new props object\n\n\t\t        for (propName in config) {\n\t\t          if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n\t\t            props[propName] = config[propName];\n\t\t          }\n\t\t        }\n\t\t      } // Children can be more than one argument, and those are transferred onto\n\t\t      // the newly allocated props object.\n\n\t\t      var childrenLength = arguments.length - 2;\n\t\t      if (childrenLength === 1) {\n\t\t        props.children = children;\n\t\t      } else if (childrenLength > 1) {\n\t\t        var childArray = Array(childrenLength);\n\t\t        for (var i = 0; i < childrenLength; i++) {\n\t\t          childArray[i] = arguments[i + 2];\n\t\t        }\n\t\t        {\n\t\t          if (Object.freeze) {\n\t\t            Object.freeze(childArray);\n\t\t          }\n\t\t        }\n\t\t        props.children = childArray;\n\t\t      } // Resolve default props\n\n\t\t      if (type && type.defaultProps) {\n\t\t        var defaultProps = type.defaultProps;\n\t\t        for (propName in defaultProps) {\n\t\t          if (props[propName] === undefined) {\n\t\t            props[propName] = defaultProps[propName];\n\t\t          }\n\t\t        }\n\t\t      }\n\t\t      {\n\t\t        if (key || ref) {\n\t\t          var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\t\t          if (key) {\n\t\t            defineKeyPropWarningGetter(props, displayName);\n\t\t          }\n\t\t          if (ref) {\n\t\t            defineRefPropWarningGetter(props, displayName);\n\t\t          }\n\t\t        }\n\t\t      }\n\t\t      return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n\t\t    }\n\t\t    function cloneAndReplaceKey(oldElement, newKey) {\n\t\t      var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);\n\t\t      return newElement;\n\t\t    }\n\t\t    /**\n\t\t     * Clone and return a new ReactElement using element as the starting point.\n\t\t     * See https://reactjs.org/docs/react-api.html#cloneelement\n\t\t     */\n\n\t\t    function cloneElement(element, config, children) {\n\t\t      if (element === null || element === undefined) {\n\t\t        throw new Error(\"React.cloneElement(...): The argument must be a React element, but you passed \" + element + \".\");\n\t\t      }\n\t\t      var propName; // Original props are copied\n\n\t\t      var props = assign({}, element.props); // Reserved names are extracted\n\n\t\t      var key = element.key;\n\t\t      var ref = element.ref; // Self is preserved since the owner is preserved.\n\n\t\t      var self = element._self; // Source is preserved since cloneElement is unlikely to be targeted by a\n\t\t      // transpiler, and the original source is probably a better indicator of the\n\t\t      // true owner.\n\n\t\t      var source = element._source; // Owner will be preserved, unless ref is overridden\n\n\t\t      var owner = element._owner;\n\t\t      if (config != null) {\n\t\t        if (hasValidRef(config)) {\n\t\t          // Silently steal the ref from the parent.\n\t\t          ref = config.ref;\n\t\t          owner = ReactCurrentOwner.current;\n\t\t        }\n\t\t        if (hasValidKey(config)) {\n\t\t          {\n\t\t            checkKeyStringCoercion(config.key);\n\t\t          }\n\t\t          key = '' + config.key;\n\t\t        } // Remaining properties override existing props\n\n\t\t        var defaultProps;\n\t\t        if (element.type && element.type.defaultProps) {\n\t\t          defaultProps = element.type.defaultProps;\n\t\t        }\n\t\t        for (propName in config) {\n\t\t          if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n\t\t            if (config[propName] === undefined && defaultProps !== undefined) {\n\t\t              // Resolve default props\n\t\t              props[propName] = defaultProps[propName];\n\t\t            } else {\n\t\t              props[propName] = config[propName];\n\t\t            }\n\t\t          }\n\t\t        }\n\t\t      } // Children can be more than one argument, and those are transferred onto\n\t\t      // the newly allocated props object.\n\n\t\t      var childrenLength = arguments.length - 2;\n\t\t      if (childrenLength === 1) {\n\t\t        props.children = children;\n\t\t      } else if (childrenLength > 1) {\n\t\t        var childArray = Array(childrenLength);\n\t\t        for (var i = 0; i < childrenLength; i++) {\n\t\t          childArray[i] = arguments[i + 2];\n\t\t        }\n\t\t        props.children = childArray;\n\t\t      }\n\t\t      return ReactElement(element.type, key, ref, self, source, owner, props);\n\t\t    }\n\t\t    /**\n\t\t     * Verifies the object is a ReactElement.\n\t\t     * See https://reactjs.org/docs/react-api.html#isvalidelement\n\t\t     * @param {?object} object\n\t\t     * @return {boolean} True if `object` is a ReactElement.\n\t\t     * @final\n\t\t     */\n\n\t\t    function isValidElement(object) {\n\t\t      return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n\t\t    }\n\t\t    var SEPARATOR = '.';\n\t\t    var SUBSEPARATOR = ':';\n\t\t    /**\n\t\t     * Escape and wrap key so it is safe to use as a reactid\n\t\t     *\n\t\t     * @param {string} key to be escaped.\n\t\t     * @return {string} the escaped key.\n\t\t     */\n\n\t\t    function escape(key) {\n\t\t      var escapeRegex = /[=:]/g;\n\t\t      var escaperLookup = {\n\t\t        '=': '=0',\n\t\t        ':': '=2'\n\t\t      };\n\t\t      var escapedString = key.replace(escapeRegex, function (match) {\n\t\t        return escaperLookup[match];\n\t\t      });\n\t\t      return '$' + escapedString;\n\t\t    }\n\t\t    /**\n\t\t     * TODO: Test that a single child and an array with one item have the same key\n\t\t     * pattern.\n\t\t     */\n\n\t\t    var didWarnAboutMaps = false;\n\t\t    var userProvidedKeyEscapeRegex = /\\/+/g;\n\t\t    function escapeUserProvidedKey(text) {\n\t\t      return text.replace(userProvidedKeyEscapeRegex, '$&/');\n\t\t    }\n\t\t    /**\n\t\t     * Generate a key string that identifies a element within a set.\n\t\t     *\n\t\t     * @param {*} element A element that could contain a manual key.\n\t\t     * @param {number} index Index that is used if a manual key is not provided.\n\t\t     * @return {string}\n\t\t     */\n\n\t\t    function getElementKey(element, index) {\n\t\t      // Do some typechecking here since we call this blindly. We want to ensure\n\t\t      // that we don't block potential future ES APIs.\n\t\t      if (typeof element === 'object' && element !== null && element.key != null) {\n\t\t        // Explicit key\n\t\t        {\n\t\t          checkKeyStringCoercion(element.key);\n\t\t        }\n\t\t        return escape('' + element.key);\n\t\t      } // Implicit key determined by the index in the set\n\n\t\t      return index.toString(36);\n\t\t    }\n\t\t    function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {\n\t\t      var type = typeof children;\n\t\t      if (type === 'undefined' || type === 'boolean') {\n\t\t        // All of the above are perceived as null.\n\t\t        children = null;\n\t\t      }\n\t\t      var invokeCallback = false;\n\t\t      if (children === null) {\n\t\t        invokeCallback = true;\n\t\t      } else {\n\t\t        switch (type) {\n\t\t          case 'string':\n\t\t          case 'number':\n\t\t            invokeCallback = true;\n\t\t            break;\n\t\t          case 'object':\n\t\t            switch (children.$$typeof) {\n\t\t              case REACT_ELEMENT_TYPE:\n\t\t              case REACT_PORTAL_TYPE:\n\t\t                invokeCallback = true;\n\t\t            }\n\t\t        }\n\t\t      }\n\t\t      if (invokeCallback) {\n\t\t        var _child = children;\n\t\t        var mappedChild = callback(_child); // If it's the only child, treat the name as if it was wrapped in an array\n\t\t        // so that it's consistent if the number of children grows:\n\n\t\t        var childKey = nameSoFar === '' ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;\n\t\t        if (isArray(mappedChild)) {\n\t\t          var escapedChildKey = '';\n\t\t          if (childKey != null) {\n\t\t            escapedChildKey = escapeUserProvidedKey(childKey) + '/';\n\t\t          }\n\t\t          mapIntoArray(mappedChild, array, escapedChildKey, '', function (c) {\n\t\t            return c;\n\t\t          });\n\t\t        } else if (mappedChild != null) {\n\t\t          if (isValidElement(mappedChild)) {\n\t\t            {\n\t\t              // The `if` statement here prevents auto-disabling of the safe\n\t\t              // coercion ESLint rule, so we must manually disable it below.\n\t\t              // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key\n\t\t              if (mappedChild.key && (!_child || _child.key !== mappedChild.key)) {\n\t\t                checkKeyStringCoercion(mappedChild.key);\n\t\t              }\n\t\t            }\n\t\t            mappedChild = cloneAndReplaceKey(mappedChild,\n\t\t            // Keep both the (mapped) and old keys if they differ, just as\n\t\t            // traverseAllChildren used to do for objects as children\n\t\t            escapedPrefix + (\n\t\t            // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key\n\t\t            mappedChild.key && (!_child || _child.key !== mappedChild.key) ?\n\t\t            // $FlowFixMe Flow incorrectly thinks existing element's key can be a number\n\t\t            // eslint-disable-next-line react-internal/safe-string-coercion\n\t\t            escapeUserProvidedKey('' + mappedChild.key) + '/' : '') + childKey);\n\t\t          }\n\t\t          array.push(mappedChild);\n\t\t        }\n\t\t        return 1;\n\t\t      }\n\t\t      var child;\n\t\t      var nextName;\n\t\t      var subtreeCount = 0; // Count of children found in the current subtree.\n\n\t\t      var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;\n\t\t      if (isArray(children)) {\n\t\t        for (var i = 0; i < children.length; i++) {\n\t\t          child = children[i];\n\t\t          nextName = nextNamePrefix + getElementKey(child, i);\n\t\t          subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);\n\t\t        }\n\t\t      } else {\n\t\t        var iteratorFn = getIteratorFn(children);\n\t\t        if (typeof iteratorFn === 'function') {\n\t\t          var iterableChildren = children;\n\t\t          {\n\t\t            // Warn about using Maps as children\n\t\t            if (iteratorFn === iterableChildren.entries) {\n\t\t              if (!didWarnAboutMaps) {\n\t\t                warn('Using Maps as children is not supported. ' + 'Use an array of keyed ReactElements instead.');\n\t\t              }\n\t\t              didWarnAboutMaps = true;\n\t\t            }\n\t\t          }\n\t\t          var iterator = iteratorFn.call(iterableChildren);\n\t\t          var step;\n\t\t          var ii = 0;\n\t\t          while (!(step = iterator.next()).done) {\n\t\t            child = step.value;\n\t\t            nextName = nextNamePrefix + getElementKey(child, ii++);\n\t\t            subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);\n\t\t          }\n\t\t        } else if (type === 'object') {\n\t\t          // eslint-disable-next-line react-internal/safe-string-coercion\n\t\t          var childrenString = String(children);\n\t\t          throw new Error(\"Objects are not valid as a React child (found: \" + (childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString) + \"). \" + 'If you meant to render a collection of children, use an array ' + 'instead.');\n\t\t        }\n\t\t      }\n\t\t      return subtreeCount;\n\t\t    }\n\n\t\t    /**\n\t\t     * Maps children that are typically specified as `props.children`.\n\t\t     *\n\t\t     * See https://reactjs.org/docs/react-api.html#reactchildrenmap\n\t\t     *\n\t\t     * The provided mapFunction(child, index) will be called for each\n\t\t     * leaf child.\n\t\t     *\n\t\t     * @param {?*} children Children tree container.\n\t\t     * @param {function(*, int)} func The map function.\n\t\t     * @param {*} context Context for mapFunction.\n\t\t     * @return {object} Object containing the ordered map of results.\n\t\t     */\n\t\t    function mapChildren(children, func, context) {\n\t\t      if (children == null) {\n\t\t        return children;\n\t\t      }\n\t\t      var result = [];\n\t\t      var count = 0;\n\t\t      mapIntoArray(children, result, '', '', function (child) {\n\t\t        return func.call(context, child, count++);\n\t\t      });\n\t\t      return result;\n\t\t    }\n\t\t    /**\n\t\t     * Count the number of children that are typically specified as\n\t\t     * `props.children`.\n\t\t     *\n\t\t     * See https://reactjs.org/docs/react-api.html#reactchildrencount\n\t\t     *\n\t\t     * @param {?*} children Children tree container.\n\t\t     * @return {number} The number of children.\n\t\t     */\n\n\t\t    function countChildren(children) {\n\t\t      var n = 0;\n\t\t      mapChildren(children, function () {\n\t\t        n++; // Don't return anything\n\t\t      });\n\n\t\t      return n;\n\t\t    }\n\n\t\t    /**\n\t\t     * Iterates through children that are typically specified as `props.children`.\n\t\t     *\n\t\t     * See https://reactjs.org/docs/react-api.html#reactchildrenforeach\n\t\t     *\n\t\t     * The provided forEachFunc(child, index) will be called for each\n\t\t     * leaf child.\n\t\t     *\n\t\t     * @param {?*} children Children tree container.\n\t\t     * @param {function(*, int)} forEachFunc\n\t\t     * @param {*} forEachContext Context for forEachContext.\n\t\t     */\n\t\t    function forEachChildren(children, forEachFunc, forEachContext) {\n\t\t      mapChildren(children, function () {\n\t\t        forEachFunc.apply(this, arguments); // Don't return anything.\n\t\t      }, forEachContext);\n\t\t    }\n\t\t    /**\n\t\t     * Flatten a children object (typically specified as `props.children`) and\n\t\t     * return an array with appropriately re-keyed children.\n\t\t     *\n\t\t     * See https://reactjs.org/docs/react-api.html#reactchildrentoarray\n\t\t     */\n\n\t\t    function toArray(children) {\n\t\t      return mapChildren(children, function (child) {\n\t\t        return child;\n\t\t      }) || [];\n\t\t    }\n\t\t    /**\n\t\t     * Returns the first child in a collection of children and verifies that there\n\t\t     * is only one child in the collection.\n\t\t     *\n\t\t     * See https://reactjs.org/docs/react-api.html#reactchildrenonly\n\t\t     *\n\t\t     * The current implementation of this function assumes that a single child gets\n\t\t     * passed without a wrapper, but the purpose of this helper function is to\n\t\t     * abstract away the particular structure of children.\n\t\t     *\n\t\t     * @param {?object} children Child collection structure.\n\t\t     * @return {ReactElement} The first and only `ReactElement` contained in the\n\t\t     * structure.\n\t\t     */\n\n\t\t    function onlyChild(children) {\n\t\t      if (!isValidElement(children)) {\n\t\t        throw new Error('React.Children.only expected to receive a single React element child.');\n\t\t      }\n\t\t      return children;\n\t\t    }\n\t\t    function createContext(defaultValue) {\n\t\t      // TODO: Second argument used to be an optional `calculateChangedBits`\n\t\t      // function. Warn to reserve for future use?\n\t\t      var context = {\n\t\t        $$typeof: REACT_CONTEXT_TYPE,\n\t\t        // As a workaround to support multiple concurrent renderers, we categorize\n\t\t        // some renderers as primary and others as secondary. We only expect\n\t\t        // there to be two concurrent renderers at most: React Native (primary) and\n\t\t        // Fabric (secondary); React DOM (primary) and React ART (secondary).\n\t\t        // Secondary renderers store their context values on separate fields.\n\t\t        _currentValue: defaultValue,\n\t\t        _currentValue2: defaultValue,\n\t\t        // Used to track how many concurrent renderers this context currently\n\t\t        // supports within in a single renderer. Such as parallel server rendering.\n\t\t        _threadCount: 0,\n\t\t        // These are circular\n\t\t        Provider: null,\n\t\t        Consumer: null,\n\t\t        // Add these to use same hidden class in VM as ServerContext\n\t\t        _defaultValue: null,\n\t\t        _globalName: null\n\t\t      };\n\t\t      context.Provider = {\n\t\t        $$typeof: REACT_PROVIDER_TYPE,\n\t\t        _context: context\n\t\t      };\n\t\t      var hasWarnedAboutUsingNestedContextConsumers = false;\n\t\t      var hasWarnedAboutUsingConsumerProvider = false;\n\t\t      var hasWarnedAboutDisplayNameOnConsumer = false;\n\t\t      {\n\t\t        // A separate object, but proxies back to the original context object for\n\t\t        // backwards compatibility. It has a different $$typeof, so we can properly\n\t\t        // warn for the incorrect usage of Context as a Consumer.\n\t\t        var Consumer = {\n\t\t          $$typeof: REACT_CONTEXT_TYPE,\n\t\t          _context: context\n\t\t        }; // $FlowFixMe: Flow complains about not setting a value, which is intentional here\n\n\t\t        Object.defineProperties(Consumer, {\n\t\t          Provider: {\n\t\t            get: function () {\n\t\t              if (!hasWarnedAboutUsingConsumerProvider) {\n\t\t                hasWarnedAboutUsingConsumerProvider = true;\n\t\t                error('Rendering <Context.Consumer.Provider> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Provider> instead?');\n\t\t              }\n\t\t              return context.Provider;\n\t\t            },\n\t\t            set: function (_Provider) {\n\t\t              context.Provider = _Provider;\n\t\t            }\n\t\t          },\n\t\t          _currentValue: {\n\t\t            get: function () {\n\t\t              return context._currentValue;\n\t\t            },\n\t\t            set: function (_currentValue) {\n\t\t              context._currentValue = _currentValue;\n\t\t            }\n\t\t          },\n\t\t          _currentValue2: {\n\t\t            get: function () {\n\t\t              return context._currentValue2;\n\t\t            },\n\t\t            set: function (_currentValue2) {\n\t\t              context._currentValue2 = _currentValue2;\n\t\t            }\n\t\t          },\n\t\t          _threadCount: {\n\t\t            get: function () {\n\t\t              return context._threadCount;\n\t\t            },\n\t\t            set: function (_threadCount) {\n\t\t              context._threadCount = _threadCount;\n\t\t            }\n\t\t          },\n\t\t          Consumer: {\n\t\t            get: function () {\n\t\t              if (!hasWarnedAboutUsingNestedContextConsumers) {\n\t\t                hasWarnedAboutUsingNestedContextConsumers = true;\n\t\t                error('Rendering <Context.Consumer.Consumer> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');\n\t\t              }\n\t\t              return context.Consumer;\n\t\t            }\n\t\t          },\n\t\t          displayName: {\n\t\t            get: function () {\n\t\t              return context.displayName;\n\t\t            },\n\t\t            set: function (displayName) {\n\t\t              if (!hasWarnedAboutDisplayNameOnConsumer) {\n\t\t                warn('Setting `displayName` on Context.Consumer has no effect. ' + \"You should set it directly on the context with Context.displayName = '%s'.\", displayName);\n\t\t                hasWarnedAboutDisplayNameOnConsumer = true;\n\t\t              }\n\t\t            }\n\t\t          }\n\t\t        }); // $FlowFixMe: Flow complains about missing properties because it doesn't understand defineProperty\n\n\t\t        context.Consumer = Consumer;\n\t\t      }\n\t\t      {\n\t\t        context._currentRenderer = null;\n\t\t        context._currentRenderer2 = null;\n\t\t      }\n\t\t      return context;\n\t\t    }\n\t\t    var Uninitialized = -1;\n\t\t    var Pending = 0;\n\t\t    var Resolved = 1;\n\t\t    var Rejected = 2;\n\t\t    function lazyInitializer(payload) {\n\t\t      if (payload._status === Uninitialized) {\n\t\t        var ctor = payload._result;\n\t\t        var thenable = ctor(); // Transition to the next state.\n\t\t        // This might throw either because it's missing or throws. If so, we treat it\n\t\t        // as still uninitialized and try again next time. Which is the same as what\n\t\t        // happens if the ctor or any wrappers processing the ctor throws. This might\n\t\t        // end up fixing it if the resolution was a concurrency bug.\n\n\t\t        thenable.then(function (moduleObject) {\n\t\t          if (payload._status === Pending || payload._status === Uninitialized) {\n\t\t            // Transition to the next state.\n\t\t            var resolved = payload;\n\t\t            resolved._status = Resolved;\n\t\t            resolved._result = moduleObject;\n\t\t          }\n\t\t        }, function (error) {\n\t\t          if (payload._status === Pending || payload._status === Uninitialized) {\n\t\t            // Transition to the next state.\n\t\t            var rejected = payload;\n\t\t            rejected._status = Rejected;\n\t\t            rejected._result = error;\n\t\t          }\n\t\t        });\n\t\t        if (payload._status === Uninitialized) {\n\t\t          // In case, we're still uninitialized, then we're waiting for the thenable\n\t\t          // to resolve. Set it as pending in the meantime.\n\t\t          var pending = payload;\n\t\t          pending._status = Pending;\n\t\t          pending._result = thenable;\n\t\t        }\n\t\t      }\n\t\t      if (payload._status === Resolved) {\n\t\t        var moduleObject = payload._result;\n\t\t        {\n\t\t          if (moduleObject === undefined) {\n\t\t            error('lazy: Expected the result of a dynamic imp' + 'ort() call. ' + 'Instead received: %s\\n\\nYour code should look like: \\n  ' +\n\t\t            // Break up imports to avoid accidentally parsing them as dependencies.\n\t\t            'const MyComponent = lazy(() => imp' + \"ort('./MyComponent'))\\n\\n\" + 'Did you accidentally put curly braces around the import?', moduleObject);\n\t\t          }\n\t\t        }\n\t\t        {\n\t\t          if (!('default' in moduleObject)) {\n\t\t            error('lazy: Expected the result of a dynamic imp' + 'ort() call. ' + 'Instead received: %s\\n\\nYour code should look like: \\n  ' +\n\t\t            // Break up imports to avoid accidentally parsing them as dependencies.\n\t\t            'const MyComponent = lazy(() => imp' + \"ort('./MyComponent'))\", moduleObject);\n\t\t          }\n\t\t        }\n\t\t        return moduleObject.default;\n\t\t      } else {\n\t\t        throw payload._result;\n\t\t      }\n\t\t    }\n\t\t    function lazy(ctor) {\n\t\t      var payload = {\n\t\t        // We use these fields to store the result.\n\t\t        _status: Uninitialized,\n\t\t        _result: ctor\n\t\t      };\n\t\t      var lazyType = {\n\t\t        $$typeof: REACT_LAZY_TYPE,\n\t\t        _payload: payload,\n\t\t        _init: lazyInitializer\n\t\t      };\n\t\t      {\n\t\t        // In production, this would just set it on the object.\n\t\t        var defaultProps;\n\t\t        var propTypes; // $FlowFixMe\n\n\t\t        Object.defineProperties(lazyType, {\n\t\t          defaultProps: {\n\t\t            configurable: true,\n\t\t            get: function () {\n\t\t              return defaultProps;\n\t\t            },\n\t\t            set: function (newDefaultProps) {\n\t\t              error('React.lazy(...): It is not supported to assign `defaultProps` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');\n\t\t              defaultProps = newDefaultProps; // Match production behavior more closely:\n\t\t              // $FlowFixMe\n\n\t\t              Object.defineProperty(lazyType, 'defaultProps', {\n\t\t                enumerable: true\n\t\t              });\n\t\t            }\n\t\t          },\n\t\t          propTypes: {\n\t\t            configurable: true,\n\t\t            get: function () {\n\t\t              return propTypes;\n\t\t            },\n\t\t            set: function (newPropTypes) {\n\t\t              error('React.lazy(...): It is not supported to assign `propTypes` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');\n\t\t              propTypes = newPropTypes; // Match production behavior more closely:\n\t\t              // $FlowFixMe\n\n\t\t              Object.defineProperty(lazyType, 'propTypes', {\n\t\t                enumerable: true\n\t\t              });\n\t\t            }\n\t\t          }\n\t\t        });\n\t\t      }\n\t\t      return lazyType;\n\t\t    }\n\t\t    function forwardRef(render) {\n\t\t      {\n\t\t        if (render != null && render.$$typeof === REACT_MEMO_TYPE) {\n\t\t          error('forwardRef requires a render function but received a `memo` ' + 'component. Instead of forwardRef(memo(...)), use ' + 'memo(forwardRef(...)).');\n\t\t        } else if (typeof render !== 'function') {\n\t\t          error('forwardRef requires a render function but was given %s.', render === null ? 'null' : typeof render);\n\t\t        } else {\n\t\t          if (render.length !== 0 && render.length !== 2) {\n\t\t            error('forwardRef render functions accept exactly two parameters: props and ref. %s', render.length === 1 ? 'Did you forget to use the ref parameter?' : 'Any additional parameter will be undefined.');\n\t\t          }\n\t\t        }\n\t\t        if (render != null) {\n\t\t          if (render.defaultProps != null || render.propTypes != null) {\n\t\t            error('forwardRef render functions do not support propTypes or defaultProps. ' + 'Did you accidentally pass a React component?');\n\t\t          }\n\t\t        }\n\t\t      }\n\t\t      var elementType = {\n\t\t        $$typeof: REACT_FORWARD_REF_TYPE,\n\t\t        render: render\n\t\t      };\n\t\t      {\n\t\t        var ownName;\n\t\t        Object.defineProperty(elementType, 'displayName', {\n\t\t          enumerable: false,\n\t\t          configurable: true,\n\t\t          get: function () {\n\t\t            return ownName;\n\t\t          },\n\t\t          set: function (name) {\n\t\t            ownName = name; // The inner component shouldn't inherit this display name in most cases,\n\t\t            // because the component may be used elsewhere.\n\t\t            // But it's nice for anonymous functions to inherit the name,\n\t\t            // so that our component-stack generation logic will display their frames.\n\t\t            // An anonymous function generally suggests a pattern like:\n\t\t            //   React.forwardRef((props, ref) => {...});\n\t\t            // This kind of inner function is not used elsewhere so the side effect is okay.\n\n\t\t            if (!render.name && !render.displayName) {\n\t\t              render.displayName = name;\n\t\t            }\n\t\t          }\n\t\t        });\n\t\t      }\n\t\t      return elementType;\n\t\t    }\n\t\t    var REACT_MODULE_REFERENCE;\n\t\t    {\n\t\t      REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');\n\t\t    }\n\t\t    function isValidElementType(type) {\n\t\t      if (typeof type === 'string' || typeof type === 'function') {\n\t\t        return true;\n\t\t      } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\t\t      if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {\n\t\t        return true;\n\t\t      }\n\t\t      if (typeof type === 'object' && type !== null) {\n\t\t        if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE ||\n\t\t        // This needs to include all possible module reference object\n\t\t        // types supported by any Flight configuration anywhere since\n\t\t        // we don't know which Flight build this will end up being used\n\t\t        // with.\n\t\t        type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {\n\t\t          return true;\n\t\t        }\n\t\t      }\n\t\t      return false;\n\t\t    }\n\t\t    function memo(type, compare) {\n\t\t      {\n\t\t        if (!isValidElementType(type)) {\n\t\t          error('memo: The first argument must be a component. Instead ' + 'received: %s', type === null ? 'null' : typeof type);\n\t\t        }\n\t\t      }\n\t\t      var elementType = {\n\t\t        $$typeof: REACT_MEMO_TYPE,\n\t\t        type: type,\n\t\t        compare: compare === undefined ? null : compare\n\t\t      };\n\t\t      {\n\t\t        var ownName;\n\t\t        Object.defineProperty(elementType, 'displayName', {\n\t\t          enumerable: false,\n\t\t          configurable: true,\n\t\t          get: function () {\n\t\t            return ownName;\n\t\t          },\n\t\t          set: function (name) {\n\t\t            ownName = name; // The inner component shouldn't inherit this display name in most cases,\n\t\t            // because the component may be used elsewhere.\n\t\t            // But it's nice for anonymous functions to inherit the name,\n\t\t            // so that our component-stack generation logic will display their frames.\n\t\t            // An anonymous function generally suggests a pattern like:\n\t\t            //   React.memo((props) => {...});\n\t\t            // This kind of inner function is not used elsewhere so the side effect is okay.\n\n\t\t            if (!type.name && !type.displayName) {\n\t\t              type.displayName = name;\n\t\t            }\n\t\t          }\n\t\t        });\n\t\t      }\n\t\t      return elementType;\n\t\t    }\n\t\t    function resolveDispatcher() {\n\t\t      var dispatcher = ReactCurrentDispatcher.current;\n\t\t      {\n\t\t        if (dispatcher === null) {\n\t\t          error('Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' + ' one of the following reasons:\\n' + '1. You might have mismatching versions of React and the renderer (such as React DOM)\\n' + '2. You might be breaking the Rules of Hooks\\n' + '3. You might have more than one copy of React in the same app\\n' + 'See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.');\n\t\t        }\n\t\t      } // Will result in a null access error if accessed outside render phase. We\n\t\t      // intentionally don't throw our own error because this is in a hot path.\n\t\t      // Also helps ensure this is inlined.\n\n\t\t      return dispatcher;\n\t\t    }\n\t\t    function useContext(Context) {\n\t\t      var dispatcher = resolveDispatcher();\n\t\t      {\n\t\t        // TODO: add a more generic warning for invalid values.\n\t\t        if (Context._context !== undefined) {\n\t\t          var realContext = Context._context; // Don't deduplicate because this legitimately causes bugs\n\t\t          // and nobody should be using this in existing code.\n\n\t\t          if (realContext.Consumer === Context) {\n\t\t            error('Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be ' + 'removed in a future major release. Did you mean to call useContext(Context) instead?');\n\t\t          } else if (realContext.Provider === Context) {\n\t\t            error('Calling useContext(Context.Provider) is not supported. ' + 'Did you mean to call useContext(Context) instead?');\n\t\t          }\n\t\t        }\n\t\t      }\n\t\t      return dispatcher.useContext(Context);\n\t\t    }\n\t\t    function useState(initialState) {\n\t\t      var dispatcher = resolveDispatcher();\n\t\t      return dispatcher.useState(initialState);\n\t\t    }\n\t\t    function useReducer(reducer, initialArg, init) {\n\t\t      var dispatcher = resolveDispatcher();\n\t\t      return dispatcher.useReducer(reducer, initialArg, init);\n\t\t    }\n\t\t    function useRef(initialValue) {\n\t\t      var dispatcher = resolveDispatcher();\n\t\t      return dispatcher.useRef(initialValue);\n\t\t    }\n\t\t    function useEffect(create, deps) {\n\t\t      var dispatcher = resolveDispatcher();\n\t\t      return dispatcher.useEffect(create, deps);\n\t\t    }\n\t\t    function useInsertionEffect(create, deps) {\n\t\t      var dispatcher = resolveDispatcher();\n\t\t      return dispatcher.useInsertionEffect(create, deps);\n\t\t    }\n\t\t    function useLayoutEffect(create, deps) {\n\t\t      var dispatcher = resolveDispatcher();\n\t\t      return dispatcher.useLayoutEffect(create, deps);\n\t\t    }\n\t\t    function useCallback(callback, deps) {\n\t\t      var dispatcher = resolveDispatcher();\n\t\t      return dispatcher.useCallback(callback, deps);\n\t\t    }\n\t\t    function useMemo(create, deps) {\n\t\t      var dispatcher = resolveDispatcher();\n\t\t      return dispatcher.useMemo(create, deps);\n\t\t    }\n\t\t    function useImperativeHandle(ref, create, deps) {\n\t\t      var dispatcher = resolveDispatcher();\n\t\t      return dispatcher.useImperativeHandle(ref, create, deps);\n\t\t    }\n\t\t    function useDebugValue(value, formatterFn) {\n\t\t      {\n\t\t        var dispatcher = resolveDispatcher();\n\t\t        return dispatcher.useDebugValue(value, formatterFn);\n\t\t      }\n\t\t    }\n\t\t    function useTransition() {\n\t\t      var dispatcher = resolveDispatcher();\n\t\t      return dispatcher.useTransition();\n\t\t    }\n\t\t    function useDeferredValue(value) {\n\t\t      var dispatcher = resolveDispatcher();\n\t\t      return dispatcher.useDeferredValue(value);\n\t\t    }\n\t\t    function useId() {\n\t\t      var dispatcher = resolveDispatcher();\n\t\t      return dispatcher.useId();\n\t\t    }\n\t\t    function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n\t\t      var dispatcher = resolveDispatcher();\n\t\t      return dispatcher.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n\t\t    }\n\n\t\t    // Helpers to patch console.logs to avoid logging during side-effect free\n\t\t    // replaying on render function. This currently only patches the object\n\t\t    // lazily which won't cover if the log function was extracted eagerly.\n\t\t    // We could also eagerly patch the method.\n\t\t    var disabledDepth = 0;\n\t\t    var prevLog;\n\t\t    var prevInfo;\n\t\t    var prevWarn;\n\t\t    var prevError;\n\t\t    var prevGroup;\n\t\t    var prevGroupCollapsed;\n\t\t    var prevGroupEnd;\n\t\t    function disabledLog() {}\n\t\t    disabledLog.__reactDisabledLog = true;\n\t\t    function disableLogs() {\n\t\t      {\n\t\t        if (disabledDepth === 0) {\n\t\t          /* eslint-disable react-internal/no-production-logging */\n\t\t          prevLog = console.log;\n\t\t          prevInfo = console.info;\n\t\t          prevWarn = console.warn;\n\t\t          prevError = console.error;\n\t\t          prevGroup = console.group;\n\t\t          prevGroupCollapsed = console.groupCollapsed;\n\t\t          prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n\t\t          var props = {\n\t\t            configurable: true,\n\t\t            enumerable: true,\n\t\t            value: disabledLog,\n\t\t            writable: true\n\t\t          }; // $FlowFixMe Flow thinks console is immutable.\n\n\t\t          Object.defineProperties(console, {\n\t\t            info: props,\n\t\t            log: props,\n\t\t            warn: props,\n\t\t            error: props,\n\t\t            group: props,\n\t\t            groupCollapsed: props,\n\t\t            groupEnd: props\n\t\t          });\n\t\t          /* eslint-enable react-internal/no-production-logging */\n\t\t        }\n\n\t\t        disabledDepth++;\n\t\t      }\n\t\t    }\n\t\t    function reenableLogs() {\n\t\t      {\n\t\t        disabledDepth--;\n\t\t        if (disabledDepth === 0) {\n\t\t          /* eslint-disable react-internal/no-production-logging */\n\t\t          var props = {\n\t\t            configurable: true,\n\t\t            enumerable: true,\n\t\t            writable: true\n\t\t          }; // $FlowFixMe Flow thinks console is immutable.\n\n\t\t          Object.defineProperties(console, {\n\t\t            log: assign({}, props, {\n\t\t              value: prevLog\n\t\t            }),\n\t\t            info: assign({}, props, {\n\t\t              value: prevInfo\n\t\t            }),\n\t\t            warn: assign({}, props, {\n\t\t              value: prevWarn\n\t\t            }),\n\t\t            error: assign({}, props, {\n\t\t              value: prevError\n\t\t            }),\n\t\t            group: assign({}, props, {\n\t\t              value: prevGroup\n\t\t            }),\n\t\t            groupCollapsed: assign({}, props, {\n\t\t              value: prevGroupCollapsed\n\t\t            }),\n\t\t            groupEnd: assign({}, props, {\n\t\t              value: prevGroupEnd\n\t\t            })\n\t\t          });\n\t\t          /* eslint-enable react-internal/no-production-logging */\n\t\t        }\n\n\t\t        if (disabledDepth < 0) {\n\t\t          error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t    var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;\n\t\t    var prefix;\n\t\t    function describeBuiltInComponentFrame(name, source, ownerFn) {\n\t\t      {\n\t\t        if (prefix === undefined) {\n\t\t          // Extract the VM specific prefix used by each line.\n\t\t          try {\n\t\t            throw Error();\n\t\t          } catch (x) {\n\t\t            var match = x.stack.trim().match(/\\n( *(at )?)/);\n\t\t            prefix = match && match[1] || '';\n\t\t          }\n\t\t        } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\t\t        return '\\n' + prefix + name;\n\t\t      }\n\t\t    }\n\t\t    var reentry = false;\n\t\t    var componentFrameCache;\n\t\t    {\n\t\t      var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n\t\t      componentFrameCache = new PossiblyWeakMap();\n\t\t    }\n\t\t    function describeNativeComponentFrame(fn, construct) {\n\t\t      // If something asked for a stack inside a fake render, it should get ignored.\n\t\t      if (!fn || reentry) {\n\t\t        return '';\n\t\t      }\n\t\t      {\n\t\t        var frame = componentFrameCache.get(fn);\n\t\t        if (frame !== undefined) {\n\t\t          return frame;\n\t\t        }\n\t\t      }\n\t\t      var control;\n\t\t      reentry = true;\n\t\t      var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.\n\n\t\t      Error.prepareStackTrace = undefined;\n\t\t      var previousDispatcher;\n\t\t      {\n\t\t        previousDispatcher = ReactCurrentDispatcher$1.current; // Set the dispatcher in DEV because this might be call in the render function\n\t\t        // for warnings.\n\n\t\t        ReactCurrentDispatcher$1.current = null;\n\t\t        disableLogs();\n\t\t      }\n\t\t      try {\n\t\t        // This should throw.\n\t\t        if (construct) {\n\t\t          // Something should be setting the props in the constructor.\n\t\t          var Fake = function () {\n\t\t            throw Error();\n\t\t          }; // $FlowFixMe\n\n\t\t          Object.defineProperty(Fake.prototype, 'props', {\n\t\t            set: function () {\n\t\t              // We use a throwing setter instead of frozen or non-writable props\n\t\t              // because that won't throw in a non-strict mode function.\n\t\t              throw Error();\n\t\t            }\n\t\t          });\n\t\t          if (typeof Reflect === 'object' && Reflect.construct) {\n\t\t            // We construct a different control for this case to include any extra\n\t\t            // frames added by the construct call.\n\t\t            try {\n\t\t              Reflect.construct(Fake, []);\n\t\t            } catch (x) {\n\t\t              control = x;\n\t\t            }\n\t\t            Reflect.construct(fn, [], Fake);\n\t\t          } else {\n\t\t            try {\n\t\t              Fake.call();\n\t\t            } catch (x) {\n\t\t              control = x;\n\t\t            }\n\t\t            fn.call(Fake.prototype);\n\t\t          }\n\t\t        } else {\n\t\t          try {\n\t\t            throw Error();\n\t\t          } catch (x) {\n\t\t            control = x;\n\t\t          }\n\t\t          fn();\n\t\t        }\n\t\t      } catch (sample) {\n\t\t        // This is inlined manually because closure doesn't do it for us.\n\t\t        if (sample && control && typeof sample.stack === 'string') {\n\t\t          // This extracts the first frame from the sample that isn't also in the control.\n\t\t          // Skipping one frame that we assume is the frame that calls the two.\n\t\t          var sampleLines = sample.stack.split('\\n');\n\t\t          var controlLines = control.stack.split('\\n');\n\t\t          var s = sampleLines.length - 1;\n\t\t          var c = controlLines.length - 1;\n\t\t          while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n\t\t            // We expect at least one stack frame to be shared.\n\t\t            // Typically this will be the root most one. However, stack frames may be\n\t\t            // cut off due to maximum stack limits. In this case, one maybe cut off\n\t\t            // earlier than the other. We assume that the sample is longer or the same\n\t\t            // and there for cut off earlier. So we should find the root most frame in\n\t\t            // the sample somewhere in the control.\n\t\t            c--;\n\t\t          }\n\t\t          for (; s >= 1 && c >= 0; s--, c--) {\n\t\t            // Next we find the first one that isn't the same which should be the\n\t\t            // frame that called our sample function and the control.\n\t\t            if (sampleLines[s] !== controlLines[c]) {\n\t\t              // In V8, the first line is describing the message but other VMs don't.\n\t\t              // If we're about to return the first line, and the control is also on the same\n\t\t              // line, that's a pretty good indicator that our sample threw at same line as\n\t\t              // the control. I.e. before we entered the sample frame. So we ignore this result.\n\t\t              // This can happen if you passed a class to function component, or non-function.\n\t\t              if (s !== 1 || c !== 1) {\n\t\t                do {\n\t\t                  s--;\n\t\t                  c--; // We may still have similar intermediate frames from the construct call.\n\t\t                  // The next one that isn't the same should be our match though.\n\n\t\t                  if (c < 0 || sampleLines[s] !== controlLines[c]) {\n\t\t                    // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n\t\t                    var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n\t\t                    // but we have a user-provided \"displayName\"\n\t\t                    // splice it in to make the stack more readable.\n\n\t\t                    if (fn.displayName && _frame.includes('<anonymous>')) {\n\t\t                      _frame = _frame.replace('<anonymous>', fn.displayName);\n\t\t                    }\n\t\t                    {\n\t\t                      if (typeof fn === 'function') {\n\t\t                        componentFrameCache.set(fn, _frame);\n\t\t                      }\n\t\t                    } // Return the line we found.\n\n\t\t                    return _frame;\n\t\t                  }\n\t\t                } while (s >= 1 && c >= 0);\n\t\t              }\n\t\t              break;\n\t\t            }\n\t\t          }\n\t\t        }\n\t\t      } finally {\n\t\t        reentry = false;\n\t\t        {\n\t\t          ReactCurrentDispatcher$1.current = previousDispatcher;\n\t\t          reenableLogs();\n\t\t        }\n\t\t        Error.prepareStackTrace = previousPrepareStackTrace;\n\t\t      } // Fallback to just using the name if we couldn't make it throw.\n\n\t\t      var name = fn ? fn.displayName || fn.name : '';\n\t\t      var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\t\t      {\n\t\t        if (typeof fn === 'function') {\n\t\t          componentFrameCache.set(fn, syntheticFrame);\n\t\t        }\n\t\t      }\n\t\t      return syntheticFrame;\n\t\t    }\n\t\t    function describeFunctionComponentFrame(fn, source, ownerFn) {\n\t\t      {\n\t\t        return describeNativeComponentFrame(fn, false);\n\t\t      }\n\t\t    }\n\t\t    function shouldConstruct(Component) {\n\t\t      var prototype = Component.prototype;\n\t\t      return !!(prototype && prototype.isReactComponent);\n\t\t    }\n\t\t    function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n\t\t      if (type == null) {\n\t\t        return '';\n\t\t      }\n\t\t      if (typeof type === 'function') {\n\t\t        {\n\t\t          return describeNativeComponentFrame(type, shouldConstruct(type));\n\t\t        }\n\t\t      }\n\t\t      if (typeof type === 'string') {\n\t\t        return describeBuiltInComponentFrame(type);\n\t\t      }\n\t\t      switch (type) {\n\t\t        case REACT_SUSPENSE_TYPE:\n\t\t          return describeBuiltInComponentFrame('Suspense');\n\t\t        case REACT_SUSPENSE_LIST_TYPE:\n\t\t          return describeBuiltInComponentFrame('SuspenseList');\n\t\t      }\n\t\t      if (typeof type === 'object') {\n\t\t        switch (type.$$typeof) {\n\t\t          case REACT_FORWARD_REF_TYPE:\n\t\t            return describeFunctionComponentFrame(type.render);\n\t\t          case REACT_MEMO_TYPE:\n\t\t            // Memo may contain any component type so we recursively resolve it.\n\t\t            return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n\t\t          case REACT_LAZY_TYPE:\n\t\t            {\n\t\t              var lazyComponent = type;\n\t\t              var payload = lazyComponent._payload;\n\t\t              var init = lazyComponent._init;\n\t\t              try {\n\t\t                // Lazy may contain any component type so we recursively resolve it.\n\t\t                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n\t\t              } catch (x) {}\n\t\t            }\n\t\t        }\n\t\t      }\n\t\t      return '';\n\t\t    }\n\t\t    var loggedTypeFailures = {};\n\t\t    var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n\t\t    function setCurrentlyValidatingElement(element) {\n\t\t      {\n\t\t        if (element) {\n\t\t          var owner = element._owner;\n\t\t          var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n\t\t          ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n\t\t        } else {\n\t\t          ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t    function checkPropTypes(typeSpecs, values, location, componentName, element) {\n\t\t      {\n\t\t        // $FlowFixMe This is okay but Flow doesn't know it.\n\t\t        var has = Function.call.bind(hasOwnProperty);\n\t\t        for (var typeSpecName in typeSpecs) {\n\t\t          if (has(typeSpecs, typeSpecName)) {\n\t\t            var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n\t\t            // fail the render phase where it didn't fail before. So we log it.\n\t\t            // After these have been cleaned up, we'll let them throw.\n\n\t\t            try {\n\t\t              // This is intentionally an invariant that gets caught. It's the same\n\t\t              // behavior as without this statement except with a better message.\n\t\t              if (typeof typeSpecs[typeSpecName] !== 'function') {\n\t\t                // eslint-disable-next-line react-internal/prod-error-codes\n\t\t                var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\n\t\t                err.name = 'Invariant Violation';\n\t\t                throw err;\n\t\t              }\n\t\t              error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\n\t\t            } catch (ex) {\n\t\t              error$1 = ex;\n\t\t            }\n\t\t            if (error$1 && !(error$1 instanceof Error)) {\n\t\t              setCurrentlyValidatingElement(element);\n\t\t              error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);\n\t\t              setCurrentlyValidatingElement(null);\n\t\t            }\n\t\t            if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n\t\t              // Only monitor this failure once because there tends to be a lot of the\n\t\t              // same error.\n\t\t              loggedTypeFailures[error$1.message] = true;\n\t\t              setCurrentlyValidatingElement(element);\n\t\t              error('Failed %s type: %s', location, error$1.message);\n\t\t              setCurrentlyValidatingElement(null);\n\t\t            }\n\t\t          }\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t    function setCurrentlyValidatingElement$1(element) {\n\t\t      {\n\t\t        if (element) {\n\t\t          var owner = element._owner;\n\t\t          var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n\t\t          setExtraStackFrame(stack);\n\t\t        } else {\n\t\t          setExtraStackFrame(null);\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t    var propTypesMisspellWarningShown;\n\t\t    {\n\t\t      propTypesMisspellWarningShown = false;\n\t\t    }\n\t\t    function getDeclarationErrorAddendum() {\n\t\t      if (ReactCurrentOwner.current) {\n\t\t        var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n\t\t        if (name) {\n\t\t          return '\\n\\nCheck the render method of `' + name + '`.';\n\t\t        }\n\t\t      }\n\t\t      return '';\n\t\t    }\n\t\t    function getSourceInfoErrorAddendum(source) {\n\t\t      if (source !== undefined) {\n\t\t        var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n\t\t        var lineNumber = source.lineNumber;\n\t\t        return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n\t\t      }\n\t\t      return '';\n\t\t    }\n\t\t    function getSourceInfoErrorAddendumForProps(elementProps) {\n\t\t      if (elementProps !== null && elementProps !== undefined) {\n\t\t        return getSourceInfoErrorAddendum(elementProps.__source);\n\t\t      }\n\t\t      return '';\n\t\t    }\n\t\t    /**\n\t\t     * Warn if there's no key explicitly set on dynamic arrays of children or\n\t\t     * object keys are not valid. This allows us to keep track of children between\n\t\t     * updates.\n\t\t     */\n\n\t\t    var ownerHasKeyUseWarning = {};\n\t\t    function getCurrentComponentErrorInfo(parentType) {\n\t\t      var info = getDeclarationErrorAddendum();\n\t\t      if (!info) {\n\t\t        var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n\t\t        if (parentName) {\n\t\t          info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n\t\t        }\n\t\t      }\n\t\t      return info;\n\t\t    }\n\t\t    /**\n\t\t     * Warn if the element doesn't have an explicit key assigned to it.\n\t\t     * This element is in an array. The array could grow and shrink or be\n\t\t     * reordered. All children that haven't already been validated are required to\n\t\t     * have a \"key\" property assigned to it. Error statuses are cached so a warning\n\t\t     * will only be shown once.\n\t\t     *\n\t\t     * @internal\n\t\t     * @param {ReactElement} element Element that requires a key.\n\t\t     * @param {*} parentType element's parent's type.\n\t\t     */\n\n\t\t    function validateExplicitKey(element, parentType) {\n\t\t      if (!element._store || element._store.validated || element.key != null) {\n\t\t        return;\n\t\t      }\n\t\t      element._store.validated = true;\n\t\t      var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\t\t      if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n\t\t        return;\n\t\t      }\n\t\t      ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n\t\t      // property, it may be the creator of the child that's responsible for\n\t\t      // assigning it a key.\n\n\t\t      var childOwner = '';\n\t\t      if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n\t\t        // Give the component that originally created this child.\n\t\t        childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n\t\t      }\n\t\t      {\n\t\t        setCurrentlyValidatingElement$1(element);\n\t\t        error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\t\t        setCurrentlyValidatingElement$1(null);\n\t\t      }\n\t\t    }\n\t\t    /**\n\t\t     * Ensure that every element either is passed in a static location, in an\n\t\t     * array with an explicit keys property defined, or in an object literal\n\t\t     * with valid key property.\n\t\t     *\n\t\t     * @internal\n\t\t     * @param {ReactNode} node Statically passed child of any type.\n\t\t     * @param {*} parentType node's parent's type.\n\t\t     */\n\n\t\t    function validateChildKeys(node, parentType) {\n\t\t      if (typeof node !== 'object') {\n\t\t        return;\n\t\t      }\n\t\t      if (isArray(node)) {\n\t\t        for (var i = 0; i < node.length; i++) {\n\t\t          var child = node[i];\n\t\t          if (isValidElement(child)) {\n\t\t            validateExplicitKey(child, parentType);\n\t\t          }\n\t\t        }\n\t\t      } else if (isValidElement(node)) {\n\t\t        // This element was passed in a valid location.\n\t\t        if (node._store) {\n\t\t          node._store.validated = true;\n\t\t        }\n\t\t      } else if (node) {\n\t\t        var iteratorFn = getIteratorFn(node);\n\t\t        if (typeof iteratorFn === 'function') {\n\t\t          // Entry iterators used to provide implicit keys,\n\t\t          // but now we print a separate warning for them later.\n\t\t          if (iteratorFn !== node.entries) {\n\t\t            var iterator = iteratorFn.call(node);\n\t\t            var step;\n\t\t            while (!(step = iterator.next()).done) {\n\t\t              if (isValidElement(step.value)) {\n\t\t                validateExplicitKey(step.value, parentType);\n\t\t              }\n\t\t            }\n\t\t          }\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t    /**\n\t\t     * Given an element, validate that its props follow the propTypes definition,\n\t\t     * provided by the type.\n\t\t     *\n\t\t     * @param {ReactElement} element\n\t\t     */\n\n\t\t    function validatePropTypes(element) {\n\t\t      {\n\t\t        var type = element.type;\n\t\t        if (type === null || type === undefined || typeof type === 'string') {\n\t\t          return;\n\t\t        }\n\t\t        var propTypes;\n\t\t        if (typeof type === 'function') {\n\t\t          propTypes = type.propTypes;\n\t\t        } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE ||\n\t\t        // Note: Memo only checks outer props here.\n\t\t        // Inner props are checked in the reconciler.\n\t\t        type.$$typeof === REACT_MEMO_TYPE)) {\n\t\t          propTypes = type.propTypes;\n\t\t        } else {\n\t\t          return;\n\t\t        }\n\t\t        if (propTypes) {\n\t\t          // Intentionally inside to avoid triggering lazy initializers:\n\t\t          var name = getComponentNameFromType(type);\n\t\t          checkPropTypes(propTypes, element.props, 'prop', name, element);\n\t\t        } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n\t\t          propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n\n\t\t          var _name = getComponentNameFromType(type);\n\t\t          error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');\n\t\t        }\n\t\t        if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\n\t\t          error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t    /**\n\t\t     * Given a fragment, validate that it can only be provided with fragment props\n\t\t     * @param {ReactElement} fragment\n\t\t     */\n\n\t\t    function validateFragmentProps(fragment) {\n\t\t      {\n\t\t        var keys = Object.keys(fragment.props);\n\t\t        for (var i = 0; i < keys.length; i++) {\n\t\t          var key = keys[i];\n\t\t          if (key !== 'children' && key !== 'key') {\n\t\t            setCurrentlyValidatingElement$1(fragment);\n\t\t            error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\t\t            setCurrentlyValidatingElement$1(null);\n\t\t            break;\n\t\t          }\n\t\t        }\n\t\t        if (fragment.ref !== null) {\n\t\t          setCurrentlyValidatingElement$1(fragment);\n\t\t          error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\t\t          setCurrentlyValidatingElement$1(null);\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t    function createElementWithValidation(type, props, children) {\n\t\t      var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n\t\t      // succeed and there will likely be errors in render.\n\n\t\t      if (!validType) {\n\t\t        var info = '';\n\t\t        if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n\t\t          info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n\t\t        }\n\t\t        var sourceInfo = getSourceInfoErrorAddendumForProps(props);\n\t\t        if (sourceInfo) {\n\t\t          info += sourceInfo;\n\t\t        } else {\n\t\t          info += getDeclarationErrorAddendum();\n\t\t        }\n\t\t        var typeString;\n\t\t        if (type === null) {\n\t\t          typeString = 'null';\n\t\t        } else if (isArray(type)) {\n\t\t          typeString = 'array';\n\t\t        } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n\t\t          typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n\t\t          info = ' Did you accidentally export a JSX literal instead of a component?';\n\t\t        } else {\n\t\t          typeString = typeof type;\n\t\t        }\n\t\t        {\n\t\t          error('React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n\t\t        }\n\t\t      }\n\t\t      var element = createElement.apply(this, arguments); // The result can be nullish if a mock or a custom function is used.\n\t\t      // TODO: Drop this when these are no longer allowed as the type argument.\n\n\t\t      if (element == null) {\n\t\t        return element;\n\t\t      } // Skip key warning if the type isn't valid since our key validation logic\n\t\t      // doesn't expect a non-string/function type and can throw confusing errors.\n\t\t      // We don't want exception behavior to differ between dev and prod.\n\t\t      // (Rendering will throw with a helpful message and as soon as the type is\n\t\t      // fixed, the key warnings will appear.)\n\n\t\t      if (validType) {\n\t\t        for (var i = 2; i < arguments.length; i++) {\n\t\t          validateChildKeys(arguments[i], type);\n\t\t        }\n\t\t      }\n\t\t      if (type === REACT_FRAGMENT_TYPE) {\n\t\t        validateFragmentProps(element);\n\t\t      } else {\n\t\t        validatePropTypes(element);\n\t\t      }\n\t\t      return element;\n\t\t    }\n\t\t    var didWarnAboutDeprecatedCreateFactory = false;\n\t\t    function createFactoryWithValidation(type) {\n\t\t      var validatedFactory = createElementWithValidation.bind(null, type);\n\t\t      validatedFactory.type = type;\n\t\t      {\n\t\t        if (!didWarnAboutDeprecatedCreateFactory) {\n\t\t          didWarnAboutDeprecatedCreateFactory = true;\n\t\t          warn('React.createFactory() is deprecated and will be removed in ' + 'a future major release. Consider using JSX ' + 'or use React.createElement() directly instead.');\n\t\t        } // Legacy hook: remove it\n\n\t\t        Object.defineProperty(validatedFactory, 'type', {\n\t\t          enumerable: false,\n\t\t          get: function () {\n\t\t            warn('Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');\n\t\t            Object.defineProperty(this, 'type', {\n\t\t              value: type\n\t\t            });\n\t\t            return type;\n\t\t          }\n\t\t        });\n\t\t      }\n\t\t      return validatedFactory;\n\t\t    }\n\t\t    function cloneElementWithValidation(element, props, children) {\n\t\t      var newElement = cloneElement.apply(this, arguments);\n\t\t      for (var i = 2; i < arguments.length; i++) {\n\t\t        validateChildKeys(arguments[i], newElement.type);\n\t\t      }\n\t\t      validatePropTypes(newElement);\n\t\t      return newElement;\n\t\t    }\n\t\t    function startTransition(scope, options) {\n\t\t      var prevTransition = ReactCurrentBatchConfig.transition;\n\t\t      ReactCurrentBatchConfig.transition = {};\n\t\t      var currentTransition = ReactCurrentBatchConfig.transition;\n\t\t      {\n\t\t        ReactCurrentBatchConfig.transition._updatedFibers = new Set();\n\t\t      }\n\t\t      try {\n\t\t        scope();\n\t\t      } finally {\n\t\t        ReactCurrentBatchConfig.transition = prevTransition;\n\t\t        {\n\t\t          if (prevTransition === null && currentTransition._updatedFibers) {\n\t\t            var updatedFibersCount = currentTransition._updatedFibers.size;\n\t\t            if (updatedFibersCount > 10) {\n\t\t              warn('Detected a large number of updates inside startTransition. ' + 'If this is due to a subscription please re-write it to use React provided hooks. ' + 'Otherwise concurrent mode guarantees are off the table.');\n\t\t            }\n\t\t            currentTransition._updatedFibers.clear();\n\t\t          }\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t    var didWarnAboutMessageChannel = false;\n\t\t    var enqueueTaskImpl = null;\n\t\t    function enqueueTask(task) {\n\t\t      if (enqueueTaskImpl === null) {\n\t\t        try {\n\t\t          // read require off the module object to get around the bundlers.\n\t\t          // we don't want them to detect a require and bundle a Node polyfill.\n\t\t          var requireString = ('require' + Math.random()).slice(0, 7);\n\t\t          var nodeRequire = module && module[requireString]; // assuming we're in node, let's try to get node's\n\t\t          // version of setImmediate, bypassing fake timers if any.\n\n\t\t          enqueueTaskImpl = nodeRequire.call(module, 'timers').setImmediate;\n\t\t        } catch (_err) {\n\t\t          // we're in a browser\n\t\t          // we can't use regular timers because they may still be faked\n\t\t          // so we try MessageChannel+postMessage instead\n\t\t          enqueueTaskImpl = function (callback) {\n\t\t            {\n\t\t              if (didWarnAboutMessageChannel === false) {\n\t\t                didWarnAboutMessageChannel = true;\n\t\t                if (typeof MessageChannel === 'undefined') {\n\t\t                  error('This browser does not have a MessageChannel implementation, ' + 'so enqueuing tasks via await act(async () => ...) will fail. ' + 'Please file an issue at https://github.com/facebook/react/issues ' + 'if you encounter this warning.');\n\t\t                }\n\t\t              }\n\t\t            }\n\t\t            var channel = new MessageChannel();\n\t\t            channel.port1.onmessage = callback;\n\t\t            channel.port2.postMessage(undefined);\n\t\t          };\n\t\t        }\n\t\t      }\n\t\t      return enqueueTaskImpl(task);\n\t\t    }\n\t\t    var actScopeDepth = 0;\n\t\t    var didWarnNoAwaitAct = false;\n\t\t    function act(callback) {\n\t\t      {\n\t\t        // `act` calls can be nested, so we track the depth. This represents the\n\t\t        // number of `act` scopes on the stack.\n\t\t        var prevActScopeDepth = actScopeDepth;\n\t\t        actScopeDepth++;\n\t\t        if (ReactCurrentActQueue.current === null) {\n\t\t          // This is the outermost `act` scope. Initialize the queue. The reconciler\n\t\t          // will detect the queue and use it instead of Scheduler.\n\t\t          ReactCurrentActQueue.current = [];\n\t\t        }\n\t\t        var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;\n\t\t        var result;\n\t\t        try {\n\t\t          // Used to reproduce behavior of `batchedUpdates` in legacy mode. Only\n\t\t          // set to `true` while the given callback is executed, not for updates\n\t\t          // triggered during an async event, because this is how the legacy\n\t\t          // implementation of `act` behaved.\n\t\t          ReactCurrentActQueue.isBatchingLegacy = true;\n\t\t          result = callback(); // Replicate behavior of original `act` implementation in legacy mode,\n\t\t          // which flushed updates immediately after the scope function exits, even\n\t\t          // if it's an async function.\n\n\t\t          if (!prevIsBatchingLegacy && ReactCurrentActQueue.didScheduleLegacyUpdate) {\n\t\t            var queue = ReactCurrentActQueue.current;\n\t\t            if (queue !== null) {\n\t\t              ReactCurrentActQueue.didScheduleLegacyUpdate = false;\n\t\t              flushActQueue(queue);\n\t\t            }\n\t\t          }\n\t\t        } catch (error) {\n\t\t          popActScope(prevActScopeDepth);\n\t\t          throw error;\n\t\t        } finally {\n\t\t          ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;\n\t\t        }\n\t\t        if (result !== null && typeof result === 'object' && typeof result.then === 'function') {\n\t\t          var thenableResult = result; // The callback is an async function (i.e. returned a promise). Wait\n\t\t          // for it to resolve before exiting the current scope.\n\n\t\t          var wasAwaited = false;\n\t\t          var thenable = {\n\t\t            then: function (resolve, reject) {\n\t\t              wasAwaited = true;\n\t\t              thenableResult.then(function (returnValue) {\n\t\t                popActScope(prevActScopeDepth);\n\t\t                if (actScopeDepth === 0) {\n\t\t                  // We've exited the outermost act scope. Recursively flush the\n\t\t                  // queue until there's no remaining work.\n\t\t                  recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n\t\t                } else {\n\t\t                  resolve(returnValue);\n\t\t                }\n\t\t              }, function (error) {\n\t\t                // The callback threw an error.\n\t\t                popActScope(prevActScopeDepth);\n\t\t                reject(error);\n\t\t              });\n\t\t            }\n\t\t          };\n\t\t          {\n\t\t            if (!didWarnNoAwaitAct && typeof Promise !== 'undefined') {\n\t\t              // eslint-disable-next-line no-undef\n\t\t              Promise.resolve().then(function () {}).then(function () {\n\t\t                if (!wasAwaited) {\n\t\t                  didWarnNoAwaitAct = true;\n\t\t                  error('You called act(async () => ...) without await. ' + 'This could lead to unexpected testing behaviour, ' + 'interleaving multiple act calls and mixing their ' + 'scopes. ' + 'You should - await act(async () => ...);');\n\t\t                }\n\t\t              });\n\t\t            }\n\t\t          }\n\t\t          return thenable;\n\t\t        } else {\n\t\t          var returnValue = result; // The callback is not an async function. Exit the current scope\n\t\t          // immediately, without awaiting.\n\n\t\t          popActScope(prevActScopeDepth);\n\t\t          if (actScopeDepth === 0) {\n\t\t            // Exiting the outermost act scope. Flush the queue.\n\t\t            var _queue = ReactCurrentActQueue.current;\n\t\t            if (_queue !== null) {\n\t\t              flushActQueue(_queue);\n\t\t              ReactCurrentActQueue.current = null;\n\t\t            } // Return a thenable. If the user awaits it, we'll flush again in\n\t\t            // case additional work was scheduled by a microtask.\n\n\t\t            var _thenable = {\n\t\t              then: function (resolve, reject) {\n\t\t                // Confirm we haven't re-entered another `act` scope, in case\n\t\t                // the user does something weird like await the thenable\n\t\t                // multiple times.\n\t\t                if (ReactCurrentActQueue.current === null) {\n\t\t                  // Recursively flush the queue until there's no remaining work.\n\t\t                  ReactCurrentActQueue.current = [];\n\t\t                  recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n\t\t                } else {\n\t\t                  resolve(returnValue);\n\t\t                }\n\t\t              }\n\t\t            };\n\t\t            return _thenable;\n\t\t          } else {\n\t\t            // Since we're inside a nested `act` scope, the returned thenable\n\t\t            // immediately resolves. The outer scope will flush the queue.\n\t\t            var _thenable2 = {\n\t\t              then: function (resolve, reject) {\n\t\t                resolve(returnValue);\n\t\t              }\n\t\t            };\n\t\t            return _thenable2;\n\t\t          }\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t    function popActScope(prevActScopeDepth) {\n\t\t      {\n\t\t        if (prevActScopeDepth !== actScopeDepth - 1) {\n\t\t          error('You seem to have overlapping act() calls, this is not supported. ' + 'Be sure to await previous act() calls before making a new one. ');\n\t\t        }\n\t\t        actScopeDepth = prevActScopeDepth;\n\t\t      }\n\t\t    }\n\t\t    function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {\n\t\t      {\n\t\t        var queue = ReactCurrentActQueue.current;\n\t\t        if (queue !== null) {\n\t\t          try {\n\t\t            flushActQueue(queue);\n\t\t            enqueueTask(function () {\n\t\t              if (queue.length === 0) {\n\t\t                // No additional work was scheduled. Finish.\n\t\t                ReactCurrentActQueue.current = null;\n\t\t                resolve(returnValue);\n\t\t              } else {\n\t\t                // Keep flushing work until there's none left.\n\t\t                recursivelyFlushAsyncActWork(returnValue, resolve, reject);\n\t\t              }\n\t\t            });\n\t\t          } catch (error) {\n\t\t            reject(error);\n\t\t          }\n\t\t        } else {\n\t\t          resolve(returnValue);\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t    var isFlushing = false;\n\t\t    function flushActQueue(queue) {\n\t\t      {\n\t\t        if (!isFlushing) {\n\t\t          // Prevent re-entrance.\n\t\t          isFlushing = true;\n\t\t          var i = 0;\n\t\t          try {\n\t\t            for (; i < queue.length; i++) {\n\t\t              var callback = queue[i];\n\t\t              do {\n\t\t                callback = callback(true);\n\t\t              } while (callback !== null);\n\t\t            }\n\t\t            queue.length = 0;\n\t\t          } catch (error) {\n\t\t            // If something throws, leave the remaining callbacks on the queue.\n\t\t            queue = queue.slice(i + 1);\n\t\t            throw error;\n\t\t          } finally {\n\t\t            isFlushing = false;\n\t\t          }\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t    var createElement$1 = createElementWithValidation;\n\t\t    var cloneElement$1 = cloneElementWithValidation;\n\t\t    var createFactory = createFactoryWithValidation;\n\t\t    var Children = {\n\t\t      map: mapChildren,\n\t\t      forEach: forEachChildren,\n\t\t      count: countChildren,\n\t\t      toArray: toArray,\n\t\t      only: onlyChild\n\t\t    };\n\t\t    exports.Children = Children;\n\t\t    exports.Component = Component;\n\t\t    exports.Fragment = REACT_FRAGMENT_TYPE;\n\t\t    exports.Profiler = REACT_PROFILER_TYPE;\n\t\t    exports.PureComponent = PureComponent;\n\t\t    exports.StrictMode = REACT_STRICT_MODE_TYPE;\n\t\t    exports.Suspense = REACT_SUSPENSE_TYPE;\n\t\t    exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;\n\t\t    exports.cloneElement = cloneElement$1;\n\t\t    exports.createContext = createContext;\n\t\t    exports.createElement = createElement$1;\n\t\t    exports.createFactory = createFactory;\n\t\t    exports.createRef = createRef;\n\t\t    exports.forwardRef = forwardRef;\n\t\t    exports.isValidElement = isValidElement;\n\t\t    exports.lazy = lazy;\n\t\t    exports.memo = memo;\n\t\t    exports.startTransition = startTransition;\n\t\t    exports.unstable_act = act;\n\t\t    exports.useCallback = useCallback;\n\t\t    exports.useContext = useContext;\n\t\t    exports.useDebugValue = useDebugValue;\n\t\t    exports.useDeferredValue = useDeferredValue;\n\t\t    exports.useEffect = useEffect;\n\t\t    exports.useId = useId;\n\t\t    exports.useImperativeHandle = useImperativeHandle;\n\t\t    exports.useInsertionEffect = useInsertionEffect;\n\t\t    exports.useLayoutEffect = useLayoutEffect;\n\t\t    exports.useMemo = useMemo;\n\t\t    exports.useReducer = useReducer;\n\t\t    exports.useRef = useRef;\n\t\t    exports.useState = useState;\n\t\t    exports.useSyncExternalStore = useSyncExternalStore;\n\t\t    exports.useTransition = useTransition;\n\t\t    exports.version = ReactVersion;\n\t\t    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n\t\t    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === 'function') {\n\t\t      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n\t\t    }\n\t\t  })();\n\t\t}\n\t} (react_development, react_developmentExports));\n\n\t(function (module) {\n\n\t\t{\n\t\t  module.exports = react_developmentExports;\n\t\t}\n\t} (react));\n\n\tvar index$1 = /*@__PURE__*/getDefaultExportFromCjs(reactExports);\n\n\tvar reactDomExports = {};\n\tvar reactDom = {\n\t  get exports(){ return reactDomExports; },\n\t  set exports(v){ reactDomExports = v; },\n\t};\n\n\tvar reactDom_development = {};\n\n\tvar schedulerExports = {};\n\tvar scheduler = {\n\t  get exports(){ return schedulerExports; },\n\t  set exports(v){ schedulerExports = v; },\n\t};\n\n\tvar scheduler_development = {};\n\n\t/**\n\t * @license React\n\t * scheduler.development.js\n\t *\n\t * Copyright (c) Facebook, Inc. and its affiliates.\n\t *\n\t * This source code is licensed under the MIT license found in the\n\t * LICENSE file in the root directory of this source tree.\n\t */\n\n\t(function (exports) {\n\n\t\t{\n\t\t  (function () {\n\n\t\t    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n\t\t    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === 'function') {\n\t\t      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n\t\t    }\n\t\t    var enableSchedulerDebugging = false;\n\t\t    var enableProfiling = false;\n\t\t    var frameYieldMs = 5;\n\t\t    function push(heap, node) {\n\t\t      var index = heap.length;\n\t\t      heap.push(node);\n\t\t      siftUp(heap, node, index);\n\t\t    }\n\t\t    function peek(heap) {\n\t\t      return heap.length === 0 ? null : heap[0];\n\t\t    }\n\t\t    function pop(heap) {\n\t\t      if (heap.length === 0) {\n\t\t        return null;\n\t\t      }\n\t\t      var first = heap[0];\n\t\t      var last = heap.pop();\n\t\t      if (last !== first) {\n\t\t        heap[0] = last;\n\t\t        siftDown(heap, last, 0);\n\t\t      }\n\t\t      return first;\n\t\t    }\n\t\t    function siftUp(heap, node, i) {\n\t\t      var index = i;\n\t\t      while (index > 0) {\n\t\t        var parentIndex = index - 1 >>> 1;\n\t\t        var parent = heap[parentIndex];\n\t\t        if (compare(parent, node) > 0) {\n\t\t          // The parent is larger. Swap positions.\n\t\t          heap[parentIndex] = node;\n\t\t          heap[index] = parent;\n\t\t          index = parentIndex;\n\t\t        } else {\n\t\t          // The parent is smaller. Exit.\n\t\t          return;\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t    function siftDown(heap, node, i) {\n\t\t      var index = i;\n\t\t      var length = heap.length;\n\t\t      var halfLength = length >>> 1;\n\t\t      while (index < halfLength) {\n\t\t        var leftIndex = (index + 1) * 2 - 1;\n\t\t        var left = heap[leftIndex];\n\t\t        var rightIndex = leftIndex + 1;\n\t\t        var right = heap[rightIndex]; // If the left or right node is smaller, swap with the smaller of those.\n\n\t\t        if (compare(left, node) < 0) {\n\t\t          if (rightIndex < length && compare(right, left) < 0) {\n\t\t            heap[index] = right;\n\t\t            heap[rightIndex] = node;\n\t\t            index = rightIndex;\n\t\t          } else {\n\t\t            heap[index] = left;\n\t\t            heap[leftIndex] = node;\n\t\t            index = leftIndex;\n\t\t          }\n\t\t        } else if (rightIndex < length && compare(right, node) < 0) {\n\t\t          heap[index] = right;\n\t\t          heap[rightIndex] = node;\n\t\t          index = rightIndex;\n\t\t        } else {\n\t\t          // Neither child is smaller. Exit.\n\t\t          return;\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t    function compare(a, b) {\n\t\t      // Compare sort index first, then task id.\n\t\t      var diff = a.sortIndex - b.sortIndex;\n\t\t      return diff !== 0 ? diff : a.id - b.id;\n\t\t    }\n\n\t\t    // TODO: Use symbols?\n\t\t    var ImmediatePriority = 1;\n\t\t    var UserBlockingPriority = 2;\n\t\t    var NormalPriority = 3;\n\t\t    var LowPriority = 4;\n\t\t    var IdlePriority = 5;\n\t\t    function markTaskErrored(task, ms) {}\n\n\t\t    /* eslint-disable no-var */\n\n\t\t    var hasPerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';\n\t\t    if (hasPerformanceNow) {\n\t\t      var localPerformance = performance;\n\t\t      exports.unstable_now = function () {\n\t\t        return localPerformance.now();\n\t\t      };\n\t\t    } else {\n\t\t      var localDate = Date;\n\t\t      var initialTime = localDate.now();\n\t\t      exports.unstable_now = function () {\n\t\t        return localDate.now() - initialTime;\n\t\t      };\n\t\t    } // Max 31 bit integer. The max integer size in V8 for 32-bit systems.\n\t\t    // Math.pow(2, 30) - 1\n\t\t    // 0b111111111111111111111111111111\n\n\t\t    var maxSigned31BitInt = 1073741823; // Times out immediately\n\n\t\t    var IMMEDIATE_PRIORITY_TIMEOUT = -1; // Eventually times out\n\n\t\t    var USER_BLOCKING_PRIORITY_TIMEOUT = 250;\n\t\t    var NORMAL_PRIORITY_TIMEOUT = 5000;\n\t\t    var LOW_PRIORITY_TIMEOUT = 10000; // Never times out\n\n\t\t    var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt; // Tasks are stored on a min heap\n\n\t\t    var taskQueue = [];\n\t\t    var timerQueue = []; // Incrementing id counter. Used to maintain insertion order.\n\n\t\t    var taskIdCounter = 1; // Pausing the scheduler is useful for debugging.\n\t\t    var currentTask = null;\n\t\t    var currentPriorityLevel = NormalPriority; // This is set while performing work, to prevent re-entrance.\n\n\t\t    var isPerformingWork = false;\n\t\t    var isHostCallbackScheduled = false;\n\t\t    var isHostTimeoutScheduled = false; // Capture local references to native APIs, in case a polyfill overrides them.\n\n\t\t    var localSetTimeout = typeof setTimeout === 'function' ? setTimeout : null;\n\t\t    var localClearTimeout = typeof clearTimeout === 'function' ? clearTimeout : null;\n\t\t    var localSetImmediate = typeof setImmediate !== 'undefined' ? setImmediate : null; // IE and Node.js + jsdom\n\n\t\t    typeof navigator !== 'undefined' && navigator.scheduling !== undefined && navigator.scheduling.isInputPending !== undefined ? navigator.scheduling.isInputPending.bind(navigator.scheduling) : null;\n\t\t    function advanceTimers(currentTime) {\n\t\t      // Check for tasks that are no longer delayed and add them to the queue.\n\t\t      var timer = peek(timerQueue);\n\t\t      while (timer !== null) {\n\t\t        if (timer.callback === null) {\n\t\t          // Timer was cancelled.\n\t\t          pop(timerQueue);\n\t\t        } else if (timer.startTime <= currentTime) {\n\t\t          // Timer fired. Transfer to the task queue.\n\t\t          pop(timerQueue);\n\t\t          timer.sortIndex = timer.expirationTime;\n\t\t          push(taskQueue, timer);\n\t\t        } else {\n\t\t          // Remaining timers are pending.\n\t\t          return;\n\t\t        }\n\t\t        timer = peek(timerQueue);\n\t\t      }\n\t\t    }\n\t\t    function handleTimeout(currentTime) {\n\t\t      isHostTimeoutScheduled = false;\n\t\t      advanceTimers(currentTime);\n\t\t      if (!isHostCallbackScheduled) {\n\t\t        if (peek(taskQueue) !== null) {\n\t\t          isHostCallbackScheduled = true;\n\t\t          requestHostCallback(flushWork);\n\t\t        } else {\n\t\t          var firstTimer = peek(timerQueue);\n\t\t          if (firstTimer !== null) {\n\t\t            requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n\t\t          }\n\t\t        }\n\t\t      }\n\t\t    }\n\t\t    function flushWork(hasTimeRemaining, initialTime) {\n\t\t      isHostCallbackScheduled = false;\n\t\t      if (isHostTimeoutScheduled) {\n\t\t        // We scheduled a timeout but it's no longer needed. Cancel it.\n\t\t        isHostTimeoutScheduled = false;\n\t\t        cancelHostTimeout();\n\t\t      }\n\t\t      isPerformingWork = true;\n\t\t      var previousPriorityLevel = currentPriorityLevel;\n\t\t      try {\n\t\t        var currentTime; if (enableProfiling) ; else {\n\t\t          // No catch in prod code path.\n\t\t          return workLoop(hasTimeRemaining, initialTime);\n\t\t        }\n\t\t      } finally {\n\t\t        currentTask = null;\n\t\t        currentPriorityLevel = previousPriorityLevel;\n\t\t        isPerformingWork = false;\n\t\t      }\n\t\t    }\n\t\t    function workLoop(hasTimeRemaining, initialTime) {\n\t\t      var currentTime = initialTime;\n\t\t      advanceTimers(currentTime);\n\t\t      currentTask = peek(taskQueue);\n\t\t      while (currentTask !== null && !enableSchedulerDebugging) {\n\t\t        if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {\n\t\t          // This currentTask hasn't expired, and we've reached the deadline.\n\t\t          break;\n\t\t        }\n\t\t        var callback = currentTask.callback;\n\t\t        if (typeof callback === 'function') {\n\t\t          currentTask.callback = null;\n\t\t          currentPriorityLevel = currentTask.priorityLevel;\n\t\t          var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;\n\t\t          var continuationCallback = callback(didUserCallbackTimeout);\n\t\t          currentTime = exports.unstable_now();\n\t\t          if (typeof continuationCallback === 'function') {\n\t\t            currentTask.callback = continuationCallback;\n\t\t          } else {\n\t\t            if (currentTask === peek(taskQueue)) {\n\t\t              pop(taskQueue);\n\t\t            }\n\t\t          }\n\t\t          advanceTimers(currentTime);\n\t\t        } else {\n\t\t          pop(taskQueue);\n\t\t        }\n\t\t        currentTask = peek(taskQueue);\n\t\t      } // Return whether there's additional work\n\n\t\t      if (currentTask !== null) {\n\t\t        return true;\n\t\t      } else {\n\t\t        var firstTimer = peek(timerQueue);\n\t\t        if (firstTimer !== null) {\n\t\t          requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n\t\t        }\n\t\t        return false;\n\t\t      }\n\t\t    }\n\t\t    function unstable_runWithPriority(priorityLevel, eventHandler) {\n\t\t      switch (priorityLevel) {\n\t\t        case ImmediatePriority:\n\t\t        case UserBlockingPriority:\n\t\t        case NormalPriority:\n\t\t        case LowPriority:\n\t\t        case IdlePriority:\n\t\t          break;\n\t\t        default:\n\t\t          priorityLevel = NormalPriority;\n\t\t      }\n\t\t      var previousPriorityLevel = currentPriorityLevel;\n\t\t      currentPriorityLevel = priorityLevel;\n\t\t      try {\n\t\t        return eventHandler();\n\t\t      } finally {\n\t\t        currentPriorityLevel = previousPriorityLevel;\n\t\t      }\n\t\t    }\n\t\t    function unstable_next(eventHandler) {\n\t\t      var priorityLevel;\n\t\t      switch (currentPriorityLevel) {\n\t\t        case ImmediatePriority:\n\t\t        case UserBlockingPriority:\n\t\t        case NormalPriority:\n\t\t          // Shift down to normal priority\n\t\t          priorityLevel = NormalPriority;\n\t\t          break;\n\t\t        default:\n\t\t          // Anything lower than normal priority should remain at the current level.\n\t\t          priorityLevel = currentPriorityLevel;\n\t\t          break;\n\t\t      }\n\t\t      var previousPriorityLevel = currentPriorityLevel;\n\t\t      currentPriorityLevel = priorityLevel;\n\t\t      try {\n\t\t        return eventHandler();\n\t\t      } finally {\n\t\t        currentPriorityLevel = previousPriorityLevel;\n\t\t      }\n\t\t    }\n\t\t    function unstable_wrapCallback(callback) {\n\t\t      var parentPriorityLevel = currentPriorityLevel;\n\t\t      return function () {\n\t\t        // This is a fork of runWithPriority, inlined for performance.\n\t\t        var previousPriorityLevel = currentPriorityLevel;\n\t\t        currentPriorityLevel = parentPriorityLevel;\n\t\t        try {\n\t\t          return callback.apply(this, arguments);\n\t\t        } finally {\n\t\t          currentPriorityLevel = previousPriorityLevel;\n\t\t        }\n\t\t      };\n\t\t    }\n\t\t    function unstable_scheduleCallback(priorityLevel, callback, options) {\n\t\t      var currentTime = exports.unstable_now();\n\t\t      var startTime;\n\t\t      if (typeof options === 'object' && options !== null) {\n\t\t        var delay = options.delay;\n\t\t        if (typeof delay === 'number' && delay > 0) {\n\t\t          startTime = currentTime + delay;\n\t\t        } else {\n\t\t          startTime = currentTime;\n\t\t        }\n\t\t      } else {\n\t\t        startTime = currentTime;\n\t\t      }\n\t\t      var timeout;\n\t\t      switch (priorityLevel) {\n\t\t        case ImmediatePriority:\n\t\t          timeout = IMMEDIATE_PRIORITY_TIMEOUT;\n\t\t          break;\n\t\t        case UserBlockingPriority:\n\t\t          timeout = USER_BLOCKING_PRIORITY_TIMEOUT;\n\t\t          break;\n\t\t        case IdlePriority:\n\t\t          timeout = IDLE_PRIORITY_TIMEOUT;\n\t\t          break;\n\t\t        case LowPriority:\n\t\t          timeout = LOW_PRIORITY_TIMEOUT;\n\t\t          break;\n\t\t        case NormalPriority:\n\t\t        default:\n\t\t          timeout = NORMAL_PRIORITY_TIMEOUT;\n\t\t          break;\n\t\t      }\n\t\t      var expirationTime = startTime + timeout;\n\t\t      var newTask = {\n\t\t        id: taskIdCounter++,\n\t\t        callback: callback,\n\t\t        priorityLevel: priorityLevel,\n\t\t        startTime: startTime,\n\t\t        expirationTime: expirationTime,\n\t\t        sortIndex: -1\n\t\t      };\n\t\t      if (startTime > currentTime) {\n\t\t        // This is a delayed task.\n\t\t        newTask.sortIndex = startTime;\n\t\t        push(timerQueue, newTask);\n\t\t        if (peek(taskQueue) === null && newTask === peek(timerQueue)) {\n\t\t          // All tasks are delayed, and this is the task with the earliest delay.\n\t\t          if (isHostTimeoutScheduled) {\n\t\t            // Cancel an existing timeout.\n\t\t            cancelHostTimeout();\n\t\t          } else {\n\t\t            isHostTimeoutScheduled = true;\n\t\t          } // Schedule a timeout.\n\n\t\t          requestHostTimeout(handleTimeout, startTime - currentTime);\n\t\t        }\n\t\t      } else {\n\t\t        newTask.sortIndex = expirationTime;\n\t\t        push(taskQueue, newTask);\n\t\t        // wait until the next time we yield.\n\n\t\t        if (!isHostCallbackScheduled && !isPerformingWork) {\n\t\t          isHostCallbackScheduled = true;\n\t\t          requestHostCallback(flushWork);\n\t\t        }\n\t\t      }\n\t\t      return newTask;\n\t\t    }\n\t\t    function unstable_pauseExecution() {}\n\t\t    function unstable_continueExecution() {\n\t\t      if (!isHostCallbackScheduled && !isPerformingWork) {\n\t\t        isHostCallbackScheduled = true;\n\t\t        requestHostCallback(flushWork);\n\t\t      }\n\t\t    }\n\t\t    function unstable_getFirstCallbackNode() {\n\t\t      return peek(taskQueue);\n\t\t    }\n\t\t    function unstable_cancelCallback(task) {\n\t\t      // remove from the queue because you can't remove arbitrary nodes from an\n\t\t      // array based heap, only the first one.)\n\n\t\t      task.callback = null;\n\t\t    }\n\t\t    function unstable_getCurrentPriorityLevel() {\n\t\t      return currentPriorityLevel;\n\t\t    }\n\t\t    var isMessageLoopRunning = false;\n\t\t    var scheduledHostCallback = null;\n\t\t    var taskTimeoutID = -1; // Scheduler periodically yields in case there is other work on the main\n\t\t    // thread, like user events. By default, it yields multiple times per frame.\n\t\t    // It does not attempt to align with frame boundaries, since most tasks don't\n\t\t    // need to be frame aligned; for those that do, use requestAnimationFrame.\n\n\t\t    var frameInterval = frameYieldMs;\n\t\t    var startTime = -1;\n\t\t    function shouldYieldToHost() {\n\t\t      var timeElapsed = exports.unstable_now() - startTime;\n\t\t      if (timeElapsed < frameInterval) {\n\t\t        // The main thread has only been blocked for a really short amount of time;\n\t\t        // smaller than a single frame. Don't yield yet.\n\t\t        return false;\n\t\t      } // The main thread has been blocked for a non-negligible amount of time. We\n\n\t\t      return true;\n\t\t    }\n\t\t    function requestPaint() {}\n\t\t    function forceFrameRate(fps) {\n\t\t      if (fps < 0 || fps > 125) {\n\t\t        // Using console['error'] to evade Babel and ESLint\n\t\t        console['error']('forceFrameRate takes a positive int between 0 and 125, ' + 'forcing frame rates higher than 125 fps is not supported');\n\t\t        return;\n\t\t      }\n\t\t      if (fps > 0) {\n\t\t        frameInterval = Math.floor(1000 / fps);\n\t\t      } else {\n\t\t        // reset the framerate\n\t\t        frameInterval = frameYieldMs;\n\t\t      }\n\t\t    }\n\t\t    var performWorkUntilDeadline = function () {\n\t\t      if (scheduledHostCallback !== null) {\n\t\t        var currentTime = exports.unstable_now(); // Keep track of the start time so we can measure how long the main thread\n\t\t        // has been blocked.\n\n\t\t        startTime = currentTime;\n\t\t        var hasTimeRemaining = true; // If a scheduler task throws, exit the current browser task so the\n\t\t        // error can be observed.\n\t\t        //\n\t\t        // Intentionally not using a try-catch, since that makes some debugging\n\t\t        // techniques harder. Instead, if `scheduledHostCallback` errors, then\n\t\t        // `hasMoreWork` will remain true, and we'll continue the work loop.\n\n\t\t        var hasMoreWork = true;\n\t\t        try {\n\t\t          hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);\n\t\t        } finally {\n\t\t          if (hasMoreWork) {\n\t\t            // If there's more work, schedule the next message event at the end\n\t\t            // of the preceding one.\n\t\t            schedulePerformWorkUntilDeadline();\n\t\t          } else {\n\t\t            isMessageLoopRunning = false;\n\t\t            scheduledHostCallback = null;\n\t\t          }\n\t\t        }\n\t\t      } else {\n\t\t        isMessageLoopRunning = false;\n\t\t      } // Yielding to the browser will give it a chance to paint, so we can\n\t\t    };\n\n\t\t    var schedulePerformWorkUntilDeadline;\n\t\t    if (typeof localSetImmediate === 'function') {\n\t\t      // Node.js and old IE.\n\t\t      // There's a few reasons for why we prefer setImmediate.\n\t\t      //\n\t\t      // Unlike MessageChannel, it doesn't prevent a Node.js process from exiting.\n\t\t      // (Even though this is a DOM fork of the Scheduler, you could get here\n\t\t      // with a mix of Node.js 15+, which has a MessageChannel, and jsdom.)\n\t\t      // https://github.com/facebook/react/issues/20756\n\t\t      //\n\t\t      // But also, it runs earlier which is the semantic we want.\n\t\t      // If other browsers ever implement it, it's better to use it.\n\t\t      // Although both of these would be inferior to native scheduling.\n\t\t      schedulePerformWorkUntilDeadline = function () {\n\t\t        localSetImmediate(performWorkUntilDeadline);\n\t\t      };\n\t\t    } else if (typeof MessageChannel !== 'undefined') {\n\t\t      // DOM and Worker environments.\n\t\t      // We prefer MessageChannel because of the 4ms setTimeout clamping.\n\t\t      var channel = new MessageChannel();\n\t\t      var port = channel.port2;\n\t\t      channel.port1.onmessage = performWorkUntilDeadline;\n\t\t      schedulePerformWorkUntilDeadline = function () {\n\t\t        port.postMessage(null);\n\t\t      };\n\t\t    } else {\n\t\t      // We should only fallback here in non-browser environments.\n\t\t      schedulePerformWorkUntilDeadline = function () {\n\t\t        localSetTimeout(performWorkUntilDeadline, 0);\n\t\t      };\n\t\t    }\n\t\t    function requestHostCallback(callback) {\n\t\t      scheduledHostCallback = callback;\n\t\t      if (!isMessageLoopRunning) {\n\t\t        isMessageLoopRunning = true;\n\t\t        schedulePerformWorkUntilDeadline();\n\t\t      }\n\t\t    }\n\t\t    function requestHostTimeout(callback, ms) {\n\t\t      taskTimeoutID = localSetTimeout(function () {\n\t\t        callback(exports.unstable_now());\n\t\t      }, ms);\n\t\t    }\n\t\t    function cancelHostTimeout() {\n\t\t      localClearTimeout(taskTimeoutID);\n\t\t      taskTimeoutID = -1;\n\t\t    }\n\t\t    var unstable_requestPaint = requestPaint;\n\t\t    var unstable_Profiling = null;\n\t\t    exports.unstable_IdlePriority = IdlePriority;\n\t\t    exports.unstable_ImmediatePriority = ImmediatePriority;\n\t\t    exports.unstable_LowPriority = LowPriority;\n\t\t    exports.unstable_NormalPriority = NormalPriority;\n\t\t    exports.unstable_Profiling = unstable_Profiling;\n\t\t    exports.unstable_UserBlockingPriority = UserBlockingPriority;\n\t\t    exports.unstable_cancelCallback = unstable_cancelCallback;\n\t\t    exports.unstable_continueExecution = unstable_continueExecution;\n\t\t    exports.unstable_forceFrameRate = forceFrameRate;\n\t\t    exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;\n\t\t    exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;\n\t\t    exports.unstable_next = unstable_next;\n\t\t    exports.unstable_pauseExecution = unstable_pauseExecution;\n\t\t    exports.unstable_requestPaint = unstable_requestPaint;\n\t\t    exports.unstable_runWithPriority = unstable_runWithPriority;\n\t\t    exports.unstable_scheduleCallback = unstable_scheduleCallback;\n\t\t    exports.unstable_shouldYield = shouldYieldToHost;\n\t\t    exports.unstable_wrapCallback = unstable_wrapCallback;\n\t\t    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n\t\t    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === 'function') {\n\t\t      __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n\t\t    }\n\t\t  })();\n\t\t}\n\t} (scheduler_development));\n\n\t(function (module) {\n\n\t\t{\n\t\t  module.exports = scheduler_development;\n\t\t}\n\t} (scheduler));\n\n\t/**\n\t * @license React\n\t * react-dom.development.js\n\t *\n\t * Copyright (c) Facebook, Inc. and its affiliates.\n\t *\n\t * This source code is licensed under the MIT license found in the\n\t * LICENSE file in the root directory of this source tree.\n\t */\n\t{(function(){/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__!=='undefined'&&typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart==='function'){__REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());}var React=reactExports;var Scheduler=schedulerExports;var ReactSharedInternals=React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;var suppressWarning=false;function setSuppressWarning(newSuppressWarning){{suppressWarning=newSuppressWarning;}}// In DEV, calls to console.warn and console.error get replaced\n\t// by calls to these methods by a Babel plugin.\n\t//\n\t// In PROD (or in packages without access to React internals),\n\t// they are left as they are instead.\n\tfunction warn(format){{if(!suppressWarning){for(var _len=arguments.length,args=new Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){args[_key-1]=arguments[_key];}printWarning('warn',format,args);}}}function error(format){{if(!suppressWarning){for(var _len2=arguments.length,args=new Array(_len2>1?_len2-1:0),_key2=1;_key2<_len2;_key2++){args[_key2-1]=arguments[_key2];}printWarning('error',format,args);}}}function printWarning(level,format,args){// When changing this logic, you might want to also\n\t// update consoleWithStackDev.www.js as well.\n\t{var ReactDebugCurrentFrame=ReactSharedInternals.ReactDebugCurrentFrame;var stack=ReactDebugCurrentFrame.getStackAddendum();if(stack!==''){format+='%s';args=args.concat([stack]);}// eslint-disable-next-line react-internal/safe-string-coercion\n\tvar argsWithFormat=args.map(function(item){return String(item);});// Careful: RN currently depends on this prefix\n\targsWithFormat.unshift('Warning: '+format);// We intentionally don't use spread (or .apply) directly because it\n\t// breaks IE9: https://github.com/facebook/react/issues/13610\n\t// eslint-disable-next-line react-internal/no-production-logging\n\tFunction.prototype.apply.call(console[level],console,argsWithFormat);}}var FunctionComponent=0;var ClassComponent=1;var IndeterminateComponent=2;// Before we know whether it is function or class\n\tvar HostRoot=3;// Root of a host tree. Could be nested inside another node.\n\tvar HostPortal=4;// A subtree. Could be an entry point to a different renderer.\n\tvar HostComponent=5;var HostText=6;var Fragment=7;var Mode=8;var ContextConsumer=9;var ContextProvider=10;var ForwardRef=11;var Profiler=12;var SuspenseComponent=13;var MemoComponent=14;var SimpleMemoComponent=15;var LazyComponent=16;var IncompleteClassComponent=17;var DehydratedFragment=18;var SuspenseListComponent=19;var ScopeComponent=21;var OffscreenComponent=22;var LegacyHiddenComponent=23;var CacheComponent=24;var TracingMarkerComponent=25;// -----------------------------------------------------------------------------\n\tvar enableClientRenderFallbackOnTextMismatch=true;// TODO: Need to review this code one more time before landing\n\t// the react-reconciler package.\n\tvar enableNewReconciler=false;// Support legacy Primer support on internal FB www\n\tvar enableLazyContextPropagation=false;// FB-only usage. The new API has different semantics.\n\tvar enableLegacyHidden=false;// Enables unstable_avoidThisFallback feature in Fiber\n\tvar enableSuspenseAvoidThisFallback=false;// Enables unstable_avoidThisFallback feature in Fizz\n\t// React DOM Chopping Block\n\t//\n\t// Similar to main Chopping Block but only flags related to React DOM. These are\n\t// grouped because we will likely batch all of them into a single major release.\n\t// -----------------------------------------------------------------------------\n\t// Disable support for comment nodes as React DOM containers. Already disabled\n\t// in open source, but www codebase still relies on it. Need to remove.\n\tvar disableCommentsAsDOMContainers=true;// Disable javascript: URL strings in href for XSS protection.\n\t// and client rendering, mostly to allow JSX attributes to apply to the custom\n\t// element's object properties instead of only HTML attributes.\n\t// https://github.com/facebook/react/issues/11347\n\tvar enableCustomElementPropertySupport=false;// Disables children for <textarea> elements\n\tvar warnAboutStringRefs=false;// -----------------------------------------------------------------------------\n\t// Debugging and DevTools\n\t// -----------------------------------------------------------------------------\n\t// Adds user timing marks for e.g. state updates, suspense, and work loop stuff,\n\t// for an experimental timeline tool.\n\tvar enableSchedulingProfiler=true;// Helps identify side effects in render-phase lifecycle hooks and setState\n\tvar enableProfilerTimer=true;// Record durations for commit and passive effects phases.\n\tvar enableProfilerCommitHooks=true;// Phase param passed to onRender callback differentiates between an \"update\" and a \"cascading-update\".\n\tvar allNativeEvents=new Set();/**\n\t * Mapping from registration name to event name\n\t */var registrationNameDependencies={};/**\n\t * Mapping from lowercase registration names to the properly cased version,\n\t * used to warn in the case of missing event handlers. Available\n\t * only in true.\n\t * @type {Object}\n\t */var possibleRegistrationNames={};// Trust the developer to only use possibleRegistrationNames in true\n\tfunction registerTwoPhaseEvent(registrationName,dependencies){registerDirectEvent(registrationName,dependencies);registerDirectEvent(registrationName+'Capture',dependencies);}function registerDirectEvent(registrationName,dependencies){{if(registrationNameDependencies[registrationName]){error('EventRegistry: More than one plugin attempted to publish the same '+'registration name, `%s`.',registrationName);}}registrationNameDependencies[registrationName]=dependencies;{var lowerCasedName=registrationName.toLowerCase();possibleRegistrationNames[lowerCasedName]=registrationName;if(registrationName==='onDoubleClick'){possibleRegistrationNames.ondblclick=registrationName;}}for(var i=0;i<dependencies.length;i++){allNativeEvents.add(dependencies[i]);}}var canUseDOM=!!(typeof window!=='undefined'&&typeof window.document!=='undefined'&&typeof window.document.createElement!=='undefined');var hasOwnProperty=Object.prototype.hasOwnProperty;/*\n\t * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol\n\t * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n\t *\n\t * The functions in this module will throw an easier-to-understand,\n\t * easier-to-debug exception with a clear errors message message explaining the\n\t * problem. (Instead of a confusing exception thrown inside the implementation\n\t * of the `value` object).\n\t */ // $FlowFixMe only called in DEV, so void return is not possible.\n\tfunction typeName(value){{// toStringTag is needed for namespaced types like Temporal.Instant\n\tvar hasToStringTag=typeof Symbol==='function'&&Symbol.toStringTag;var type=hasToStringTag&&value[Symbol.toStringTag]||value.constructor.name||'Object';return type;}}// $FlowFixMe only called in DEV, so void return is not possible.\n\tfunction willCoercionThrow(value){{try{testStringCoercion(value);return false;}catch(e){return true;}}}function testStringCoercion(value){// If you ended up here by following an exception call stack, here's what's\n\t// happened: you supplied an object or symbol value to React (as a prop, key,\n\t// DOM attribute, CSS property, string ref, etc.) and when React tried to\n\t// coerce it to a string using `'' + value`, an exception was thrown.\n\t//\n\t// The most common types that will cause this exception are `Symbol` instances\n\t// and Temporal objects like `Temporal.Instant`. But any object that has a\n\t// `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n\t// exception. (Library authors do this to prevent users from using built-in\n\t// numeric operators like `+` or comparison operators like `>=` because custom\n\t// methods are needed to perform accurate arithmetic or comparison.)\n\t//\n\t// To fix the problem, coerce this object or symbol value to a string before\n\t// passing it to React. The most reliable way is usually `String(value)`.\n\t//\n\t// To find which value is throwing, check the browser or debugger console.\n\t// Before this exception was thrown, there should be `console.error` output\n\t// that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n\t// problem and how that type was used: key, atrribute, input value prop, etc.\n\t// In most cases, this console output also shows the component and its\n\t// ancestor components where the exception happened.\n\t//\n\t// eslint-disable-next-line react-internal/safe-string-coercion\n\treturn ''+value;}function checkAttributeStringCoercion(value,attributeName){{if(willCoercionThrow(value)){error('The provided `%s` attribute is an unsupported type %s.'+' This value must be coerced to a string before before using it here.',attributeName,typeName(value));return testStringCoercion(value);// throw (to help callers find troubleshooting comments)\n\t}}}function checkKeyStringCoercion(value){{if(willCoercionThrow(value)){error('The provided key is an unsupported type %s.'+' This value must be coerced to a string before before using it here.',typeName(value));return testStringCoercion(value);// throw (to help callers find troubleshooting comments)\n\t}}}function checkPropStringCoercion(value,propName){{if(willCoercionThrow(value)){error('The provided `%s` prop is an unsupported type %s.'+' This value must be coerced to a string before before using it here.',propName,typeName(value));return testStringCoercion(value);// throw (to help callers find troubleshooting comments)\n\t}}}function checkCSSPropertyStringCoercion(value,propName){{if(willCoercionThrow(value)){error('The provided `%s` CSS property is an unsupported type %s.'+' This value must be coerced to a string before before using it here.',propName,typeName(value));return testStringCoercion(value);// throw (to help callers find troubleshooting comments)\n\t}}}function checkHtmlStringCoercion(value){{if(willCoercionThrow(value)){error('The provided HTML markup uses a value of unsupported type %s.'+' This value must be coerced to a string before before using it here.',typeName(value));return testStringCoercion(value);// throw (to help callers find troubleshooting comments)\n\t}}}function checkFormFieldValueStringCoercion(value){{if(willCoercionThrow(value)){error('Form field values (value, checked, defaultValue, or defaultChecked props)'+' must be strings, not %s.'+' This value must be coerced to a string before before using it here.',typeName(value));return testStringCoercion(value);// throw (to help callers find troubleshooting comments)\n\t}}}// A reserved attribute.\n\t// It is handled by React separately and shouldn't be written to the DOM.\n\tvar RESERVED=0;// A simple string attribute.\n\t// Attributes that aren't in the filter are presumed to have this type.\n\tvar STRING=1;// A string attribute that accepts booleans in React. In HTML, these are called\n\t// \"enumerated\" attributes with \"true\" and \"false\" as possible values.\n\t// When true, it should be set to a \"true\" string.\n\t// When false, it should be set to a \"false\" string.\n\tvar BOOLEANISH_STRING=2;// A real boolean attribute.\n\t// When true, it should be present (set either to an empty string or its name).\n\t// When false, it should be omitted.\n\tvar BOOLEAN=3;// An attribute that can be used as a flag as well as with a value.\n\t// When true, it should be present (set either to an empty string or its name).\n\t// When false, it should be omitted.\n\t// For any other value, should be present with that value.\n\tvar OVERLOADED_BOOLEAN=4;// An attribute that must be numeric or parse as a numeric.\n\t// When falsy, it should be removed.\n\tvar NUMERIC=5;// An attribute that must be positive numeric or parse as a positive numeric.\n\t// When falsy, it should be removed.\n\tvar POSITIVE_NUMERIC=6;/* eslint-disable max-len */var ATTRIBUTE_NAME_START_CHAR=\":A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\";/* eslint-enable max-len */var ATTRIBUTE_NAME_CHAR=ATTRIBUTE_NAME_START_CHAR+\"\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040\";var VALID_ATTRIBUTE_NAME_REGEX=new RegExp('^['+ATTRIBUTE_NAME_START_CHAR+']['+ATTRIBUTE_NAME_CHAR+']*$');var illegalAttributeNameCache={};var validatedAttributeNameCache={};function isAttributeNameSafe(attributeName){if(hasOwnProperty.call(validatedAttributeNameCache,attributeName)){return true;}if(hasOwnProperty.call(illegalAttributeNameCache,attributeName)){return false;}if(VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)){validatedAttributeNameCache[attributeName]=true;return true;}illegalAttributeNameCache[attributeName]=true;{error('Invalid attribute name: `%s`',attributeName);}return false;}function shouldIgnoreAttribute(name,propertyInfo,isCustomComponentTag){if(propertyInfo!==null){return propertyInfo.type===RESERVED;}if(isCustomComponentTag){return false;}if(name.length>2&&(name[0]==='o'||name[0]==='O')&&(name[1]==='n'||name[1]==='N')){return true;}return false;}function shouldRemoveAttributeWithWarning(name,value,propertyInfo,isCustomComponentTag){if(propertyInfo!==null&&propertyInfo.type===RESERVED){return false;}switch(typeof value){case'function':// $FlowIssue symbol is perfectly valid here\n\tcase'symbol':// eslint-disable-line\n\treturn true;case'boolean':{if(isCustomComponentTag){return false;}if(propertyInfo!==null){return !propertyInfo.acceptsBooleans;}else {var prefix=name.toLowerCase().slice(0,5);return prefix!=='data-'&&prefix!=='aria-';}}default:return false;}}function shouldRemoveAttribute(name,value,propertyInfo,isCustomComponentTag){if(value===null||typeof value==='undefined'){return true;}if(shouldRemoveAttributeWithWarning(name,value,propertyInfo,isCustomComponentTag)){return true;}if(isCustomComponentTag){return false;}if(propertyInfo!==null){switch(propertyInfo.type){case BOOLEAN:return !value;case OVERLOADED_BOOLEAN:return value===false;case NUMERIC:return isNaN(value);case POSITIVE_NUMERIC:return isNaN(value)||value<1;}}return false;}function getPropertyInfo(name){return properties.hasOwnProperty(name)?properties[name]:null;}function PropertyInfoRecord(name,type,mustUseProperty,attributeName,attributeNamespace,sanitizeURL,removeEmptyString){this.acceptsBooleans=type===BOOLEANISH_STRING||type===BOOLEAN||type===OVERLOADED_BOOLEAN;this.attributeName=attributeName;this.attributeNamespace=attributeNamespace;this.mustUseProperty=mustUseProperty;this.propertyName=name;this.type=type;this.sanitizeURL=sanitizeURL;this.removeEmptyString=removeEmptyString;}// When adding attributes to this list, be sure to also add them to\n\t// the `possibleStandardNames` module to ensure casing and incorrect\n\t// name warnings.\n\tvar properties={};// These props are reserved by React. They shouldn't be written to the DOM.\n\tvar reservedProps=['children','dangerouslySetInnerHTML',// TODO: This prevents the assignment of defaultValue to regular\n\t// elements (not just inputs). Now that ReactDOMInput assigns to the\n\t// defaultValue property -- do we need this?\n\t'defaultValue','defaultChecked','innerHTML','suppressContentEditableWarning','suppressHydrationWarning','style'];reservedProps.forEach(function(name){properties[name]=new PropertyInfoRecord(name,RESERVED,false,// mustUseProperty\n\tname,// attributeName\n\tnull,// attributeNamespace\n\tfalse,// sanitizeURL\n\tfalse);});// A few React string attributes have a different name.\n\t// This is a mapping from React prop names to the attribute names.\n\t[['acceptCharset','accept-charset'],['className','class'],['htmlFor','for'],['httpEquiv','http-equiv']].forEach(function(_ref){var name=_ref[0],attributeName=_ref[1];properties[name]=new PropertyInfoRecord(name,STRING,false,// mustUseProperty\n\tattributeName,// attributeName\n\tnull,// attributeNamespace\n\tfalse,// sanitizeURL\n\tfalse);});// These are \"enumerated\" HTML attributes that accept \"true\" and \"false\".\n\t// In React, we let users pass `true` and `false` even though technically\n\t// these aren't boolean attributes (they are coerced to strings).\n\t['contentEditable','draggable','spellCheck','value'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,BOOLEANISH_STRING,false,// mustUseProperty\n\tname.toLowerCase(),// attributeName\n\tnull,// attributeNamespace\n\tfalse,// sanitizeURL\n\tfalse);});// These are \"enumerated\" SVG attributes that accept \"true\" and \"false\".\n\t// In React, we let users pass `true` and `false` even though technically\n\t// these aren't boolean attributes (they are coerced to strings).\n\t// Since these are SVG attributes, their attribute names are case-sensitive.\n\t['autoReverse','externalResourcesRequired','focusable','preserveAlpha'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,BOOLEANISH_STRING,false,// mustUseProperty\n\tname,// attributeName\n\tnull,// attributeNamespace\n\tfalse,// sanitizeURL\n\tfalse);});// These are HTML boolean attributes.\n\t['allowFullScreen','async',// Note: there is a special case that prevents it from being written to the DOM\n\t// on the client side because the browsers are inconsistent. Instead we call focus().\n\t'autoFocus','autoPlay','controls','default','defer','disabled','disablePictureInPicture','disableRemotePlayback','formNoValidate','hidden','loop','noModule','noValidate','open','playsInline','readOnly','required','reversed','scoped','seamless',// Microdata\n\t'itemScope'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,BOOLEAN,false,// mustUseProperty\n\tname.toLowerCase(),// attributeName\n\tnull,// attributeNamespace\n\tfalse,// sanitizeURL\n\tfalse);});// These are the few React props that we set as DOM properties\n\t// rather than attributes. These are all booleans.\n\t['checked',// Note: `option.selected` is not updated if `select.multiple` is\n\t// disabled with `removeAttribute`. We have special logic for handling this.\n\t'multiple','muted','selected'// NOTE: if you add a camelCased prop to this list,\n\t// you'll need to set attributeName to name.toLowerCase()\n\t// instead in the assignment below.\n\t].forEach(function(name){properties[name]=new PropertyInfoRecord(name,BOOLEAN,true,// mustUseProperty\n\tname,// attributeName\n\tnull,// attributeNamespace\n\tfalse,// sanitizeURL\n\tfalse);});// These are HTML attributes that are \"overloaded booleans\": they behave like\n\t// booleans, but can also accept a string value.\n\t['capture','download'// NOTE: if you add a camelCased prop to this list,\n\t// you'll need to set attributeName to name.toLowerCase()\n\t// instead in the assignment below.\n\t].forEach(function(name){properties[name]=new PropertyInfoRecord(name,OVERLOADED_BOOLEAN,false,// mustUseProperty\n\tname,// attributeName\n\tnull,// attributeNamespace\n\tfalse,// sanitizeURL\n\tfalse);});// These are HTML attributes that must be positive numbers.\n\t['cols','rows','size','span'// NOTE: if you add a camelCased prop to this list,\n\t// you'll need to set attributeName to name.toLowerCase()\n\t// instead in the assignment below.\n\t].forEach(function(name){properties[name]=new PropertyInfoRecord(name,POSITIVE_NUMERIC,false,// mustUseProperty\n\tname,// attributeName\n\tnull,// attributeNamespace\n\tfalse,// sanitizeURL\n\tfalse);});// These are HTML attributes that must be numbers.\n\t['rowSpan','start'].forEach(function(name){properties[name]=new PropertyInfoRecord(name,NUMERIC,false,// mustUseProperty\n\tname.toLowerCase(),// attributeName\n\tnull,// attributeNamespace\n\tfalse,// sanitizeURL\n\tfalse);});var CAMELIZE=/[\\-\\:]([a-z])/g;var capitalize=function(token){return token[1].toUpperCase();};// This is a list of all SVG attributes that need special casing, namespacing,\n\t// or boolean value assignment. Regular attributes that just accept strings\n\t// and have the same names are omitted, just like in the HTML attribute filter.\n\t// Some of these attributes can be hard to find. This list was created by\n\t// scraping the MDN documentation.\n\t['accent-height','alignment-baseline','arabic-form','baseline-shift','cap-height','clip-path','clip-rule','color-interpolation','color-interpolation-filters','color-profile','color-rendering','dominant-baseline','enable-background','fill-opacity','fill-rule','flood-color','flood-opacity','font-family','font-size','font-size-adjust','font-stretch','font-style','font-variant','font-weight','glyph-name','glyph-orientation-horizontal','glyph-orientation-vertical','horiz-adv-x','horiz-origin-x','image-rendering','letter-spacing','lighting-color','marker-end','marker-mid','marker-start','overline-position','overline-thickness','paint-order','panose-1','pointer-events','rendering-intent','shape-rendering','stop-color','stop-opacity','strikethrough-position','strikethrough-thickness','stroke-dasharray','stroke-dashoffset','stroke-linecap','stroke-linejoin','stroke-miterlimit','stroke-opacity','stroke-width','text-anchor','text-decoration','text-rendering','underline-position','underline-thickness','unicode-bidi','unicode-range','units-per-em','v-alphabetic','v-hanging','v-ideographic','v-mathematical','vector-effect','vert-adv-y','vert-origin-x','vert-origin-y','word-spacing','writing-mode','xmlns:xlink','x-height'// NOTE: if you add a camelCased prop to this list,\n\t// you'll need to set attributeName to name.toLowerCase()\n\t// instead in the assignment below.\n\t].forEach(function(attributeName){var name=attributeName.replace(CAMELIZE,capitalize);properties[name]=new PropertyInfoRecord(name,STRING,false,// mustUseProperty\n\tattributeName,null,// attributeNamespace\n\tfalse,// sanitizeURL\n\tfalse);});// String SVG attributes with the xlink namespace.\n\t['xlink:actuate','xlink:arcrole','xlink:role','xlink:show','xlink:title','xlink:type'// NOTE: if you add a camelCased prop to this list,\n\t// you'll need to set attributeName to name.toLowerCase()\n\t// instead in the assignment below.\n\t].forEach(function(attributeName){var name=attributeName.replace(CAMELIZE,capitalize);properties[name]=new PropertyInfoRecord(name,STRING,false,// mustUseProperty\n\tattributeName,'http://www.w3.org/1999/xlink',false,// sanitizeURL\n\tfalse);});// String SVG attributes with the xml namespace.\n\t['xml:base','xml:lang','xml:space'// NOTE: if you add a camelCased prop to this list,\n\t// you'll need to set attributeName to name.toLowerCase()\n\t// instead in the assignment below.\n\t].forEach(function(attributeName){var name=attributeName.replace(CAMELIZE,capitalize);properties[name]=new PropertyInfoRecord(name,STRING,false,// mustUseProperty\n\tattributeName,'http://www.w3.org/XML/1998/namespace',false,// sanitizeURL\n\tfalse);});// These attribute exists both in HTML and SVG.\n\t// The attribute name is case-sensitive in SVG so we can't just use\n\t// the React name like we do for attributes that exist only in HTML.\n\t['tabIndex','crossOrigin'].forEach(function(attributeName){properties[attributeName]=new PropertyInfoRecord(attributeName,STRING,false,// mustUseProperty\n\tattributeName.toLowerCase(),// attributeName\n\tnull,// attributeNamespace\n\tfalse,// sanitizeURL\n\tfalse);});// These attributes accept URLs. These must not allow javascript: URLS.\n\t// These will also need to accept Trusted Types object in the future.\n\tvar xlinkHref='xlinkHref';properties[xlinkHref]=new PropertyInfoRecord('xlinkHref',STRING,false,// mustUseProperty\n\t'xlink:href','http://www.w3.org/1999/xlink',true,// sanitizeURL\n\tfalse);['src','href','action','formAction'].forEach(function(attributeName){properties[attributeName]=new PropertyInfoRecord(attributeName,STRING,false,// mustUseProperty\n\tattributeName.toLowerCase(),// attributeName\n\tnull,// attributeNamespace\n\ttrue,// sanitizeURL\n\ttrue);});// and any newline or tab are filtered out as if they're not part of the URL.\n\t// https://url.spec.whatwg.org/#url-parsing\n\t// Tab or newline are defined as \\r\\n\\t:\n\t// https://infra.spec.whatwg.org/#ascii-tab-or-newline\n\t// A C0 control is a code point in the range \\u0000 NULL to \\u001F\n\t// INFORMATION SEPARATOR ONE, inclusive:\n\t// https://infra.spec.whatwg.org/#c0-control-or-space\n\t/* eslint-disable max-len */var isJavaScriptProtocol=/^[\\u0000-\\u001F ]*j[\\r\\n\\t]*a[\\r\\n\\t]*v[\\r\\n\\t]*a[\\r\\n\\t]*s[\\r\\n\\t]*c[\\r\\n\\t]*r[\\r\\n\\t]*i[\\r\\n\\t]*p[\\r\\n\\t]*t[\\r\\n\\t]*\\:/i;var didWarn=false;function sanitizeURL(url){{if(!didWarn&&isJavaScriptProtocol.test(url)){didWarn=true;error('A future version of React will block javascript: URLs as a security precaution. '+'Use event handlers instead if you can. If you need to generate unsafe HTML try '+'using dangerouslySetInnerHTML instead. React was passed %s.',JSON.stringify(url));}}}/**\n\t * Get the value for a property on a node. Only used in DEV for SSR validation.\n\t * The \"expected\" argument is used as a hint of what the expected value is.\n\t * Some properties have multiple equivalent values.\n\t */function getValueForProperty(node,name,expected,propertyInfo){{if(propertyInfo.mustUseProperty){var propertyName=propertyInfo.propertyName;return node[propertyName];}else {// This check protects multiple uses of `expected`, which is why the\n\t// react-internal/safe-string-coercion rule is disabled in several spots\n\t// below.\n\t{checkAttributeStringCoercion(expected,name);}if(propertyInfo.sanitizeURL){// If we haven't fully disabled javascript: URLs, and if\n\t// the hydration is successful of a javascript: URL, we\n\t// still want to warn on the client.\n\t// eslint-disable-next-line react-internal/safe-string-coercion\n\tsanitizeURL(''+expected);}var attributeName=propertyInfo.attributeName;var stringValue=null;if(propertyInfo.type===OVERLOADED_BOOLEAN){if(node.hasAttribute(attributeName)){var value=node.getAttribute(attributeName);if(value===''){return true;}if(shouldRemoveAttribute(name,expected,propertyInfo,false)){return value;}// eslint-disable-next-line react-internal/safe-string-coercion\n\tif(value===''+expected){return expected;}return value;}}else if(node.hasAttribute(attributeName)){if(shouldRemoveAttribute(name,expected,propertyInfo,false)){// We had an attribute but shouldn't have had one, so read it\n\t// for the error message.\n\treturn node.getAttribute(attributeName);}if(propertyInfo.type===BOOLEAN){// If this was a boolean, it doesn't matter what the value is\n\t// the fact that we have it is the same as the expected.\n\treturn expected;}// Even if this property uses a namespace we use getAttribute\n\t// because we assume its namespaced name is the same as our config.\n\t// To use getAttributeNS we need the local name which we don't have\n\t// in our config atm.\n\tstringValue=node.getAttribute(attributeName);}if(shouldRemoveAttribute(name,expected,propertyInfo,false)){return stringValue===null?expected:stringValue;// eslint-disable-next-line react-internal/safe-string-coercion\n\t}else if(stringValue===''+expected){return expected;}else {return stringValue;}}}}/**\n\t * Get the value for a attribute on a node. Only used in DEV for SSR validation.\n\t * The third argument is used as a hint of what the expected value is. Some\n\t * attributes have multiple equivalent values.\n\t */function getValueForAttribute(node,name,expected,isCustomComponentTag){{if(!isAttributeNameSafe(name)){return;}if(!node.hasAttribute(name)){return expected===undefined?undefined:null;}var value=node.getAttribute(name);{checkAttributeStringCoercion(expected,name);}if(value===''+expected){return expected;}return value;}}/**\n\t * Sets the value for a property on a node.\n\t *\n\t * @param {DOMElement} node\n\t * @param {string} name\n\t * @param {*} value\n\t */function setValueForProperty(node,name,value,isCustomComponentTag){var propertyInfo=getPropertyInfo(name);if(shouldIgnoreAttribute(name,propertyInfo,isCustomComponentTag)){return;}if(shouldRemoveAttribute(name,value,propertyInfo,isCustomComponentTag)){value=null;}if(isCustomComponentTag||propertyInfo===null){if(isAttributeNameSafe(name)){var _attributeName=name;if(value===null){node.removeAttribute(_attributeName);}else {{checkAttributeStringCoercion(value,name);}node.setAttribute(_attributeName,''+value);}}return;}var mustUseProperty=propertyInfo.mustUseProperty;if(mustUseProperty){var propertyName=propertyInfo.propertyName;if(value===null){var type=propertyInfo.type;node[propertyName]=type===BOOLEAN?false:'';}else {// Contrary to `setAttribute`, object properties are properly\n\t// `toString`ed by IE8/9.\n\tnode[propertyName]=value;}return;}// The rest are treated as attributes with special cases.\n\tvar attributeName=propertyInfo.attributeName,attributeNamespace=propertyInfo.attributeNamespace;if(value===null){node.removeAttribute(attributeName);}else {var _type=propertyInfo.type;var attributeValue;if(_type===BOOLEAN||_type===OVERLOADED_BOOLEAN&&value===true){// If attribute type is boolean, we know for sure it won't be an execution sink\n\t// and we won't require Trusted Type here.\n\tattributeValue='';}else {// `setAttribute` with objects becomes only `[object]` in IE8/9,\n\t// ('' + value) makes it output the correct toString()-value.\n\t{{checkAttributeStringCoercion(value,attributeName);}attributeValue=''+value;}if(propertyInfo.sanitizeURL){sanitizeURL(attributeValue.toString());}}if(attributeNamespace){node.setAttributeNS(attributeNamespace,attributeName,attributeValue);}else {node.setAttribute(attributeName,attributeValue);}}}// ATTENTION\n\t// When adding new symbols to this file,\n\t// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n\t// The Symbol used to tag the ReactElement-like types.\n\tvar REACT_ELEMENT_TYPE=Symbol.for('react.element');var REACT_PORTAL_TYPE=Symbol.for('react.portal');var REACT_FRAGMENT_TYPE=Symbol.for('react.fragment');var REACT_STRICT_MODE_TYPE=Symbol.for('react.strict_mode');var REACT_PROFILER_TYPE=Symbol.for('react.profiler');var REACT_PROVIDER_TYPE=Symbol.for('react.provider');var REACT_CONTEXT_TYPE=Symbol.for('react.context');var REACT_FORWARD_REF_TYPE=Symbol.for('react.forward_ref');var REACT_SUSPENSE_TYPE=Symbol.for('react.suspense');var REACT_SUSPENSE_LIST_TYPE=Symbol.for('react.suspense_list');var REACT_MEMO_TYPE=Symbol.for('react.memo');var REACT_LAZY_TYPE=Symbol.for('react.lazy');var REACT_SCOPE_TYPE=Symbol.for('react.scope');var REACT_DEBUG_TRACING_MODE_TYPE=Symbol.for('react.debug_trace_mode');var REACT_OFFSCREEN_TYPE=Symbol.for('react.offscreen');var REACT_LEGACY_HIDDEN_TYPE=Symbol.for('react.legacy_hidden');var REACT_CACHE_TYPE=Symbol.for('react.cache');var REACT_TRACING_MARKER_TYPE=Symbol.for('react.tracing_marker');var MAYBE_ITERATOR_SYMBOL=Symbol.iterator;var FAUX_ITERATOR_SYMBOL='@@iterator';function getIteratorFn(maybeIterable){if(maybeIterable===null||typeof maybeIterable!=='object'){return null;}var maybeIterator=MAYBE_ITERATOR_SYMBOL&&maybeIterable[MAYBE_ITERATOR_SYMBOL]||maybeIterable[FAUX_ITERATOR_SYMBOL];if(typeof maybeIterator==='function'){return maybeIterator;}return null;}var assign=Object.assign;// Helpers to patch console.logs to avoid logging during side-effect free\n\t// replaying on render function. This currently only patches the object\n\t// lazily which won't cover if the log function was extracted eagerly.\n\t// We could also eagerly patch the method.\n\tvar disabledDepth=0;var prevLog;var prevInfo;var prevWarn;var prevError;var prevGroup;var prevGroupCollapsed;var prevGroupEnd;function disabledLog(){}disabledLog.__reactDisabledLog=true;function disableLogs(){{if(disabledDepth===0){/* eslint-disable react-internal/no-production-logging */prevLog=console.log;prevInfo=console.info;prevWarn=console.warn;prevError=console.error;prevGroup=console.group;prevGroupCollapsed=console.groupCollapsed;prevGroupEnd=console.groupEnd;// https://github.com/facebook/react/issues/19099\n\tvar props={configurable:true,enumerable:true,value:disabledLog,writable:true};// $FlowFixMe Flow thinks console is immutable.\n\tObject.defineProperties(console,{info:props,log:props,warn:props,error:props,group:props,groupCollapsed:props,groupEnd:props});/* eslint-enable react-internal/no-production-logging */}disabledDepth++;}}function reenableLogs(){{disabledDepth--;if(disabledDepth===0){/* eslint-disable react-internal/no-production-logging */var props={configurable:true,enumerable:true,writable:true};// $FlowFixMe Flow thinks console is immutable.\n\tObject.defineProperties(console,{log:assign({},props,{value:prevLog}),info:assign({},props,{value:prevInfo}),warn:assign({},props,{value:prevWarn}),error:assign({},props,{value:prevError}),group:assign({},props,{value:prevGroup}),groupCollapsed:assign({},props,{value:prevGroupCollapsed}),groupEnd:assign({},props,{value:prevGroupEnd})});/* eslint-enable react-internal/no-production-logging */}if(disabledDepth<0){error('disabledDepth fell below zero. '+'This is a bug in React. Please file an issue.');}}}var ReactCurrentDispatcher=ReactSharedInternals.ReactCurrentDispatcher;var prefix;function describeBuiltInComponentFrame(name,source,ownerFn){{if(prefix===undefined){// Extract the VM specific prefix used by each line.\n\ttry{throw Error();}catch(x){var match=x.stack.trim().match(/\\n( *(at )?)/);prefix=match&&match[1]||'';}}// We use the prefix to ensure our stacks line up with native stack frames.\n\treturn '\\n'+prefix+name;}}var reentry=false;var componentFrameCache;{var PossiblyWeakMap=typeof WeakMap==='function'?WeakMap:Map;componentFrameCache=new PossiblyWeakMap();}function describeNativeComponentFrame(fn,construct){// If something asked for a stack inside a fake render, it should get ignored.\n\tif(!fn||reentry){return '';}{var frame=componentFrameCache.get(fn);if(frame!==undefined){return frame;}}var control;reentry=true;var previousPrepareStackTrace=Error.prepareStackTrace;// $FlowFixMe It does accept undefined.\n\tError.prepareStackTrace=undefined;var previousDispatcher;{previousDispatcher=ReactCurrentDispatcher.current;// Set the dispatcher in DEV because this might be call in the render function\n\t// for warnings.\n\tReactCurrentDispatcher.current=null;disableLogs();}try{// This should throw.\n\tif(construct){// Something should be setting the props in the constructor.\n\tvar Fake=function(){throw Error();};// $FlowFixMe\n\tObject.defineProperty(Fake.prototype,'props',{set:function(){// We use a throwing setter instead of frozen or non-writable props\n\t// because that won't throw in a non-strict mode function.\n\tthrow Error();}});if(typeof Reflect==='object'&&Reflect.construct){// We construct a different control for this case to include any extra\n\t// frames added by the construct call.\n\ttry{Reflect.construct(Fake,[]);}catch(x){control=x;}Reflect.construct(fn,[],Fake);}else {try{Fake.call();}catch(x){control=x;}fn.call(Fake.prototype);}}else {try{throw Error();}catch(x){control=x;}fn();}}catch(sample){// This is inlined manually because closure doesn't do it for us.\n\tif(sample&&control&&typeof sample.stack==='string'){// This extracts the first frame from the sample that isn't also in the control.\n\t// Skipping one frame that we assume is the frame that calls the two.\n\tvar sampleLines=sample.stack.split('\\n');var controlLines=control.stack.split('\\n');var s=sampleLines.length-1;var c=controlLines.length-1;while(s>=1&&c>=0&&sampleLines[s]!==controlLines[c]){// We expect at least one stack frame to be shared.\n\t// Typically this will be the root most one. However, stack frames may be\n\t// cut off due to maximum stack limits. In this case, one maybe cut off\n\t// earlier than the other. We assume that the sample is longer or the same\n\t// and there for cut off earlier. So we should find the root most frame in\n\t// the sample somewhere in the control.\n\tc--;}for(;s>=1&&c>=0;s--,c--){// Next we find the first one that isn't the same which should be the\n\t// frame that called our sample function and the control.\n\tif(sampleLines[s]!==controlLines[c]){// In V8, the first line is describing the message but other VMs don't.\n\t// If we're about to return the first line, and the control is also on the same\n\t// line, that's a pretty good indicator that our sample threw at same line as\n\t// the control. I.e. before we entered the sample frame. So we ignore this result.\n\t// This can happen if you passed a class to function component, or non-function.\n\tif(s!==1||c!==1){do{s--;c--;// We may still have similar intermediate frames from the construct call.\n\t// The next one that isn't the same should be our match though.\n\tif(c<0||sampleLines[s]!==controlLines[c]){// V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n\tvar _frame='\\n'+sampleLines[s].replace(' at new ',' at ');// If our component frame is labeled \"<anonymous>\"\n\t// but we have a user-provided \"displayName\"\n\t// splice it in to make the stack more readable.\n\tif(fn.displayName&&_frame.includes('<anonymous>')){_frame=_frame.replace('<anonymous>',fn.displayName);}{if(typeof fn==='function'){componentFrameCache.set(fn,_frame);}}// Return the line we found.\n\treturn _frame;}}while(s>=1&&c>=0);}break;}}}}finally{reentry=false;{ReactCurrentDispatcher.current=previousDispatcher;reenableLogs();}Error.prepareStackTrace=previousPrepareStackTrace;}// Fallback to just using the name if we couldn't make it throw.\n\tvar name=fn?fn.displayName||fn.name:'';var syntheticFrame=name?describeBuiltInComponentFrame(name):'';{if(typeof fn==='function'){componentFrameCache.set(fn,syntheticFrame);}}return syntheticFrame;}function describeClassComponentFrame(ctor,source,ownerFn){{return describeNativeComponentFrame(ctor,true);}}function describeFunctionComponentFrame(fn,source,ownerFn){{return describeNativeComponentFrame(fn,false);}}function shouldConstruct(Component){var prototype=Component.prototype;return !!(prototype&&prototype.isReactComponent);}function describeUnknownElementTypeFrameInDEV(type,source,ownerFn){if(type==null){return '';}if(typeof type==='function'){{return describeNativeComponentFrame(type,shouldConstruct(type));}}if(typeof type==='string'){return describeBuiltInComponentFrame(type);}switch(type){case REACT_SUSPENSE_TYPE:return describeBuiltInComponentFrame('Suspense');case REACT_SUSPENSE_LIST_TYPE:return describeBuiltInComponentFrame('SuspenseList');}if(typeof type==='object'){switch(type.$$typeof){case REACT_FORWARD_REF_TYPE:return describeFunctionComponentFrame(type.render);case REACT_MEMO_TYPE:// Memo may contain any component type so we recursively resolve it.\n\treturn describeUnknownElementTypeFrameInDEV(type.type,source,ownerFn);case REACT_LAZY_TYPE:{var lazyComponent=type;var payload=lazyComponent._payload;var init=lazyComponent._init;try{// Lazy may contain any component type so we recursively resolve it.\n\treturn describeUnknownElementTypeFrameInDEV(init(payload),source,ownerFn);}catch(x){}}}}return '';}function describeFiber(fiber){fiber._debugOwner?fiber._debugOwner.type:null;fiber._debugSource;switch(fiber.tag){case HostComponent:return describeBuiltInComponentFrame(fiber.type);case LazyComponent:return describeBuiltInComponentFrame('Lazy');case SuspenseComponent:return describeBuiltInComponentFrame('Suspense');case SuspenseListComponent:return describeBuiltInComponentFrame('SuspenseList');case FunctionComponent:case IndeterminateComponent:case SimpleMemoComponent:return describeFunctionComponentFrame(fiber.type);case ForwardRef:return describeFunctionComponentFrame(fiber.type.render);case ClassComponent:return describeClassComponentFrame(fiber.type);default:return '';}}function getStackByFiberInDevAndProd(workInProgress){try{var info='';var node=workInProgress;do{info+=describeFiber(node);node=node.return;}while(node);return info;}catch(x){return '\\nError generating stack: '+x.message+'\\n'+x.stack;}}function getWrappedName(outerType,innerType,wrapperName){var displayName=outerType.displayName;if(displayName){return displayName;}var functionName=innerType.displayName||innerType.name||'';return functionName!==''?wrapperName+\"(\"+functionName+\")\":wrapperName;}// Keep in sync with react-reconciler/getComponentNameFromFiber\n\tfunction getContextName(type){return type.displayName||'Context';}// Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\tfunction getComponentNameFromType(type){if(type==null){// Host root, text node or just invalid type.\n\treturn null;}{if(typeof type.tag==='number'){error('Received an unexpected object in getComponentNameFromType(). '+'This is likely a bug in React. Please file an issue.');}}if(typeof type==='function'){return type.displayName||type.name||null;}if(typeof type==='string'){return type;}switch(type){case REACT_FRAGMENT_TYPE:return 'Fragment';case REACT_PORTAL_TYPE:return 'Portal';case REACT_PROFILER_TYPE:return 'Profiler';case REACT_STRICT_MODE_TYPE:return 'StrictMode';case REACT_SUSPENSE_TYPE:return 'Suspense';case REACT_SUSPENSE_LIST_TYPE:return 'SuspenseList';}if(typeof type==='object'){switch(type.$$typeof){case REACT_CONTEXT_TYPE:var context=type;return getContextName(context)+'.Consumer';case REACT_PROVIDER_TYPE:var provider=type;return getContextName(provider._context)+'.Provider';case REACT_FORWARD_REF_TYPE:return getWrappedName(type,type.render,'ForwardRef');case REACT_MEMO_TYPE:var outerName=type.displayName||null;if(outerName!==null){return outerName;}return getComponentNameFromType(type.type)||'Memo';case REACT_LAZY_TYPE:{var lazyComponent=type;var payload=lazyComponent._payload;var init=lazyComponent._init;try{return getComponentNameFromType(init(payload));}catch(x){return null;}}// eslint-disable-next-line no-fallthrough\n\t}}return null;}function getWrappedName$1(outerType,innerType,wrapperName){var functionName=innerType.displayName||innerType.name||'';return outerType.displayName||(functionName!==''?wrapperName+\"(\"+functionName+\")\":wrapperName);}// Keep in sync with shared/getComponentNameFromType\n\tfunction getContextName$1(type){return type.displayName||'Context';}function getComponentNameFromFiber(fiber){var tag=fiber.tag,type=fiber.type;switch(tag){case CacheComponent:return 'Cache';case ContextConsumer:var context=type;return getContextName$1(context)+'.Consumer';case ContextProvider:var provider=type;return getContextName$1(provider._context)+'.Provider';case DehydratedFragment:return 'DehydratedFragment';case ForwardRef:return getWrappedName$1(type,type.render,'ForwardRef');case Fragment:return 'Fragment';case HostComponent:// Host component type is the display name (e.g. \"div\", \"View\")\n\treturn type;case HostPortal:return 'Portal';case HostRoot:return 'Root';case HostText:return 'Text';case LazyComponent:// Name comes from the type in this case; we don't have a tag.\n\treturn getComponentNameFromType(type);case Mode:if(type===REACT_STRICT_MODE_TYPE){// Don't be less specific than shared/getComponentNameFromType\n\treturn 'StrictMode';}return 'Mode';case OffscreenComponent:return 'Offscreen';case Profiler:return 'Profiler';case ScopeComponent:return 'Scope';case SuspenseComponent:return 'Suspense';case SuspenseListComponent:return 'SuspenseList';case TracingMarkerComponent:return 'TracingMarker';// The display name for this tags come from the user-provided type:\n\tcase ClassComponent:case FunctionComponent:case IncompleteClassComponent:case IndeterminateComponent:case MemoComponent:case SimpleMemoComponent:if(typeof type==='function'){return type.displayName||type.name||null;}if(typeof type==='string'){return type;}break;}return null;}var ReactDebugCurrentFrame=ReactSharedInternals.ReactDebugCurrentFrame;var current=null;var isRendering=false;function getCurrentFiberOwnerNameInDevOrNull(){{if(current===null){return null;}var owner=current._debugOwner;if(owner!==null&&typeof owner!=='undefined'){return getComponentNameFromFiber(owner);}}return null;}function getCurrentFiberStackInDev(){{if(current===null){return '';}// Safe because if current fiber exists, we are reconciling,\n\t// and it is guaranteed to be the work-in-progress version.\n\treturn getStackByFiberInDevAndProd(current);}}function resetCurrentFiber(){{ReactDebugCurrentFrame.getCurrentStack=null;current=null;isRendering=false;}}function setCurrentFiber(fiber){{ReactDebugCurrentFrame.getCurrentStack=fiber===null?null:getCurrentFiberStackInDev;current=fiber;isRendering=false;}}function getCurrentFiber(){{return current;}}function setIsRendering(rendering){{isRendering=rendering;}}// Flow does not allow string concatenation of most non-string types. To work\n\t// around this limitation, we use an opaque type that can only be obtained by\n\t// passing the value through getToStringValue first.\n\tfunction toString(value){// The coercion safety check is performed in getToStringValue().\n\t// eslint-disable-next-line react-internal/safe-string-coercion\n\treturn ''+value;}function getToStringValue(value){switch(typeof value){case'boolean':case'number':case'string':case'undefined':return value;case'object':{checkFormFieldValueStringCoercion(value);}return value;default:// function, symbol are assigned as empty strings\n\treturn '';}}var hasReadOnlyValue={button:true,checkbox:true,image:true,hidden:true,radio:true,reset:true,submit:true};function checkControlledValueProps(tagName,props){{if(!(hasReadOnlyValue[props.type]||props.onChange||props.onInput||props.readOnly||props.disabled||props.value==null)){error('You provided a `value` prop to a form field without an '+'`onChange` handler. This will render a read-only field. If '+'the field should be mutable use `defaultValue`. Otherwise, '+'set either `onChange` or `readOnly`.');}if(!(props.onChange||props.readOnly||props.disabled||props.checked==null)){error('You provided a `checked` prop to a form field without an '+'`onChange` handler. This will render a read-only field. If '+'the field should be mutable use `defaultChecked`. Otherwise, '+'set either `onChange` or `readOnly`.');}}}function isCheckable(elem){var type=elem.type;var nodeName=elem.nodeName;return nodeName&&nodeName.toLowerCase()==='input'&&(type==='checkbox'||type==='radio');}function getTracker(node){return node._valueTracker;}function detachTracker(node){node._valueTracker=null;}function getValueFromNode(node){var value='';if(!node){return value;}if(isCheckable(node)){value=node.checked?'true':'false';}else {value=node.value;}return value;}function trackValueOnNode(node){var valueField=isCheckable(node)?'checked':'value';var descriptor=Object.getOwnPropertyDescriptor(node.constructor.prototype,valueField);{checkFormFieldValueStringCoercion(node[valueField]);}var currentValue=''+node[valueField];// if someone has already defined a value or Safari, then bail\n\t// and don't track value will cause over reporting of changes,\n\t// but it's better then a hard failure\n\t// (needed for certain tests that spyOn input values and Safari)\n\tif(node.hasOwnProperty(valueField)||typeof descriptor==='undefined'||typeof descriptor.get!=='function'||typeof descriptor.set!=='function'){return;}var get=descriptor.get,set=descriptor.set;Object.defineProperty(node,valueField,{configurable:true,get:function(){return get.call(this);},set:function(value){{checkFormFieldValueStringCoercion(value);}currentValue=''+value;set.call(this,value);}});// We could've passed this the first time\n\t// but it triggers a bug in IE11 and Edge 14/15.\n\t// Calling defineProperty() again should be equivalent.\n\t// https://github.com/facebook/react/issues/11768\n\tObject.defineProperty(node,valueField,{enumerable:descriptor.enumerable});var tracker={getValue:function(){return currentValue;},setValue:function(value){{checkFormFieldValueStringCoercion(value);}currentValue=''+value;},stopTracking:function(){detachTracker(node);delete node[valueField];}};return tracker;}function track(node){if(getTracker(node)){return;}// TODO: Once it's just Fiber we can move this to node._wrapperState\n\tnode._valueTracker=trackValueOnNode(node);}function updateValueIfChanged(node){if(!node){return false;}var tracker=getTracker(node);// if there is no tracker at this point it's unlikely\n\t// that trying again will succeed\n\tif(!tracker){return true;}var lastValue=tracker.getValue();var nextValue=getValueFromNode(node);if(nextValue!==lastValue){tracker.setValue(nextValue);return true;}return false;}function getActiveElement(doc){doc=doc||(typeof document!=='undefined'?document:undefined);if(typeof doc==='undefined'){return null;}try{return doc.activeElement||doc.body;}catch(e){return doc.body;}}var didWarnValueDefaultValue=false;var didWarnCheckedDefaultChecked=false;var didWarnControlledToUncontrolled=false;var didWarnUncontrolledToControlled=false;function isControlled(props){var usesChecked=props.type==='checkbox'||props.type==='radio';return usesChecked?props.checked!=null:props.value!=null;}/**\n\t * Implements an <input> host component that allows setting these optional\n\t * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.\n\t *\n\t * If `checked` or `value` are not supplied (or null/undefined), user actions\n\t * that affect the checked state or value will trigger updates to the element.\n\t *\n\t * If they are supplied (and not null/undefined), the rendered element will not\n\t * trigger updates to the element. Instead, the props must change in order for\n\t * the rendered element to be updated.\n\t *\n\t * The rendered element will be initialized as unchecked (or `defaultChecked`)\n\t * with an empty value (or `defaultValue`).\n\t *\n\t * See http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html\n\t */function getHostProps(element,props){var node=element;var checked=props.checked;var hostProps=assign({},props,{defaultChecked:undefined,defaultValue:undefined,value:undefined,checked:checked!=null?checked:node._wrapperState.initialChecked});return hostProps;}function initWrapperState(element,props){{checkControlledValueProps('input',props);if(props.checked!==undefined&&props.defaultChecked!==undefined&&!didWarnCheckedDefaultChecked){error('%s contains an input of type %s with both checked and defaultChecked props. '+'Input elements must be either controlled or uncontrolled '+'(specify either the checked prop, or the defaultChecked prop, but not '+'both). Decide between using a controlled or uncontrolled input '+'element and remove one of these props. More info: '+'https://reactjs.org/link/controlled-components',getCurrentFiberOwnerNameInDevOrNull()||'A component',props.type);didWarnCheckedDefaultChecked=true;}if(props.value!==undefined&&props.defaultValue!==undefined&&!didWarnValueDefaultValue){error('%s contains an input of type %s with both value and defaultValue props. '+'Input elements must be either controlled or uncontrolled '+'(specify either the value prop, or the defaultValue prop, but not '+'both). Decide between using a controlled or uncontrolled input '+'element and remove one of these props. More info: '+'https://reactjs.org/link/controlled-components',getCurrentFiberOwnerNameInDevOrNull()||'A component',props.type);didWarnValueDefaultValue=true;}}var node=element;var defaultValue=props.defaultValue==null?'':props.defaultValue;node._wrapperState={initialChecked:props.checked!=null?props.checked:props.defaultChecked,initialValue:getToStringValue(props.value!=null?props.value:defaultValue),controlled:isControlled(props)};}function updateChecked(element,props){var node=element;var checked=props.checked;if(checked!=null){setValueForProperty(node,'checked',checked,false);}}function updateWrapper(element,props){var node=element;{var controlled=isControlled(props);if(!node._wrapperState.controlled&&controlled&&!didWarnUncontrolledToControlled){error('A component is changing an uncontrolled input to be controlled. '+'This is likely caused by the value changing from undefined to '+'a defined value, which should not happen. '+'Decide between using a controlled or uncontrolled input '+'element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components');didWarnUncontrolledToControlled=true;}if(node._wrapperState.controlled&&!controlled&&!didWarnControlledToUncontrolled){error('A component is changing a controlled input to be uncontrolled. '+'This is likely caused by the value changing from a defined to '+'undefined, which should not happen. '+'Decide between using a controlled or uncontrolled input '+'element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components');didWarnControlledToUncontrolled=true;}}updateChecked(element,props);var value=getToStringValue(props.value);var type=props.type;if(value!=null){if(type==='number'){if(value===0&&node.value===''||// We explicitly want to coerce to number here if possible.\n\t// eslint-disable-next-line\n\tnode.value!=value){node.value=toString(value);}}else if(node.value!==toString(value)){node.value=toString(value);}}else if(type==='submit'||type==='reset'){// Submit/reset inputs need the attribute removed completely to avoid\n\t// blank-text buttons.\n\tnode.removeAttribute('value');return;}{// When syncing the value attribute, the value comes from a cascade of\n\t// properties:\n\t//  1. The value React property\n\t//  2. The defaultValue React property\n\t//  3. Otherwise there should be no change\n\tif(props.hasOwnProperty('value')){setDefaultValue(node,props.type,value);}else if(props.hasOwnProperty('defaultValue')){setDefaultValue(node,props.type,getToStringValue(props.defaultValue));}}{// When syncing the checked attribute, it only changes when it needs\n\t// to be removed, such as transitioning from a checkbox into a text input\n\tif(props.checked==null&&props.defaultChecked!=null){node.defaultChecked=!!props.defaultChecked;}}}function postMountWrapper(element,props,isHydrating){var node=element;// Do not assign value if it is already set. This prevents user text input\n\t// from being lost during SSR hydration.\n\tif(props.hasOwnProperty('value')||props.hasOwnProperty('defaultValue')){var type=props.type;var isButton=type==='submit'||type==='reset';// Avoid setting value attribute on submit/reset inputs as it overrides the\n\t// default value provided by the browser. See: #12872\n\tif(isButton&&(props.value===undefined||props.value===null)){return;}var initialValue=toString(node._wrapperState.initialValue);// Do not assign value if it is already set. This prevents user text input\n\t// from being lost during SSR hydration.\n\tif(!isHydrating){{// When syncing the value attribute, the value property should use\n\t// the wrapperState._initialValue property. This uses:\n\t//\n\t//   1. The value React property when present\n\t//   2. The defaultValue React property when present\n\t//   3. An empty string\n\tif(initialValue!==node.value){node.value=initialValue;}}}{// Otherwise, the value attribute is synchronized to the property,\n\t// so we assign defaultValue to the same thing as the value property\n\t// assignment step above.\n\tnode.defaultValue=initialValue;}}// Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug\n\t// this is needed to work around a chrome bug where setting defaultChecked\n\t// will sometimes influence the value of checked (even after detachment).\n\t// Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416\n\t// We need to temporarily unset name to avoid disrupting radio button groups.\n\tvar name=node.name;if(name!==''){node.name='';}{// When syncing the checked attribute, both the checked property and\n\t// attribute are assigned at the same time using defaultChecked. This uses:\n\t//\n\t//   1. The checked React property when present\n\t//   2. The defaultChecked React property when present\n\t//   3. Otherwise, false\n\tnode.defaultChecked=!node.defaultChecked;node.defaultChecked=!!node._wrapperState.initialChecked;}if(name!==''){node.name=name;}}function restoreControlledState(element,props){var node=element;updateWrapper(node,props);updateNamedCousins(node,props);}function updateNamedCousins(rootNode,props){var name=props.name;if(props.type==='radio'&&name!=null){var queryRoot=rootNode;while(queryRoot.parentNode){queryRoot=queryRoot.parentNode;}// If `rootNode.form` was non-null, then we could try `form.elements`,\n\t// but that sometimes behaves strangely in IE8. We could also try using\n\t// `form.getElementsByName`, but that will only return direct children\n\t// and won't include inputs that use the HTML5 `form=` attribute. Since\n\t// the input might not even be in a form. It might not even be in the\n\t// document. Let's just use the local `querySelectorAll` to ensure we don't\n\t// miss anything.\n\t{checkAttributeStringCoercion(name,'name');}var group=queryRoot.querySelectorAll('input[name='+JSON.stringify(''+name)+'][type=\"radio\"]');for(var i=0;i<group.length;i++){var otherNode=group[i];if(otherNode===rootNode||otherNode.form!==rootNode.form){continue;}// This will throw if radio buttons rendered by different copies of React\n\t// and the same name are rendered into the same form (same as #1939).\n\t// That's probably okay; we don't support it just as we don't support\n\t// mixing React radio buttons with non-React ones.\n\tvar otherProps=getFiberCurrentPropsFromNode(otherNode);if(!otherProps){throw new Error('ReactDOMInput: Mixing React and non-React radio inputs with the '+'same `name` is not supported.');}// We need update the tracked value on the named cousin since the value\n\t// was changed but the input saw no event or value set\n\tupdateValueIfChanged(otherNode);// If this is a controlled radio button group, forcing the input that\n\t// was previously checked to update will cause it to be come re-checked\n\t// as appropriate.\n\tupdateWrapper(otherNode,otherProps);}}}// In Chrome, assigning defaultValue to certain input types triggers input validation.\n\t// For number inputs, the display value loses trailing decimal points. For email inputs,\n\t// Chrome raises \"The specified value <x> is not a valid email address\".\n\t//\n\t// Here we check to see if the defaultValue has actually changed, avoiding these problems\n\t// when the user is inputting text\n\t//\n\t// https://github.com/facebook/react/issues/7253\n\tfunction setDefaultValue(node,type,value){if(// Focused number inputs synchronize on blur. See ChangeEventPlugin.js\n\ttype!=='number'||getActiveElement(node.ownerDocument)!==node){if(value==null){node.defaultValue=toString(node._wrapperState.initialValue);}else if(node.defaultValue!==toString(value)){node.defaultValue=toString(value);}}}var didWarnSelectedSetOnOption=false;var didWarnInvalidChild=false;var didWarnInvalidInnerHTML=false;/**\n\t * Implements an <option> host component that warns when `selected` is set.\n\t */function validateProps(element,props){{// If a value is not provided, then the children must be simple.\n\tif(props.value==null){if(typeof props.children==='object'&&props.children!==null){React.Children.forEach(props.children,function(child){if(child==null){return;}if(typeof child==='string'||typeof child==='number'){return;}if(!didWarnInvalidChild){didWarnInvalidChild=true;error('Cannot infer the option value of complex children. '+'Pass a `value` prop or use a plain string as children to <option>.');}});}else if(props.dangerouslySetInnerHTML!=null){if(!didWarnInvalidInnerHTML){didWarnInvalidInnerHTML=true;error('Pass a `value` prop if you set dangerouslyInnerHTML so React knows '+'which value should be selected.');}}}// TODO: Remove support for `selected` in <option>.\n\tif(props.selected!=null&&!didWarnSelectedSetOnOption){error('Use the `defaultValue` or `value` props on <select> instead of '+'setting `selected` on <option>.');didWarnSelectedSetOnOption=true;}}}function postMountWrapper$1(element,props){// value=\"\" should make a value attribute (#6219)\n\tif(props.value!=null){element.setAttribute('value',toString(getToStringValue(props.value)));}}var isArrayImpl=Array.isArray;// eslint-disable-next-line no-redeclare\n\tfunction isArray(a){return isArrayImpl(a);}var didWarnValueDefaultValue$1;{didWarnValueDefaultValue$1=false;}function getDeclarationErrorAddendum(){var ownerName=getCurrentFiberOwnerNameInDevOrNull();if(ownerName){return '\\n\\nCheck the render method of `'+ownerName+'`.';}return '';}var valuePropNames=['value','defaultValue'];/**\n\t * Validation function for `value` and `defaultValue`.\n\t */function checkSelectPropTypes(props){{checkControlledValueProps('select',props);for(var i=0;i<valuePropNames.length;i++){var propName=valuePropNames[i];if(props[propName]==null){continue;}var propNameIsArray=isArray(props[propName]);if(props.multiple&&!propNameIsArray){error('The `%s` prop supplied to <select> must be an array if '+'`multiple` is true.%s',propName,getDeclarationErrorAddendum());}else if(!props.multiple&&propNameIsArray){error('The `%s` prop supplied to <select> must be a scalar '+'value if `multiple` is false.%s',propName,getDeclarationErrorAddendum());}}}}function updateOptions(node,multiple,propValue,setDefaultSelected){var options=node.options;if(multiple){var selectedValues=propValue;var selectedValue={};for(var i=0;i<selectedValues.length;i++){// Prefix to avoid chaos with special keys.\n\tselectedValue['$'+selectedValues[i]]=true;}for(var _i=0;_i<options.length;_i++){var selected=selectedValue.hasOwnProperty('$'+options[_i].value);if(options[_i].selected!==selected){options[_i].selected=selected;}if(selected&&setDefaultSelected){options[_i].defaultSelected=true;}}}else {// Do not set `select.value` as exact behavior isn't consistent across all\n\t// browsers for all cases.\n\tvar _selectedValue=toString(getToStringValue(propValue));var defaultSelected=null;for(var _i2=0;_i2<options.length;_i2++){if(options[_i2].value===_selectedValue){options[_i2].selected=true;if(setDefaultSelected){options[_i2].defaultSelected=true;}return;}if(defaultSelected===null&&!options[_i2].disabled){defaultSelected=options[_i2];}}if(defaultSelected!==null){defaultSelected.selected=true;}}}/**\n\t * Implements a <select> host component that allows optionally setting the\n\t * props `value` and `defaultValue`. If `multiple` is false, the prop must be a\n\t * stringable. If `multiple` is true, the prop must be an array of stringables.\n\t *\n\t * If `value` is not supplied (or null/undefined), user actions that change the\n\t * selected option will trigger updates to the rendered options.\n\t *\n\t * If it is supplied (and not null/undefined), the rendered options will not\n\t * update in response to user actions. Instead, the `value` prop must change in\n\t * order for the rendered options to update.\n\t *\n\t * If `defaultValue` is provided, any options with the supplied values will be\n\t * selected.\n\t */function getHostProps$1(element,props){return assign({},props,{value:undefined});}function initWrapperState$1(element,props){var node=element;{checkSelectPropTypes(props);}node._wrapperState={wasMultiple:!!props.multiple};{if(props.value!==undefined&&props.defaultValue!==undefined&&!didWarnValueDefaultValue$1){error('Select elements must be either controlled or uncontrolled '+'(specify either the value prop, or the defaultValue prop, but not '+'both). Decide between using a controlled or uncontrolled select '+'element and remove one of these props. More info: '+'https://reactjs.org/link/controlled-components');didWarnValueDefaultValue$1=true;}}}function postMountWrapper$2(element,props){var node=element;node.multiple=!!props.multiple;var value=props.value;if(value!=null){updateOptions(node,!!props.multiple,value,false);}else if(props.defaultValue!=null){updateOptions(node,!!props.multiple,props.defaultValue,true);}}function postUpdateWrapper(element,props){var node=element;var wasMultiple=node._wrapperState.wasMultiple;node._wrapperState.wasMultiple=!!props.multiple;var value=props.value;if(value!=null){updateOptions(node,!!props.multiple,value,false);}else if(wasMultiple!==!!props.multiple){// For simplicity, reapply `defaultValue` if `multiple` is toggled.\n\tif(props.defaultValue!=null){updateOptions(node,!!props.multiple,props.defaultValue,true);}else {// Revert the select back to its default unselected state.\n\tupdateOptions(node,!!props.multiple,props.multiple?[]:'',false);}}}function restoreControlledState$1(element,props){var node=element;var value=props.value;if(value!=null){updateOptions(node,!!props.multiple,value,false);}}var didWarnValDefaultVal=false;/**\n\t * Implements a <textarea> host component that allows setting `value`, and\n\t * `defaultValue`. This differs from the traditional DOM API because value is\n\t * usually set as PCDATA children.\n\t *\n\t * If `value` is not supplied (or null/undefined), user actions that affect the\n\t * value will trigger updates to the element.\n\t *\n\t * If `value` is supplied (and not null/undefined), the rendered element will\n\t * not trigger updates to the element. Instead, the `value` prop must change in\n\t * order for the rendered element to be updated.\n\t *\n\t * The rendered element will be initialized with an empty value, the prop\n\t * `defaultValue` if specified, or the children content (deprecated).\n\t */function getHostProps$2(element,props){var node=element;if(props.dangerouslySetInnerHTML!=null){throw new Error('`dangerouslySetInnerHTML` does not make sense on <textarea>.');}// Always set children to the same thing. In IE9, the selection range will\n\t// get reset if `textContent` is mutated.  We could add a check in setTextContent\n\t// to only set the value if/when the value differs from the node value (which would\n\t// completely solve this IE9 bug), but Sebastian+Sophie seemed to like this\n\t// solution. The value can be a boolean or object so that's why it's forced\n\t// to be a string.\n\tvar hostProps=assign({},props,{value:undefined,defaultValue:undefined,children:toString(node._wrapperState.initialValue)});return hostProps;}function initWrapperState$2(element,props){var node=element;{checkControlledValueProps('textarea',props);if(props.value!==undefined&&props.defaultValue!==undefined&&!didWarnValDefaultVal){error('%s contains a textarea with both value and defaultValue props. '+'Textarea elements must be either controlled or uncontrolled '+'(specify either the value prop, or the defaultValue prop, but not '+'both). Decide between using a controlled or uncontrolled textarea '+'and remove one of these props. More info: '+'https://reactjs.org/link/controlled-components',getCurrentFiberOwnerNameInDevOrNull()||'A component');didWarnValDefaultVal=true;}}var initialValue=props.value;// Only bother fetching default value if we're going to use it\n\tif(initialValue==null){var children=props.children,defaultValue=props.defaultValue;if(children!=null){{error('Use the `defaultValue` or `value` props instead of setting '+'children on <textarea>.');}{if(defaultValue!=null){throw new Error('If you supply `defaultValue` on a <textarea>, do not pass children.');}if(isArray(children)){if(children.length>1){throw new Error('<textarea> can only have at most one child.');}children=children[0];}defaultValue=children;}}if(defaultValue==null){defaultValue='';}initialValue=defaultValue;}node._wrapperState={initialValue:getToStringValue(initialValue)};}function updateWrapper$1(element,props){var node=element;var value=getToStringValue(props.value);var defaultValue=getToStringValue(props.defaultValue);if(value!=null){// Cast `value` to a string to ensure the value is set correctly. While\n\t// browsers typically do this as necessary, jsdom doesn't.\n\tvar newValue=toString(value);// To avoid side effects (such as losing text selection), only set value if changed\n\tif(newValue!==node.value){node.value=newValue;}if(props.defaultValue==null&&node.defaultValue!==newValue){node.defaultValue=newValue;}}if(defaultValue!=null){node.defaultValue=toString(defaultValue);}}function postMountWrapper$3(element,props){var node=element;// This is in postMount because we need access to the DOM node, which is not\n\t// available until after the component has mounted.\n\tvar textContent=node.textContent;// Only set node.value if textContent is equal to the expected\n\t// initial value. In IE10/IE11 there is a bug where the placeholder attribute\n\t// will populate textContent as well.\n\t// https://developer.microsoft.com/microsoft-edge/platform/issues/101525/\n\tif(textContent===node._wrapperState.initialValue){if(textContent!==''&&textContent!==null){node.value=textContent;}}}function restoreControlledState$2(element,props){// DOM component is still mounted; update\n\tupdateWrapper$1(element,props);}var HTML_NAMESPACE='http://www.w3.org/1999/xhtml';var MATH_NAMESPACE='http://www.w3.org/1998/Math/MathML';var SVG_NAMESPACE='http://www.w3.org/2000/svg';// Assumes there is no parent namespace.\n\tfunction getIntrinsicNamespace(type){switch(type){case'svg':return SVG_NAMESPACE;case'math':return MATH_NAMESPACE;default:return HTML_NAMESPACE;}}function getChildNamespace(parentNamespace,type){if(parentNamespace==null||parentNamespace===HTML_NAMESPACE){// No (or default) parent namespace: potential entry point.\n\treturn getIntrinsicNamespace(type);}if(parentNamespace===SVG_NAMESPACE&&type==='foreignObject'){// We're leaving SVG.\n\treturn HTML_NAMESPACE;}// By default, pass namespace below.\n\treturn parentNamespace;}/* globals MSApp */ /**\n\t * Create a function which has 'unsafe' privileges (required by windows8 apps)\n\t */var createMicrosoftUnsafeLocalFunction=function(func){if(typeof MSApp!=='undefined'&&MSApp.execUnsafeLocalFunction){return function(arg0,arg1,arg2,arg3){MSApp.execUnsafeLocalFunction(function(){return func(arg0,arg1,arg2,arg3);});};}else {return func;}};var reusableSVGContainer;/**\n\t * Set the innerHTML property of a node\n\t *\n\t * @param {DOMElement} node\n\t * @param {string} html\n\t * @internal\n\t */var setInnerHTML=createMicrosoftUnsafeLocalFunction(function(node,html){if(node.namespaceURI===SVG_NAMESPACE){if(!('innerHTML'in node)){// IE does not have innerHTML for SVG nodes, so instead we inject the\n\t// new markup in a temp node and then move the child nodes across into\n\t// the target node\n\treusableSVGContainer=reusableSVGContainer||document.createElement('div');reusableSVGContainer.innerHTML='<svg>'+html.valueOf().toString()+'</svg>';var svgNode=reusableSVGContainer.firstChild;while(node.firstChild){node.removeChild(node.firstChild);}while(svgNode.firstChild){node.appendChild(svgNode.firstChild);}return;}}node.innerHTML=html;});/**\n\t * HTML nodeType values that represent the type of the node\n\t */var ELEMENT_NODE=1;var TEXT_NODE=3;var COMMENT_NODE=8;var DOCUMENT_NODE=9;var DOCUMENT_FRAGMENT_NODE=11;/**\n\t * Set the textContent property of a node. For text updates, it's faster\n\t * to set the `nodeValue` of the Text node directly instead of using\n\t * `.textContent` which will remove the existing node and create a new one.\n\t *\n\t * @param {DOMElement} node\n\t * @param {string} text\n\t * @internal\n\t */var setTextContent=function(node,text){if(text){var firstChild=node.firstChild;if(firstChild&&firstChild===node.lastChild&&firstChild.nodeType===TEXT_NODE){firstChild.nodeValue=text;return;}}node.textContent=text;};// List derived from Gecko source code:\n\t// https://github.com/mozilla/gecko-dev/blob/4e638efc71/layout/style/test/property_database.js\n\tvar shorthandToLonghand={animation:['animationDelay','animationDirection','animationDuration','animationFillMode','animationIterationCount','animationName','animationPlayState','animationTimingFunction'],background:['backgroundAttachment','backgroundClip','backgroundColor','backgroundImage','backgroundOrigin','backgroundPositionX','backgroundPositionY','backgroundRepeat','backgroundSize'],backgroundPosition:['backgroundPositionX','backgroundPositionY'],border:['borderBottomColor','borderBottomStyle','borderBottomWidth','borderImageOutset','borderImageRepeat','borderImageSlice','borderImageSource','borderImageWidth','borderLeftColor','borderLeftStyle','borderLeftWidth','borderRightColor','borderRightStyle','borderRightWidth','borderTopColor','borderTopStyle','borderTopWidth'],borderBlockEnd:['borderBlockEndColor','borderBlockEndStyle','borderBlockEndWidth'],borderBlockStart:['borderBlockStartColor','borderBlockStartStyle','borderBlockStartWidth'],borderBottom:['borderBottomColor','borderBottomStyle','borderBottomWidth'],borderColor:['borderBottomColor','borderLeftColor','borderRightColor','borderTopColor'],borderImage:['borderImageOutset','borderImageRepeat','borderImageSlice','borderImageSource','borderImageWidth'],borderInlineEnd:['borderInlineEndColor','borderInlineEndStyle','borderInlineEndWidth'],borderInlineStart:['borderInlineStartColor','borderInlineStartStyle','borderInlineStartWidth'],borderLeft:['borderLeftColor','borderLeftStyle','borderLeftWidth'],borderRadius:['borderBottomLeftRadius','borderBottomRightRadius','borderTopLeftRadius','borderTopRightRadius'],borderRight:['borderRightColor','borderRightStyle','borderRightWidth'],borderStyle:['borderBottomStyle','borderLeftStyle','borderRightStyle','borderTopStyle'],borderTop:['borderTopColor','borderTopStyle','borderTopWidth'],borderWidth:['borderBottomWidth','borderLeftWidth','borderRightWidth','borderTopWidth'],columnRule:['columnRuleColor','columnRuleStyle','columnRuleWidth'],columns:['columnCount','columnWidth'],flex:['flexBasis','flexGrow','flexShrink'],flexFlow:['flexDirection','flexWrap'],font:['fontFamily','fontFeatureSettings','fontKerning','fontLanguageOverride','fontSize','fontSizeAdjust','fontStretch','fontStyle','fontVariant','fontVariantAlternates','fontVariantCaps','fontVariantEastAsian','fontVariantLigatures','fontVariantNumeric','fontVariantPosition','fontWeight','lineHeight'],fontVariant:['fontVariantAlternates','fontVariantCaps','fontVariantEastAsian','fontVariantLigatures','fontVariantNumeric','fontVariantPosition'],gap:['columnGap','rowGap'],grid:['gridAutoColumns','gridAutoFlow','gridAutoRows','gridTemplateAreas','gridTemplateColumns','gridTemplateRows'],gridArea:['gridColumnEnd','gridColumnStart','gridRowEnd','gridRowStart'],gridColumn:['gridColumnEnd','gridColumnStart'],gridColumnGap:['columnGap'],gridGap:['columnGap','rowGap'],gridRow:['gridRowEnd','gridRowStart'],gridRowGap:['rowGap'],gridTemplate:['gridTemplateAreas','gridTemplateColumns','gridTemplateRows'],listStyle:['listStyleImage','listStylePosition','listStyleType'],margin:['marginBottom','marginLeft','marginRight','marginTop'],marker:['markerEnd','markerMid','markerStart'],mask:['maskClip','maskComposite','maskImage','maskMode','maskOrigin','maskPositionX','maskPositionY','maskRepeat','maskSize'],maskPosition:['maskPositionX','maskPositionY'],outline:['outlineColor','outlineStyle','outlineWidth'],overflow:['overflowX','overflowY'],padding:['paddingBottom','paddingLeft','paddingRight','paddingTop'],placeContent:['alignContent','justifyContent'],placeItems:['alignItems','justifyItems'],placeSelf:['alignSelf','justifySelf'],textDecoration:['textDecorationColor','textDecorationLine','textDecorationStyle'],textEmphasis:['textEmphasisColor','textEmphasisStyle'],transition:['transitionDelay','transitionDuration','transitionProperty','transitionTimingFunction'],wordWrap:['overflowWrap']};/**\n\t * CSS properties which accept numbers but are not in units of \"px\".\n\t */var isUnitlessNumber={animationIterationCount:true,aspectRatio:true,borderImageOutset:true,borderImageSlice:true,borderImageWidth:true,boxFlex:true,boxFlexGroup:true,boxOrdinalGroup:true,columnCount:true,columns:true,flex:true,flexGrow:true,flexPositive:true,flexShrink:true,flexNegative:true,flexOrder:true,gridArea:true,gridRow:true,gridRowEnd:true,gridRowSpan:true,gridRowStart:true,gridColumn:true,gridColumnEnd:true,gridColumnSpan:true,gridColumnStart:true,fontWeight:true,lineClamp:true,lineHeight:true,opacity:true,order:true,orphans:true,tabSize:true,widows:true,zIndex:true,zoom:true,// SVG-related properties\n\tfillOpacity:true,floodOpacity:true,stopOpacity:true,strokeDasharray:true,strokeDashoffset:true,strokeMiterlimit:true,strokeOpacity:true,strokeWidth:true};/**\n\t * @param {string} prefix vendor-specific prefix, eg: Webkit\n\t * @param {string} key style name, eg: transitionDuration\n\t * @return {string} style name prefixed with `prefix`, properly camelCased, eg:\n\t * WebkitTransitionDuration\n\t */function prefixKey(prefix,key){return prefix+key.charAt(0).toUpperCase()+key.substring(1);}/**\n\t * Support style names that may come passed in prefixed by adding permutations\n\t * of vendor prefixes.\n\t */var prefixes=['Webkit','ms','Moz','O'];// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an\n\t// infinite loop, because it iterates over the newly added props too.\n\tObject.keys(isUnitlessNumber).forEach(function(prop){prefixes.forEach(function(prefix){isUnitlessNumber[prefixKey(prefix,prop)]=isUnitlessNumber[prop];});});/**\n\t * Convert a value into the proper css writable value. The style name `name`\n\t * should be logical (no hyphens), as specified\n\t * in `CSSProperty.isUnitlessNumber`.\n\t *\n\t * @param {string} name CSS property name such as `topMargin`.\n\t * @param {*} value CSS property value such as `10px`.\n\t * @return {string} Normalized style value with dimensions applied.\n\t */function dangerousStyleValue(name,value,isCustomProperty){// Note that we've removed escapeTextForBrowser() calls here since the\n\t// whole string will be escaped when the attribute is injected into\n\t// the markup. If you provide unsafe user data here they can inject\n\t// arbitrary CSS which may be problematic (I couldn't repro this):\n\t// https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet\n\t// http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/\n\t// This is not an XSS hole but instead a potential CSS injection issue\n\t// which has lead to a greater discussion about how we're going to\n\t// trust URLs moving forward. See #2115901\n\tvar isEmpty=value==null||typeof value==='boolean'||value==='';if(isEmpty){return '';}if(!isCustomProperty&&typeof value==='number'&&value!==0&&!(isUnitlessNumber.hasOwnProperty(name)&&isUnitlessNumber[name])){return value+'px';// Presumes implicit 'px' suffix for unitless numbers\n\t}{checkCSSPropertyStringCoercion(value,name);}return (''+value).trim();}var uppercasePattern=/([A-Z])/g;var msPattern=/^ms-/;/**\n\t * Hyphenates a camelcased CSS property name, for example:\n\t *\n\t *   > hyphenateStyleName('backgroundColor')\n\t *   < \"background-color\"\n\t *   > hyphenateStyleName('MozTransition')\n\t *   < \"-moz-transition\"\n\t *   > hyphenateStyleName('msTransition')\n\t *   < \"-ms-transition\"\n\t *\n\t * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix\n\t * is converted to `-ms-`.\n\t */function hyphenateStyleName(name){return name.replace(uppercasePattern,'-$1').toLowerCase().replace(msPattern,'-ms-');}var warnValidStyle=function(){};{// 'msTransform' is correct, but the other prefixes should be capitalized\n\tvar badVendoredStyleNamePattern=/^(?:webkit|moz|o)[A-Z]/;var msPattern$1=/^-ms-/;var hyphenPattern=/-(.)/g;// style values shouldn't contain a semicolon\n\tvar badStyleValueWithSemicolonPattern=/;\\s*$/;var warnedStyleNames={};var warnedStyleValues={};var warnedForNaNValue=false;var warnedForInfinityValue=false;var camelize=function(string){return string.replace(hyphenPattern,function(_,character){return character.toUpperCase();});};var warnHyphenatedStyleName=function(name){if(warnedStyleNames.hasOwnProperty(name)&&warnedStyleNames[name]){return;}warnedStyleNames[name]=true;error('Unsupported style property %s. Did you mean %s?',name,// As Andi Smith suggests\n\t// (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix\n\t// is converted to lowercase `ms`.\n\tcamelize(name.replace(msPattern$1,'ms-')));};var warnBadVendoredStyleName=function(name){if(warnedStyleNames.hasOwnProperty(name)&&warnedStyleNames[name]){return;}warnedStyleNames[name]=true;error('Unsupported vendor-prefixed style property %s. Did you mean %s?',name,name.charAt(0).toUpperCase()+name.slice(1));};var warnStyleValueWithSemicolon=function(name,value){if(warnedStyleValues.hasOwnProperty(value)&&warnedStyleValues[value]){return;}warnedStyleValues[value]=true;error(\"Style property values shouldn't contain a semicolon. \"+'Try \"%s: %s\" instead.',name,value.replace(badStyleValueWithSemicolonPattern,''));};var warnStyleValueIsNaN=function(name,value){if(warnedForNaNValue){return;}warnedForNaNValue=true;error('`NaN` is an invalid value for the `%s` css style property.',name);};var warnStyleValueIsInfinity=function(name,value){if(warnedForInfinityValue){return;}warnedForInfinityValue=true;error('`Infinity` is an invalid value for the `%s` css style property.',name);};warnValidStyle=function(name,value){if(name.indexOf('-')>-1){warnHyphenatedStyleName(name);}else if(badVendoredStyleNamePattern.test(name)){warnBadVendoredStyleName(name);}else if(badStyleValueWithSemicolonPattern.test(value)){warnStyleValueWithSemicolon(name,value);}if(typeof value==='number'){if(isNaN(value)){warnStyleValueIsNaN(name,value);}else if(!isFinite(value)){warnStyleValueIsInfinity(name,value);}}};}var warnValidStyle$1=warnValidStyle;/**\n\t * Operations for dealing with CSS properties.\n\t */ /**\n\t * This creates a string that is expected to be equivalent to the style\n\t * attribute generated by server-side rendering. It by-passes warnings and\n\t * security checks so it's not safe to use this value for anything other than\n\t * comparison. It is only used in DEV for SSR validation.\n\t */function createDangerousStringForStyles(styles){{var serialized='';var delimiter='';for(var styleName in styles){if(!styles.hasOwnProperty(styleName)){continue;}var styleValue=styles[styleName];if(styleValue!=null){var isCustomProperty=styleName.indexOf('--')===0;serialized+=delimiter+(isCustomProperty?styleName:hyphenateStyleName(styleName))+':';serialized+=dangerousStyleValue(styleName,styleValue,isCustomProperty);delimiter=';';}}return serialized||null;}}/**\n\t * Sets the value for multiple styles on a node.  If a value is specified as\n\t * '' (empty string), the corresponding style property will be unset.\n\t *\n\t * @param {DOMElement} node\n\t * @param {object} styles\n\t */function setValueForStyles(node,styles){var style=node.style;for(var styleName in styles){if(!styles.hasOwnProperty(styleName)){continue;}var isCustomProperty=styleName.indexOf('--')===0;{if(!isCustomProperty){warnValidStyle$1(styleName,styles[styleName]);}}var styleValue=dangerousStyleValue(styleName,styles[styleName],isCustomProperty);if(styleName==='float'){styleName='cssFloat';}if(isCustomProperty){style.setProperty(styleName,styleValue);}else {style[styleName]=styleValue;}}}function isValueEmpty(value){return value==null||typeof value==='boolean'||value==='';}/**\n\t * Given {color: 'red', overflow: 'hidden'} returns {\n\t *   color: 'color',\n\t *   overflowX: 'overflow',\n\t *   overflowY: 'overflow',\n\t * }. This can be read as \"the overflowY property was set by the overflow\n\t * shorthand\". That is, the values are the property that each was derived from.\n\t */function expandShorthandMap(styles){var expanded={};for(var key in styles){var longhands=shorthandToLonghand[key]||[key];for(var i=0;i<longhands.length;i++){expanded[longhands[i]]=key;}}return expanded;}/**\n\t * When mixing shorthand and longhand property names, we warn during updates if\n\t * we expect an incorrect result to occur. In particular, we warn for:\n\t *\n\t * Updating a shorthand property (longhand gets overwritten):\n\t *   {font: 'foo', fontVariant: 'bar'} -> {font: 'baz', fontVariant: 'bar'}\n\t *   becomes .style.font = 'baz'\n\t * Removing a shorthand property (longhand gets lost too):\n\t *   {font: 'foo', fontVariant: 'bar'} -> {fontVariant: 'bar'}\n\t *   becomes .style.font = ''\n\t * Removing a longhand property (should revert to shorthand; doesn't):\n\t *   {font: 'foo', fontVariant: 'bar'} -> {font: 'foo'}\n\t *   becomes .style.fontVariant = ''\n\t */function validateShorthandPropertyCollisionInDev(styleUpdates,nextStyles){{if(!nextStyles){return;}var expandedUpdates=expandShorthandMap(styleUpdates);var expandedStyles=expandShorthandMap(nextStyles);var warnedAbout={};for(var key in expandedUpdates){var originalKey=expandedUpdates[key];var correctOriginalKey=expandedStyles[key];if(correctOriginalKey&&originalKey!==correctOriginalKey){var warningKey=originalKey+','+correctOriginalKey;if(warnedAbout[warningKey]){continue;}warnedAbout[warningKey]=true;error('%s a style property during rerender (%s) when a '+'conflicting property is set (%s) can lead to styling bugs. To '+\"avoid this, don't mix shorthand and non-shorthand properties \"+'for the same value; instead, replace the shorthand with '+'separate values.',isValueEmpty(styleUpdates[originalKey])?'Removing':'Updating',originalKey,correctOriginalKey);}}}}// For HTML, certain tags should omit their close tag. We keep a list for\n\t// those special-case tags.\n\tvar omittedCloseTags={area:true,base:true,br:true,col:true,embed:true,hr:true,img:true,input:true,keygen:true,link:true,meta:true,param:true,source:true,track:true,wbr:true// NOTE: menuitem's close tag should be omitted, but that causes problems.\n\t};// `omittedCloseTags` except that `menuitem` should still have its closing tag.\n\tvar voidElementTags=assign({menuitem:true},omittedCloseTags);var HTML='__html';function assertValidProps(tag,props){if(!props){return;}// Note the use of `==` which checks for null or undefined.\n\tif(voidElementTags[tag]){if(props.children!=null||props.dangerouslySetInnerHTML!=null){throw new Error(tag+\" is a void element tag and must neither have `children` nor \"+'use `dangerouslySetInnerHTML`.');}}if(props.dangerouslySetInnerHTML!=null){if(props.children!=null){throw new Error('Can only set one of `children` or `props.dangerouslySetInnerHTML`.');}if(typeof props.dangerouslySetInnerHTML!=='object'||!(HTML in props.dangerouslySetInnerHTML)){throw new Error('`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. '+'Please visit https://reactjs.org/link/dangerously-set-inner-html '+'for more information.');}}{if(!props.suppressContentEditableWarning&&props.contentEditable&&props.children!=null){error('A component is `contentEditable` and contains `children` managed by '+'React. It is now your responsibility to guarantee that none of '+'those nodes are unexpectedly modified or duplicated. This is '+'probably not intentional.');}}if(props.style!=null&&typeof props.style!=='object'){throw new Error('The `style` prop expects a mapping from style properties to values, '+\"not a string. For example, style={{marginRight: spacing + 'em'}} when \"+'using JSX.');}}function isCustomComponent(tagName,props){if(tagName.indexOf('-')===-1){return typeof props.is==='string';}switch(tagName){// These are reserved SVG and MathML elements.\n\t// We don't mind this list too much because we expect it to never grow.\n\t// The alternative is to track the namespace in a few places which is convoluted.\n\t// https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts\n\tcase'annotation-xml':case'color-profile':case'font-face':case'font-face-src':case'font-face-uri':case'font-face-format':case'font-face-name':case'missing-glyph':return false;default:return true;}}// When adding attributes to the HTML or SVG allowed attribute list, be sure to\n\t// also add them to this module to ensure casing and incorrect name\n\t// warnings.\n\tvar possibleStandardNames={// HTML\n\taccept:'accept',acceptcharset:'acceptCharset','accept-charset':'acceptCharset',accesskey:'accessKey',action:'action',allowfullscreen:'allowFullScreen',alt:'alt',as:'as',async:'async',autocapitalize:'autoCapitalize',autocomplete:'autoComplete',autocorrect:'autoCorrect',autofocus:'autoFocus',autoplay:'autoPlay',autosave:'autoSave',capture:'capture',cellpadding:'cellPadding',cellspacing:'cellSpacing',challenge:'challenge',charset:'charSet',checked:'checked',children:'children',cite:'cite',class:'className',classid:'classID',classname:'className',cols:'cols',colspan:'colSpan',content:'content',contenteditable:'contentEditable',contextmenu:'contextMenu',controls:'controls',controlslist:'controlsList',coords:'coords',crossorigin:'crossOrigin',dangerouslysetinnerhtml:'dangerouslySetInnerHTML',data:'data',datetime:'dateTime',default:'default',defaultchecked:'defaultChecked',defaultvalue:'defaultValue',defer:'defer',dir:'dir',disabled:'disabled',disablepictureinpicture:'disablePictureInPicture',disableremoteplayback:'disableRemotePlayback',download:'download',draggable:'draggable',enctype:'encType',enterkeyhint:'enterKeyHint',for:'htmlFor',form:'form',formmethod:'formMethod',formaction:'formAction',formenctype:'formEncType',formnovalidate:'formNoValidate',formtarget:'formTarget',frameborder:'frameBorder',headers:'headers',height:'height',hidden:'hidden',high:'high',href:'href',hreflang:'hrefLang',htmlfor:'htmlFor',httpequiv:'httpEquiv','http-equiv':'httpEquiv',icon:'icon',id:'id',imagesizes:'imageSizes',imagesrcset:'imageSrcSet',innerhtml:'innerHTML',inputmode:'inputMode',integrity:'integrity',is:'is',itemid:'itemID',itemprop:'itemProp',itemref:'itemRef',itemscope:'itemScope',itemtype:'itemType',keyparams:'keyParams',keytype:'keyType',kind:'kind',label:'label',lang:'lang',list:'list',loop:'loop',low:'low',manifest:'manifest',marginwidth:'marginWidth',marginheight:'marginHeight',max:'max',maxlength:'maxLength',media:'media',mediagroup:'mediaGroup',method:'method',min:'min',minlength:'minLength',multiple:'multiple',muted:'muted',name:'name',nomodule:'noModule',nonce:'nonce',novalidate:'noValidate',open:'open',optimum:'optimum',pattern:'pattern',placeholder:'placeholder',playsinline:'playsInline',poster:'poster',preload:'preload',profile:'profile',radiogroup:'radioGroup',readonly:'readOnly',referrerpolicy:'referrerPolicy',rel:'rel',required:'required',reversed:'reversed',role:'role',rows:'rows',rowspan:'rowSpan',sandbox:'sandbox',scope:'scope',scoped:'scoped',scrolling:'scrolling',seamless:'seamless',selected:'selected',shape:'shape',size:'size',sizes:'sizes',span:'span',spellcheck:'spellCheck',src:'src',srcdoc:'srcDoc',srclang:'srcLang',srcset:'srcSet',start:'start',step:'step',style:'style',summary:'summary',tabindex:'tabIndex',target:'target',title:'title',type:'type',usemap:'useMap',value:'value',width:'width',wmode:'wmode',wrap:'wrap',// SVG\n\tabout:'about',accentheight:'accentHeight','accent-height':'accentHeight',accumulate:'accumulate',additive:'additive',alignmentbaseline:'alignmentBaseline','alignment-baseline':'alignmentBaseline',allowreorder:'allowReorder',alphabetic:'alphabetic',amplitude:'amplitude',arabicform:'arabicForm','arabic-form':'arabicForm',ascent:'ascent',attributename:'attributeName',attributetype:'attributeType',autoreverse:'autoReverse',azimuth:'azimuth',basefrequency:'baseFrequency',baselineshift:'baselineShift','baseline-shift':'baselineShift',baseprofile:'baseProfile',bbox:'bbox',begin:'begin',bias:'bias',by:'by',calcmode:'calcMode',capheight:'capHeight','cap-height':'capHeight',clip:'clip',clippath:'clipPath','clip-path':'clipPath',clippathunits:'clipPathUnits',cliprule:'clipRule','clip-rule':'clipRule',color:'color',colorinterpolation:'colorInterpolation','color-interpolation':'colorInterpolation',colorinterpolationfilters:'colorInterpolationFilters','color-interpolation-filters':'colorInterpolationFilters',colorprofile:'colorProfile','color-profile':'colorProfile',colorrendering:'colorRendering','color-rendering':'colorRendering',contentscripttype:'contentScriptType',contentstyletype:'contentStyleType',cursor:'cursor',cx:'cx',cy:'cy',d:'d',datatype:'datatype',decelerate:'decelerate',descent:'descent',diffuseconstant:'diffuseConstant',direction:'direction',display:'display',divisor:'divisor',dominantbaseline:'dominantBaseline','dominant-baseline':'dominantBaseline',dur:'dur',dx:'dx',dy:'dy',edgemode:'edgeMode',elevation:'elevation',enablebackground:'enableBackground','enable-background':'enableBackground',end:'end',exponent:'exponent',externalresourcesrequired:'externalResourcesRequired',fill:'fill',fillopacity:'fillOpacity','fill-opacity':'fillOpacity',fillrule:'fillRule','fill-rule':'fillRule',filter:'filter',filterres:'filterRes',filterunits:'filterUnits',floodopacity:'floodOpacity','flood-opacity':'floodOpacity',floodcolor:'floodColor','flood-color':'floodColor',focusable:'focusable',fontfamily:'fontFamily','font-family':'fontFamily',fontsize:'fontSize','font-size':'fontSize',fontsizeadjust:'fontSizeAdjust','font-size-adjust':'fontSizeAdjust',fontstretch:'fontStretch','font-stretch':'fontStretch',fontstyle:'fontStyle','font-style':'fontStyle',fontvariant:'fontVariant','font-variant':'fontVariant',fontweight:'fontWeight','font-weight':'fontWeight',format:'format',from:'from',fx:'fx',fy:'fy',g1:'g1',g2:'g2',glyphname:'glyphName','glyph-name':'glyphName',glyphorientationhorizontal:'glyphOrientationHorizontal','glyph-orientation-horizontal':'glyphOrientationHorizontal',glyphorientationvertical:'glyphOrientationVertical','glyph-orientation-vertical':'glyphOrientationVertical',glyphref:'glyphRef',gradienttransform:'gradientTransform',gradientunits:'gradientUnits',hanging:'hanging',horizadvx:'horizAdvX','horiz-adv-x':'horizAdvX',horizoriginx:'horizOriginX','horiz-origin-x':'horizOriginX',ideographic:'ideographic',imagerendering:'imageRendering','image-rendering':'imageRendering',in2:'in2',in:'in',inlist:'inlist',intercept:'intercept',k1:'k1',k2:'k2',k3:'k3',k4:'k4',k:'k',kernelmatrix:'kernelMatrix',kernelunitlength:'kernelUnitLength',kerning:'kerning',keypoints:'keyPoints',keysplines:'keySplines',keytimes:'keyTimes',lengthadjust:'lengthAdjust',letterspacing:'letterSpacing','letter-spacing':'letterSpacing',lightingcolor:'lightingColor','lighting-color':'lightingColor',limitingconeangle:'limitingConeAngle',local:'local',markerend:'markerEnd','marker-end':'markerEnd',markerheight:'markerHeight',markermid:'markerMid','marker-mid':'markerMid',markerstart:'markerStart','marker-start':'markerStart',markerunits:'markerUnits',markerwidth:'markerWidth',mask:'mask',maskcontentunits:'maskContentUnits',maskunits:'maskUnits',mathematical:'mathematical',mode:'mode',numoctaves:'numOctaves',offset:'offset',opacity:'opacity',operator:'operator',order:'order',orient:'orient',orientation:'orientation',origin:'origin',overflow:'overflow',overlineposition:'overlinePosition','overline-position':'overlinePosition',overlinethickness:'overlineThickness','overline-thickness':'overlineThickness',paintorder:'paintOrder','paint-order':'paintOrder',panose1:'panose1','panose-1':'panose1',pathlength:'pathLength',patterncontentunits:'patternContentUnits',patterntransform:'patternTransform',patternunits:'patternUnits',pointerevents:'pointerEvents','pointer-events':'pointerEvents',points:'points',pointsatx:'pointsAtX',pointsaty:'pointsAtY',pointsatz:'pointsAtZ',prefix:'prefix',preservealpha:'preserveAlpha',preserveaspectratio:'preserveAspectRatio',primitiveunits:'primitiveUnits',property:'property',r:'r',radius:'radius',refx:'refX',refy:'refY',renderingintent:'renderingIntent','rendering-intent':'renderingIntent',repeatcount:'repeatCount',repeatdur:'repeatDur',requiredextensions:'requiredExtensions',requiredfeatures:'requiredFeatures',resource:'resource',restart:'restart',result:'result',results:'results',rotate:'rotate',rx:'rx',ry:'ry',scale:'scale',security:'security',seed:'seed',shaperendering:'shapeRendering','shape-rendering':'shapeRendering',slope:'slope',spacing:'spacing',specularconstant:'specularConstant',specularexponent:'specularExponent',speed:'speed',spreadmethod:'spreadMethod',startoffset:'startOffset',stddeviation:'stdDeviation',stemh:'stemh',stemv:'stemv',stitchtiles:'stitchTiles',stopcolor:'stopColor','stop-color':'stopColor',stopopacity:'stopOpacity','stop-opacity':'stopOpacity',strikethroughposition:'strikethroughPosition','strikethrough-position':'strikethroughPosition',strikethroughthickness:'strikethroughThickness','strikethrough-thickness':'strikethroughThickness',string:'string',stroke:'stroke',strokedasharray:'strokeDasharray','stroke-dasharray':'strokeDasharray',strokedashoffset:'strokeDashoffset','stroke-dashoffset':'strokeDashoffset',strokelinecap:'strokeLinecap','stroke-linecap':'strokeLinecap',strokelinejoin:'strokeLinejoin','stroke-linejoin':'strokeLinejoin',strokemiterlimit:'strokeMiterlimit','stroke-miterlimit':'strokeMiterlimit',strokewidth:'strokeWidth','stroke-width':'strokeWidth',strokeopacity:'strokeOpacity','stroke-opacity':'strokeOpacity',suppresscontenteditablewarning:'suppressContentEditableWarning',suppresshydrationwarning:'suppressHydrationWarning',surfacescale:'surfaceScale',systemlanguage:'systemLanguage',tablevalues:'tableValues',targetx:'targetX',targety:'targetY',textanchor:'textAnchor','text-anchor':'textAnchor',textdecoration:'textDecoration','text-decoration':'textDecoration',textlength:'textLength',textrendering:'textRendering','text-rendering':'textRendering',to:'to',transform:'transform',typeof:'typeof',u1:'u1',u2:'u2',underlineposition:'underlinePosition','underline-position':'underlinePosition',underlinethickness:'underlineThickness','underline-thickness':'underlineThickness',unicode:'unicode',unicodebidi:'unicodeBidi','unicode-bidi':'unicodeBidi',unicoderange:'unicodeRange','unicode-range':'unicodeRange',unitsperem:'unitsPerEm','units-per-em':'unitsPerEm',unselectable:'unselectable',valphabetic:'vAlphabetic','v-alphabetic':'vAlphabetic',values:'values',vectoreffect:'vectorEffect','vector-effect':'vectorEffect',version:'version',vertadvy:'vertAdvY','vert-adv-y':'vertAdvY',vertoriginx:'vertOriginX','vert-origin-x':'vertOriginX',vertoriginy:'vertOriginY','vert-origin-y':'vertOriginY',vhanging:'vHanging','v-hanging':'vHanging',videographic:'vIdeographic','v-ideographic':'vIdeographic',viewbox:'viewBox',viewtarget:'viewTarget',visibility:'visibility',vmathematical:'vMathematical','v-mathematical':'vMathematical',vocab:'vocab',widths:'widths',wordspacing:'wordSpacing','word-spacing':'wordSpacing',writingmode:'writingMode','writing-mode':'writingMode',x1:'x1',x2:'x2',x:'x',xchannelselector:'xChannelSelector',xheight:'xHeight','x-height':'xHeight',xlinkactuate:'xlinkActuate','xlink:actuate':'xlinkActuate',xlinkarcrole:'xlinkArcrole','xlink:arcrole':'xlinkArcrole',xlinkhref:'xlinkHref','xlink:href':'xlinkHref',xlinkrole:'xlinkRole','xlink:role':'xlinkRole',xlinkshow:'xlinkShow','xlink:show':'xlinkShow',xlinktitle:'xlinkTitle','xlink:title':'xlinkTitle',xlinktype:'xlinkType','xlink:type':'xlinkType',xmlbase:'xmlBase','xml:base':'xmlBase',xmllang:'xmlLang','xml:lang':'xmlLang',xmlns:'xmlns','xml:space':'xmlSpace',xmlnsxlink:'xmlnsXlink','xmlns:xlink':'xmlnsXlink',xmlspace:'xmlSpace',y1:'y1',y2:'y2',y:'y',ychannelselector:'yChannelSelector',z:'z',zoomandpan:'zoomAndPan'};var ariaProperties={'aria-current':0,// state\n\t'aria-description':0,'aria-details':0,'aria-disabled':0,// state\n\t'aria-hidden':0,// state\n\t'aria-invalid':0,// state\n\t'aria-keyshortcuts':0,'aria-label':0,'aria-roledescription':0,// Widget Attributes\n\t'aria-autocomplete':0,'aria-checked':0,'aria-expanded':0,'aria-haspopup':0,'aria-level':0,'aria-modal':0,'aria-multiline':0,'aria-multiselectable':0,'aria-orientation':0,'aria-placeholder':0,'aria-pressed':0,'aria-readonly':0,'aria-required':0,'aria-selected':0,'aria-sort':0,'aria-valuemax':0,'aria-valuemin':0,'aria-valuenow':0,'aria-valuetext':0,// Live Region Attributes\n\t'aria-atomic':0,'aria-busy':0,'aria-live':0,'aria-relevant':0,// Drag-and-Drop Attributes\n\t'aria-dropeffect':0,'aria-grabbed':0,// Relationship Attributes\n\t'aria-activedescendant':0,'aria-colcount':0,'aria-colindex':0,'aria-colspan':0,'aria-controls':0,'aria-describedby':0,'aria-errormessage':0,'aria-flowto':0,'aria-labelledby':0,'aria-owns':0,'aria-posinset':0,'aria-rowcount':0,'aria-rowindex':0,'aria-rowspan':0,'aria-setsize':0};var warnedProperties={};var rARIA=new RegExp('^(aria)-['+ATTRIBUTE_NAME_CHAR+']*$');var rARIACamel=new RegExp('^(aria)[A-Z]['+ATTRIBUTE_NAME_CHAR+']*$');function validateProperty(tagName,name){{if(hasOwnProperty.call(warnedProperties,name)&&warnedProperties[name]){return true;}if(rARIACamel.test(name)){var ariaName='aria-'+name.slice(4).toLowerCase();var correctName=ariaProperties.hasOwnProperty(ariaName)?ariaName:null;// If this is an aria-* attribute, but is not listed in the known DOM\n\t// DOM properties, then it is an invalid aria-* attribute.\n\tif(correctName==null){error('Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.',name);warnedProperties[name]=true;return true;}// aria-* attributes should be lowercase; suggest the lowercase version.\n\tif(name!==correctName){error('Invalid ARIA attribute `%s`. Did you mean `%s`?',name,correctName);warnedProperties[name]=true;return true;}}if(rARIA.test(name)){var lowerCasedName=name.toLowerCase();var standardName=ariaProperties.hasOwnProperty(lowerCasedName)?lowerCasedName:null;// If this is an aria-* attribute, but is not listed in the known DOM\n\t// DOM properties, then it is an invalid aria-* attribute.\n\tif(standardName==null){warnedProperties[name]=true;return false;}// aria-* attributes should be lowercase; suggest the lowercase version.\n\tif(name!==standardName){error('Unknown ARIA attribute `%s`. Did you mean `%s`?',name,standardName);warnedProperties[name]=true;return true;}}}return true;}function warnInvalidARIAProps(type,props){{var invalidProps=[];for(var key in props){var isValid=validateProperty(type,key);if(!isValid){invalidProps.push(key);}}var unknownPropString=invalidProps.map(function(prop){return '`'+prop+'`';}).join(', ');if(invalidProps.length===1){error('Invalid aria prop %s on <%s> tag. '+'For details, see https://reactjs.org/link/invalid-aria-props',unknownPropString,type);}else if(invalidProps.length>1){error('Invalid aria props %s on <%s> tag. '+'For details, see https://reactjs.org/link/invalid-aria-props',unknownPropString,type);}}}function validateProperties(type,props){if(isCustomComponent(type,props)){return;}warnInvalidARIAProps(type,props);}var didWarnValueNull=false;function validateProperties$1(type,props){{if(type!=='input'&&type!=='textarea'&&type!=='select'){return;}if(props!=null&&props.value===null&&!didWarnValueNull){didWarnValueNull=true;if(type==='select'&&props.multiple){error('`value` prop on `%s` should not be null. '+'Consider using an empty array when `multiple` is set to `true` '+'to clear the component or `undefined` for uncontrolled components.',type);}else {error('`value` prop on `%s` should not be null. '+'Consider using an empty string to clear the component or `undefined` '+'for uncontrolled components.',type);}}}}var validateProperty$1=function(){};{var warnedProperties$1={};var EVENT_NAME_REGEX=/^on./;var INVALID_EVENT_NAME_REGEX=/^on[^A-Z]/;var rARIA$1=new RegExp('^(aria)-['+ATTRIBUTE_NAME_CHAR+']*$');var rARIACamel$1=new RegExp('^(aria)[A-Z]['+ATTRIBUTE_NAME_CHAR+']*$');validateProperty$1=function(tagName,name,value,eventRegistry){if(hasOwnProperty.call(warnedProperties$1,name)&&warnedProperties$1[name]){return true;}var lowerCasedName=name.toLowerCase();if(lowerCasedName==='onfocusin'||lowerCasedName==='onfocusout'){error('React uses onFocus and onBlur instead of onFocusIn and onFocusOut. '+'All React events are normalized to bubble, so onFocusIn and onFocusOut '+'are not needed/supported by React.');warnedProperties$1[name]=true;return true;}// We can't rely on the event system being injected on the server.\n\tif(eventRegistry!=null){var registrationNameDependencies=eventRegistry.registrationNameDependencies,possibleRegistrationNames=eventRegistry.possibleRegistrationNames;if(registrationNameDependencies.hasOwnProperty(name)){return true;}var registrationName=possibleRegistrationNames.hasOwnProperty(lowerCasedName)?possibleRegistrationNames[lowerCasedName]:null;if(registrationName!=null){error('Invalid event handler property `%s`. Did you mean `%s`?',name,registrationName);warnedProperties$1[name]=true;return true;}if(EVENT_NAME_REGEX.test(name)){error('Unknown event handler property `%s`. It will be ignored.',name);warnedProperties$1[name]=true;return true;}}else if(EVENT_NAME_REGEX.test(name)){// If no event plugins have been injected, we are in a server environment.\n\t// So we can't tell if the event name is correct for sure, but we can filter\n\t// out known bad ones like `onclick`. We can't suggest a specific replacement though.\n\tif(INVALID_EVENT_NAME_REGEX.test(name)){error('Invalid event handler property `%s`. '+'React events use the camelCase naming convention, for example `onClick`.',name);}warnedProperties$1[name]=true;return true;}// Let the ARIA attribute hook validate ARIA attributes\n\tif(rARIA$1.test(name)||rARIACamel$1.test(name)){return true;}if(lowerCasedName==='innerhtml'){error('Directly setting property `innerHTML` is not permitted. '+'For more information, lookup documentation on `dangerouslySetInnerHTML`.');warnedProperties$1[name]=true;return true;}if(lowerCasedName==='aria'){error('The `aria` attribute is reserved for future use in React. '+'Pass individual `aria-` attributes instead.');warnedProperties$1[name]=true;return true;}if(lowerCasedName==='is'&&value!==null&&value!==undefined&&typeof value!=='string'){error('Received a `%s` for a string attribute `is`. If this is expected, cast '+'the value to a string.',typeof value);warnedProperties$1[name]=true;return true;}if(typeof value==='number'&&isNaN(value)){error('Received NaN for the `%s` attribute. If this is expected, cast '+'the value to a string.',name);warnedProperties$1[name]=true;return true;}var propertyInfo=getPropertyInfo(name);var isReserved=propertyInfo!==null&&propertyInfo.type===RESERVED;// Known attributes should match the casing specified in the property config.\n\tif(possibleStandardNames.hasOwnProperty(lowerCasedName)){var standardName=possibleStandardNames[lowerCasedName];if(standardName!==name){error('Invalid DOM property `%s`. Did you mean `%s`?',name,standardName);warnedProperties$1[name]=true;return true;}}else if(!isReserved&&name!==lowerCasedName){// Unknown attributes should have lowercase casing since that's how they\n\t// will be cased anyway with server rendering.\n\terror('React does not recognize the `%s` prop on a DOM element. If you '+'intentionally want it to appear in the DOM as a custom '+'attribute, spell it as lowercase `%s` instead. '+'If you accidentally passed it from a parent component, remove '+'it from the DOM element.',name,lowerCasedName);warnedProperties$1[name]=true;return true;}if(typeof value==='boolean'&&shouldRemoveAttributeWithWarning(name,value,propertyInfo,false)){if(value){error('Received `%s` for a non-boolean attribute `%s`.\\n\\n'+'If you want to write it to the DOM, pass a string instead: '+'%s=\"%s\" or %s={value.toString()}.',value,name,name,value,name);}else {error('Received `%s` for a non-boolean attribute `%s`.\\n\\n'+'If you want to write it to the DOM, pass a string instead: '+'%s=\"%s\" or %s={value.toString()}.\\n\\n'+'If you used to conditionally omit it with %s={condition && value}, '+'pass %s={condition ? value : undefined} instead.',value,name,name,value,name,name,name);}warnedProperties$1[name]=true;return true;}// Now that we've validated casing, do not validate\n\t// data types for reserved props\n\tif(isReserved){return true;}// Warn when a known attribute is a bad type\n\tif(shouldRemoveAttributeWithWarning(name,value,propertyInfo,false)){warnedProperties$1[name]=true;return false;}// Warn when passing the strings 'false' or 'true' into a boolean prop\n\tif((value==='false'||value==='true')&&propertyInfo!==null&&propertyInfo.type===BOOLEAN){error('Received the string `%s` for the boolean attribute `%s`. '+'%s '+'Did you mean %s={%s}?',value,name,value==='false'?'The browser will interpret it as a truthy value.':'Although this works, it will not work as expected if you pass the string \"false\".',name,value);warnedProperties$1[name]=true;return true;}return true;};}var warnUnknownProperties=function(type,props,eventRegistry){{var unknownProps=[];for(var key in props){var isValid=validateProperty$1(type,key,props[key],eventRegistry);if(!isValid){unknownProps.push(key);}}var unknownPropString=unknownProps.map(function(prop){return '`'+prop+'`';}).join(', ');if(unknownProps.length===1){error('Invalid value for prop %s on <%s> tag. Either remove it from the element, '+'or pass a string or number value to keep it in the DOM. '+'For details, see https://reactjs.org/link/attribute-behavior ',unknownPropString,type);}else if(unknownProps.length>1){error('Invalid values for props %s on <%s> tag. Either remove them from the element, '+'or pass a string or number value to keep them in the DOM. '+'For details, see https://reactjs.org/link/attribute-behavior ',unknownPropString,type);}}};function validateProperties$2(type,props,eventRegistry){if(isCustomComponent(type,props)){return;}warnUnknownProperties(type,props,eventRegistry);}var IS_EVENT_HANDLE_NON_MANAGED_NODE=1;var IS_NON_DELEGATED=1<<1;var IS_CAPTURE_PHASE=1<<2;// set to LEGACY_FB_SUPPORT. LEGACY_FB_SUPPORT only gets set when\n\t// we call willDeferLaterForLegacyFBSupport, thus not bailing out\n\t// will result in endless cycles like an infinite loop.\n\t// We also don't want to defer during event replaying.\n\tvar SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS=IS_EVENT_HANDLE_NON_MANAGED_NODE|IS_NON_DELEGATED|IS_CAPTURE_PHASE;// This exists to avoid circular dependency between ReactDOMEventReplaying\n\t// and DOMPluginEventSystem.\n\tvar currentReplayingEvent=null;function setReplayingEvent(event){{if(currentReplayingEvent!==null){error('Expected currently replaying event to be null. This error '+'is likely caused by a bug in React. Please file an issue.');}}currentReplayingEvent=event;}function resetReplayingEvent(){{if(currentReplayingEvent===null){error('Expected currently replaying event to not be null. This error '+'is likely caused by a bug in React. Please file an issue.');}}currentReplayingEvent=null;}function isReplayingEvent(event){return event===currentReplayingEvent;}/**\n\t * Gets the target node from a native browser event by accounting for\n\t * inconsistencies in browser DOM APIs.\n\t *\n\t * @param {object} nativeEvent Native browser event.\n\t * @return {DOMEventTarget} Target node.\n\t */function getEventTarget(nativeEvent){// Fallback to nativeEvent.srcElement for IE9\n\t// https://github.com/facebook/react/issues/12506\n\tvar target=nativeEvent.target||nativeEvent.srcElement||window;// Normalize SVG <use> element events #4963\n\tif(target.correspondingUseElement){target=target.correspondingUseElement;}// Safari may fire events on text nodes (Node.TEXT_NODE is 3).\n\t// @see http://www.quirksmode.org/js/events_properties.html\n\treturn target.nodeType===TEXT_NODE?target.parentNode:target;}var restoreImpl=null;var restoreTarget=null;var restoreQueue=null;function restoreStateOfTarget(target){// We perform this translation at the end of the event loop so that we\n\t// always receive the correct fiber here\n\tvar internalInstance=getInstanceFromNode(target);if(!internalInstance){// Unmounted\n\treturn;}if(typeof restoreImpl!=='function'){throw new Error('setRestoreImplementation() needs to be called to handle a target for controlled '+'events. This error is likely caused by a bug in React. Please file an issue.');}var stateNode=internalInstance.stateNode;// Guard against Fiber being unmounted.\n\tif(stateNode){var _props=getFiberCurrentPropsFromNode(stateNode);restoreImpl(internalInstance.stateNode,internalInstance.type,_props);}}function setRestoreImplementation(impl){restoreImpl=impl;}function enqueueStateRestore(target){if(restoreTarget){if(restoreQueue){restoreQueue.push(target);}else {restoreQueue=[target];}}else {restoreTarget=target;}}function needsStateRestore(){return restoreTarget!==null||restoreQueue!==null;}function restoreStateIfNeeded(){if(!restoreTarget){return;}var target=restoreTarget;var queuedTargets=restoreQueue;restoreTarget=null;restoreQueue=null;restoreStateOfTarget(target);if(queuedTargets){for(var i=0;i<queuedTargets.length;i++){restoreStateOfTarget(queuedTargets[i]);}}}// the renderer. Such as when we're dispatching events or if third party\n\t// libraries need to call batchedUpdates. Eventually, this API will go away when\n\t// everything is batched by default. We'll then have a similar API to opt-out of\n\t// scheduled work and instead do synchronous work.\n\t// Defaults\n\tvar batchedUpdatesImpl=function(fn,bookkeeping){return fn(bookkeeping);};var flushSyncImpl=function(){};var isInsideEventHandler=false;function finishEventHandler(){// Here we wait until all updates have propagated, which is important\n\t// when using controlled components within layers:\n\t// https://github.com/facebook/react/issues/1698\n\t// Then we restore state of any controlled component.\n\tvar controlledComponentsHavePendingUpdates=needsStateRestore();if(controlledComponentsHavePendingUpdates){// If a controlled event was fired, we may need to restore the state of\n\t// the DOM node back to the controlled value. This is necessary when React\n\t// bails out of the update without touching the DOM.\n\t// TODO: Restore state in the microtask, after the discrete updates flush,\n\t// instead of early flushing them here.\n\tflushSyncImpl();restoreStateIfNeeded();}}function batchedUpdates(fn,a,b){if(isInsideEventHandler){// If we are currently inside another batch, we need to wait until it\n\t// fully completes before restoring state.\n\treturn fn(a,b);}isInsideEventHandler=true;try{return batchedUpdatesImpl(fn,a,b);}finally{isInsideEventHandler=false;finishEventHandler();}}// TODO: Replace with flushSync\n\tfunction setBatchingImplementation(_batchedUpdatesImpl,_discreteUpdatesImpl,_flushSyncImpl){batchedUpdatesImpl=_batchedUpdatesImpl;flushSyncImpl=_flushSyncImpl;}function isInteractive(tag){return tag==='button'||tag==='input'||tag==='select'||tag==='textarea';}function shouldPreventMouseEvent(name,type,props){switch(name){case'onClick':case'onClickCapture':case'onDoubleClick':case'onDoubleClickCapture':case'onMouseDown':case'onMouseDownCapture':case'onMouseMove':case'onMouseMoveCapture':case'onMouseUp':case'onMouseUpCapture':case'onMouseEnter':return !!(props.disabled&&isInteractive(type));default:return false;}}/**\n\t * @param {object} inst The instance, which is the source of events.\n\t * @param {string} registrationName Name of listener (e.g. `onClick`).\n\t * @return {?function} The stored callback.\n\t */function getListener(inst,registrationName){var stateNode=inst.stateNode;if(stateNode===null){// Work in progress (ex: onload events in incremental mode).\n\treturn null;}var props=getFiberCurrentPropsFromNode(stateNode);if(props===null){// Work in progress.\n\treturn null;}var listener=props[registrationName];if(shouldPreventMouseEvent(registrationName,inst.type,props)){return null;}if(listener&&typeof listener!=='function'){throw new Error(\"Expected `\"+registrationName+\"` listener to be a function, instead got a value of `\"+typeof listener+\"` type.\");}return listener;}var passiveBrowserEventsSupported=false;// Check if browser support events with passive listeners\n\t// https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support\n\tif(canUseDOM){try{var options={};// $FlowFixMe: Ignore Flow complaining about needing a value\n\tObject.defineProperty(options,'passive',{get:function(){passiveBrowserEventsSupported=true;}});window.addEventListener('test',options,options);window.removeEventListener('test',options,options);}catch(e){passiveBrowserEventsSupported=false;}}function invokeGuardedCallbackProd(name,func,context,a,b,c,d,e,f){var funcArgs=Array.prototype.slice.call(arguments,3);try{func.apply(context,funcArgs);}catch(error){this.onError(error);}}var invokeGuardedCallbackImpl=invokeGuardedCallbackProd;{// In DEV mode, we swap out invokeGuardedCallback for a special version\n\t// that plays more nicely with the browser's DevTools. The idea is to preserve\n\t// \"Pause on exceptions\" behavior. Because React wraps all user-provided\n\t// functions in invokeGuardedCallback, and the production version of\n\t// invokeGuardedCallback uses a try-catch, all user exceptions are treated\n\t// like caught exceptions, and the DevTools won't pause unless the developer\n\t// takes the extra step of enabling pause on caught exceptions. This is\n\t// unintuitive, though, because even though React has caught the error, from\n\t// the developer's perspective, the error is uncaught.\n\t//\n\t// To preserve the expected \"Pause on exceptions\" behavior, we don't use a\n\t// try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake\n\t// DOM node, and call the user-provided callback from inside an event handler\n\t// for that fake event. If the callback throws, the error is \"captured\" using\n\t// a global event handler. But because the error happens in a different\n\t// event loop context, it does not interrupt the normal program flow.\n\t// Effectively, this gives us try-catch behavior without actually using\n\t// try-catch. Neat!\n\t// Check that the browser supports the APIs we need to implement our special\n\t// DEV version of invokeGuardedCallback\n\tif(typeof window!=='undefined'&&typeof window.dispatchEvent==='function'&&typeof document!=='undefined'&&typeof document.createEvent==='function'){var fakeNode=document.createElement('react');invokeGuardedCallbackImpl=function invokeGuardedCallbackDev(name,func,context,a,b,c,d,e,f){// If document doesn't exist we know for sure we will crash in this method\n\t// when we call document.createEvent(). However this can cause confusing\n\t// errors: https://github.com/facebook/create-react-app/issues/3482\n\t// So we preemptively throw with a better message instead.\n\tif(typeof document==='undefined'||document===null){throw new Error('The `document` global was defined when React was initialized, but is not '+'defined anymore. This can happen in a test environment if a component '+'schedules an update from an asynchronous callback, but the test has already '+'finished running. To solve this, you can either unmount the component at '+'the end of your test (and ensure that any asynchronous operations get '+'canceled in `componentWillUnmount`), or you can change the test itself '+'to be asynchronous.');}var evt=document.createEvent('Event');var didCall=false;// Keeps track of whether the user-provided callback threw an error. We\n\t// set this to true at the beginning, then set it to false right after\n\t// calling the function. If the function errors, `didError` will never be\n\t// set to false. This strategy works even if the browser is flaky and\n\t// fails to call our global error handler, because it doesn't rely on\n\t// the error event at all.\n\tvar didError=true;// Keeps track of the value of window.event so that we can reset it\n\t// during the callback to let user code access window.event in the\n\t// browsers that support it.\n\tvar windowEvent=window.event;// Keeps track of the descriptor of window.event to restore it after event\n\t// dispatching: https://github.com/facebook/react/issues/13688\n\tvar windowEventDescriptor=Object.getOwnPropertyDescriptor(window,'event');function restoreAfterDispatch(){// We immediately remove the callback from event listeners so that\n\t// nested `invokeGuardedCallback` calls do not clash. Otherwise, a\n\t// nested call would trigger the fake event handlers of any call higher\n\t// in the stack.\n\tfakeNode.removeEventListener(evtType,callCallback,false);// We check for window.hasOwnProperty('event') to prevent the\n\t// window.event assignment in both IE <= 10 as they throw an error\n\t// \"Member not found\" in strict mode, and in Firefox which does not\n\t// support window.event.\n\tif(typeof window.event!=='undefined'&&window.hasOwnProperty('event')){window.event=windowEvent;}}// Create an event handler for our fake event. We will synchronously\n\t// dispatch our fake event using `dispatchEvent`. Inside the handler, we\n\t// call the user-provided callback.\n\tvar funcArgs=Array.prototype.slice.call(arguments,3);function callCallback(){didCall=true;restoreAfterDispatch();func.apply(context,funcArgs);didError=false;}// Create a global error event handler. We use this to capture the value\n\t// that was thrown. It's possible that this error handler will fire more\n\t// than once; for example, if non-React code also calls `dispatchEvent`\n\t// and a handler for that event throws. We should be resilient to most of\n\t// those cases. Even if our error event handler fires more than once, the\n\t// last error event is always used. If the callback actually does error,\n\t// we know that the last error event is the correct one, because it's not\n\t// possible for anything else to have happened in between our callback\n\t// erroring and the code that follows the `dispatchEvent` call below. If\n\t// the callback doesn't error, but the error event was fired, we know to\n\t// ignore it because `didError` will be false, as described above.\n\tvar error;// Use this to track whether the error event is ever called.\n\tvar didSetError=false;var isCrossOriginError=false;function handleWindowError(event){error=event.error;didSetError=true;if(error===null&&event.colno===0&&event.lineno===0){isCrossOriginError=true;}if(event.defaultPrevented){// Some other error handler has prevented default.\n\t// Browsers silence the error report if this happens.\n\t// We'll remember this to later decide whether to log it or not.\n\tif(error!=null&&typeof error==='object'){try{error._suppressLogging=true;}catch(inner){// Ignore.\n\t}}}}// Create a fake event type.\n\tvar evtType=\"react-\"+(name?name:'invokeguardedcallback');// Attach our event handlers\n\twindow.addEventListener('error',handleWindowError);fakeNode.addEventListener(evtType,callCallback,false);// Synchronously dispatch our fake event. If the user-provided function\n\t// errors, it will trigger our global error handler.\n\tevt.initEvent(evtType,false,false);fakeNode.dispatchEvent(evt);if(windowEventDescriptor){Object.defineProperty(window,'event',windowEventDescriptor);}if(didCall&&didError){if(!didSetError){// The callback errored, but the error event never fired.\n\t// eslint-disable-next-line react-internal/prod-error-codes\n\terror=new Error('An error was thrown inside one of your components, but React '+\"doesn't know what it was. This is likely due to browser \"+'flakiness. React does its best to preserve the \"Pause on '+'exceptions\" behavior of the DevTools, which requires some '+\"DEV-mode only tricks. It's possible that these don't work in \"+'your browser. Try triggering the error in production mode, '+'or switching to a modern browser. If you suspect that this is '+'actually an issue with React, please file an issue.');}else if(isCrossOriginError){// eslint-disable-next-line react-internal/prod-error-codes\n\terror=new Error(\"A cross-origin error was thrown. React doesn't have access to \"+'the actual error object in development. '+'See https://reactjs.org/link/crossorigin-error for more information.');}this.onError(error);}// Remove our event listeners\n\twindow.removeEventListener('error',handleWindowError);if(!didCall){// Something went really wrong, and our event was not dispatched.\n\t// https://github.com/facebook/react/issues/16734\n\t// https://github.com/facebook/react/issues/16585\n\t// Fall back to the production implementation.\n\trestoreAfterDispatch();return invokeGuardedCallbackProd.apply(this,arguments);}};}}var invokeGuardedCallbackImpl$1=invokeGuardedCallbackImpl;var hasError=false;var caughtError=null;// Used by event system to capture/rethrow the first error.\n\tvar hasRethrowError=false;var rethrowError=null;var reporter={onError:function(error){hasError=true;caughtError=error;}};/**\n\t * Call a function while guarding against errors that happens within it.\n\t * Returns an error if it throws, otherwise null.\n\t *\n\t * In production, this is implemented using a try-catch. The reason we don't\n\t * use a try-catch directly is so that we can swap out a different\n\t * implementation in DEV mode.\n\t *\n\t * @param {String} name of the guard to use for logging or debugging\n\t * @param {Function} func The function to invoke\n\t * @param {*} context The context to use when calling the function\n\t * @param {...*} args Arguments for function\n\t */function invokeGuardedCallback(name,func,context,a,b,c,d,e,f){hasError=false;caughtError=null;invokeGuardedCallbackImpl$1.apply(reporter,arguments);}/**\n\t * Same as invokeGuardedCallback, but instead of returning an error, it stores\n\t * it in a global so it can be rethrown by `rethrowCaughtError` later.\n\t * TODO: See if caughtError and rethrowError can be unified.\n\t *\n\t * @param {String} name of the guard to use for logging or debugging\n\t * @param {Function} func The function to invoke\n\t * @param {*} context The context to use when calling the function\n\t * @param {...*} args Arguments for function\n\t */function invokeGuardedCallbackAndCatchFirstError(name,func,context,a,b,c,d,e,f){invokeGuardedCallback.apply(this,arguments);if(hasError){var error=clearCaughtError();if(!hasRethrowError){hasRethrowError=true;rethrowError=error;}}}/**\n\t * During execution of guarded functions we will capture the first error which\n\t * we will rethrow to be handled by the top level error handler.\n\t */function rethrowCaughtError(){if(hasRethrowError){var error=rethrowError;hasRethrowError=false;rethrowError=null;throw error;}}function hasCaughtError(){return hasError;}function clearCaughtError(){if(hasError){var error=caughtError;hasError=false;caughtError=null;return error;}else {throw new Error('clearCaughtError was called but no error was captured. This error '+'is likely caused by a bug in React. Please file an issue.');}}/**\n\t * `ReactInstanceMap` maintains a mapping from a public facing stateful\n\t * instance (key) and the internal representation (value). This allows public\n\t * methods to accept the user facing instance as an argument and map them back\n\t * to internal methods.\n\t *\n\t * Note that this module is currently shared and assumed to be stateless.\n\t * If this becomes an actual Map, that will break.\n\t */function get(key){return key._reactInternals;}function has(key){return key._reactInternals!==undefined;}function set(key,value){key._reactInternals=value;}// Don't change these two values. They're used by React Dev Tools.\n\tvar NoFlags=/*                      */0;var PerformedWork=/*                */1;// You can change the rest (and add more).\n\tvar Placement=/*                    */2;var Update=/*                       */4;var ChildDeletion=/*                */16;var ContentReset=/*                 */32;var Callback=/*                     */64;var DidCapture=/*                   */128;var ForceClientRender=/*            */256;var Ref=/*                          */512;var Snapshot=/*                     */1024;var Passive=/*                      */2048;var Hydrating=/*                    */4096;var Visibility=/*                   */8192;var StoreConsistency=/*             */16384;var LifecycleEffectMask=Passive|Update|Callback|Ref|Snapshot|StoreConsistency;// Union of all commit flags (flags with the lifetime of a particular commit)\n\tvar HostEffectMask=/*               */32767;// These are not really side effects, but we still reuse this field.\n\tvar Incomplete=/*                   */32768;var ShouldCapture=/*                */65536;var ForceUpdateForLegacySuspense=/* */131072;var Forked=/*                       */1048576;// Static tags describe aspects of a fiber that are not specific to a render,\n\t// e.g. a fiber uses a passive effect (even if there are no updates on this particular render).\n\t// This enables us to defer more work in the unmount case,\n\t// since we can defer traversing the tree during layout to look for Passive effects,\n\t// and instead rely on the static flag as a signal that there may be cleanup work.\n\tvar RefStatic=/*                    */2097152;var LayoutStatic=/*                 */4194304;var PassiveStatic=/*                */8388608;// These flags allow us to traverse to fibers that have effects on mount\n\t// without traversing the entire tree after every commit for\n\t// double invoking\n\tvar MountLayoutDev=/*               */16777216;var MountPassiveDev=/*              */33554432;// Groups of flags that are used in the commit phase to skip over trees that\n\t// don't contain effects, by checking subtreeFlags.\n\tvar BeforeMutationMask=// TODO: Remove Update flag from before mutation phase by re-landing Visibility\n\t// flag logic (see #20043)\n\tUpdate|Snapshot|0;var MutationMask=Placement|Update|ChildDeletion|ContentReset|Ref|Hydrating|Visibility;var LayoutMask=Update|Callback|Ref|Visibility;// TODO: Split into PassiveMountMask and PassiveUnmountMask\n\tvar PassiveMask=Passive|ChildDeletion;// Union of tags that don't get reset on clones.\n\t// This allows certain concepts to persist without recalculating them,\n\t// e.g. whether a subtree contains passive effects or portals.\n\tvar StaticMask=LayoutStatic|PassiveStatic|RefStatic;var ReactCurrentOwner=ReactSharedInternals.ReactCurrentOwner;function getNearestMountedFiber(fiber){var node=fiber;var nearestMounted=fiber;if(!fiber.alternate){// If there is no alternate, this might be a new tree that isn't inserted\n\t// yet. If it is, then it will have a pending insertion effect on it.\n\tvar nextNode=node;do{node=nextNode;if((node.flags&(Placement|Hydrating))!==NoFlags){// This is an insertion or in-progress hydration. The nearest possible\n\t// mounted fiber is the parent but we need to continue to figure out\n\t// if that one is still mounted.\n\tnearestMounted=node.return;}nextNode=node.return;}while(nextNode);}else {while(node.return){node=node.return;}}if(node.tag===HostRoot){// TODO: Check if this was a nested HostRoot when used with\n\t// renderContainerIntoSubtree.\n\treturn nearestMounted;}// If we didn't hit the root, that means that we're in an disconnected tree\n\t// that has been unmounted.\n\treturn null;}function getSuspenseInstanceFromFiber(fiber){if(fiber.tag===SuspenseComponent){var suspenseState=fiber.memoizedState;if(suspenseState===null){var current=fiber.alternate;if(current!==null){suspenseState=current.memoizedState;}}if(suspenseState!==null){return suspenseState.dehydrated;}}return null;}function getContainerFromFiber(fiber){return fiber.tag===HostRoot?fiber.stateNode.containerInfo:null;}function isFiberMounted(fiber){return getNearestMountedFiber(fiber)===fiber;}function isMounted(component){{var owner=ReactCurrentOwner.current;if(owner!==null&&owner.tag===ClassComponent){var ownerFiber=owner;var instance=ownerFiber.stateNode;if(!instance._warnedAboutRefsInRender){error('%s is accessing isMounted inside its render() function. '+'render() should be a pure function of props and state. It should '+'never access something that requires stale data from the previous '+'render, such as refs. Move this logic to componentDidMount and '+'componentDidUpdate instead.',getComponentNameFromFiber(ownerFiber)||'A component');}instance._warnedAboutRefsInRender=true;}}var fiber=get(component);if(!fiber){return false;}return getNearestMountedFiber(fiber)===fiber;}function assertIsMounted(fiber){if(getNearestMountedFiber(fiber)!==fiber){throw new Error('Unable to find node on an unmounted component.');}}function findCurrentFiberUsingSlowPath(fiber){var alternate=fiber.alternate;if(!alternate){// If there is no alternate, then we only need to check if it is mounted.\n\tvar nearestMounted=getNearestMountedFiber(fiber);if(nearestMounted===null){throw new Error('Unable to find node on an unmounted component.');}if(nearestMounted!==fiber){return null;}return fiber;}// If we have two possible branches, we'll walk backwards up to the root\n\t// to see what path the root points to. On the way we may hit one of the\n\t// special cases and we'll deal with them.\n\tvar a=fiber;var b=alternate;while(true){var parentA=a.return;if(parentA===null){// We're at the root.\n\tbreak;}var parentB=parentA.alternate;if(parentB===null){// There is no alternate. This is an unusual case. Currently, it only\n\t// happens when a Suspense component is hidden. An extra fragment fiber\n\t// is inserted in between the Suspense fiber and its children. Skip\n\t// over this extra fragment fiber and proceed to the next parent.\n\tvar nextParent=parentA.return;if(nextParent!==null){a=b=nextParent;continue;}// If there's no parent, we're at the root.\n\tbreak;}// If both copies of the parent fiber point to the same child, we can\n\t// assume that the child is current. This happens when we bailout on low\n\t// priority: the bailed out fiber's child reuses the current child.\n\tif(parentA.child===parentB.child){var child=parentA.child;while(child){if(child===a){// We've determined that A is the current branch.\n\tassertIsMounted(parentA);return fiber;}if(child===b){// We've determined that B is the current branch.\n\tassertIsMounted(parentA);return alternate;}child=child.sibling;}// We should never have an alternate for any mounting node. So the only\n\t// way this could possibly happen is if this was unmounted, if at all.\n\tthrow new Error('Unable to find node on an unmounted component.');}if(a.return!==b.return){// The return pointer of A and the return pointer of B point to different\n\t// fibers. We assume that return pointers never criss-cross, so A must\n\t// belong to the child set of A.return, and B must belong to the child\n\t// set of B.return.\n\ta=parentA;b=parentB;}else {// The return pointers point to the same fiber. We'll have to use the\n\t// default, slow path: scan the child sets of each parent alternate to see\n\t// which child belongs to which set.\n\t//\n\t// Search parent A's child set\n\tvar didFindChild=false;var _child=parentA.child;while(_child){if(_child===a){didFindChild=true;a=parentA;b=parentB;break;}if(_child===b){didFindChild=true;b=parentA;a=parentB;break;}_child=_child.sibling;}if(!didFindChild){// Search parent B's child set\n\t_child=parentB.child;while(_child){if(_child===a){didFindChild=true;a=parentB;b=parentA;break;}if(_child===b){didFindChild=true;b=parentB;a=parentA;break;}_child=_child.sibling;}if(!didFindChild){throw new Error('Child was not found in either parent set. This indicates a bug '+'in React related to the return pointer. Please file an issue.');}}}if(a.alternate!==b){throw new Error(\"Return fibers should always be each others' alternates. \"+'This error is likely caused by a bug in React. Please file an issue.');}}// If the root is not a host container, we're in a disconnected tree. I.e.\n\t// unmounted.\n\tif(a.tag!==HostRoot){throw new Error('Unable to find node on an unmounted component.');}if(a.stateNode.current===a){// We've determined that A is the current branch.\n\treturn fiber;}// Otherwise B has to be current branch.\n\treturn alternate;}function findCurrentHostFiber(parent){var currentParent=findCurrentFiberUsingSlowPath(parent);return currentParent!==null?findCurrentHostFiberImpl(currentParent):null;}function findCurrentHostFiberImpl(node){// Next we'll drill down this component to find the first HostComponent/Text.\n\tif(node.tag===HostComponent||node.tag===HostText){return node;}var child=node.child;while(child!==null){var match=findCurrentHostFiberImpl(child);if(match!==null){return match;}child=child.sibling;}return null;}function findCurrentHostFiberWithNoPortals(parent){var currentParent=findCurrentFiberUsingSlowPath(parent);return currentParent!==null?findCurrentHostFiberWithNoPortalsImpl(currentParent):null;}function findCurrentHostFiberWithNoPortalsImpl(node){// Next we'll drill down this component to find the first HostComponent/Text.\n\tif(node.tag===HostComponent||node.tag===HostText){return node;}var child=node.child;while(child!==null){if(child.tag!==HostPortal){var match=findCurrentHostFiberWithNoPortalsImpl(child);if(match!==null){return match;}}child=child.sibling;}return null;}// This module only exists as an ESM wrapper around the external CommonJS\n\tvar scheduleCallback=Scheduler.unstable_scheduleCallback;var cancelCallback=Scheduler.unstable_cancelCallback;var shouldYield=Scheduler.unstable_shouldYield;var requestPaint=Scheduler.unstable_requestPaint;var now=Scheduler.unstable_now;var getCurrentPriorityLevel=Scheduler.unstable_getCurrentPriorityLevel;var ImmediatePriority=Scheduler.unstable_ImmediatePriority;var UserBlockingPriority=Scheduler.unstable_UserBlockingPriority;var NormalPriority=Scheduler.unstable_NormalPriority;var LowPriority=Scheduler.unstable_LowPriority;var IdlePriority=Scheduler.unstable_IdlePriority;// this doesn't actually exist on the scheduler, but it *does*\n\t// on scheduler/unstable_mock, which we'll need for internal testing\n\tvar unstable_yieldValue=Scheduler.unstable_yieldValue;var unstable_setDisableYieldValue=Scheduler.unstable_setDisableYieldValue;var rendererID=null;var injectedHook=null;var injectedProfilingHooks=null;var hasLoggedError=false;var isDevToolsPresent=typeof __REACT_DEVTOOLS_GLOBAL_HOOK__!=='undefined';function injectInternals(internals){if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__==='undefined'){// No DevTools\n\treturn false;}var hook=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(hook.isDisabled){// This isn't a real property on the hook, but it can be set to opt out\n\t// of DevTools integration and associated warnings and logs.\n\t// https://github.com/facebook/react/issues/3877\n\treturn true;}if(!hook.supportsFiber){{error('The installed version of React DevTools is too old and will not work '+'with the current version of React. Please update React DevTools. '+'https://reactjs.org/link/react-devtools');}// DevTools exists, even though it doesn't support Fiber.\n\treturn true;}try{if(enableSchedulingProfiler){// Conditionally inject these hooks only if Timeline profiler is supported by this build.\n\t// This gives DevTools a way to feature detect that isn't tied to version number\n\t// (since profiling and timeline are controlled by different feature flags).\n\tinternals=assign({},internals,{getLaneLabelMap:getLaneLabelMap,injectProfilingHooks:injectProfilingHooks});}rendererID=hook.inject(internals);// We have successfully injected, so now it is safe to set up hooks.\n\tinjectedHook=hook;}catch(err){// Catch all errors because it is unsafe to throw during initialization.\n\t{error('React instrumentation encountered an error: %s.',err);}}if(hook.checkDCE){// This is the real DevTools.\n\treturn true;}else {// This is likely a hook installed by Fast Refresh runtime.\n\treturn false;}}function onScheduleRoot(root,children){{if(injectedHook&&typeof injectedHook.onScheduleFiberRoot==='function'){try{injectedHook.onScheduleFiberRoot(rendererID,root,children);}catch(err){if(!hasLoggedError){hasLoggedError=true;error('React instrumentation encountered an error: %s',err);}}}}}function onCommitRoot(root,eventPriority){if(injectedHook&&typeof injectedHook.onCommitFiberRoot==='function'){try{var didError=(root.current.flags&DidCapture)===DidCapture;if(enableProfilerTimer){var schedulerPriority;switch(eventPriority){case DiscreteEventPriority:schedulerPriority=ImmediatePriority;break;case ContinuousEventPriority:schedulerPriority=UserBlockingPriority;break;case DefaultEventPriority:schedulerPriority=NormalPriority;break;case IdleEventPriority:schedulerPriority=IdlePriority;break;default:schedulerPriority=NormalPriority;break;}injectedHook.onCommitFiberRoot(rendererID,root,schedulerPriority,didError);}}catch(err){{if(!hasLoggedError){hasLoggedError=true;error('React instrumentation encountered an error: %s',err);}}}}}function onPostCommitRoot(root){if(injectedHook&&typeof injectedHook.onPostCommitFiberRoot==='function'){try{injectedHook.onPostCommitFiberRoot(rendererID,root);}catch(err){{if(!hasLoggedError){hasLoggedError=true;error('React instrumentation encountered an error: %s',err);}}}}}function onCommitUnmount(fiber){if(injectedHook&&typeof injectedHook.onCommitFiberUnmount==='function'){try{injectedHook.onCommitFiberUnmount(rendererID,fiber);}catch(err){{if(!hasLoggedError){hasLoggedError=true;error('React instrumentation encountered an error: %s',err);}}}}}function setIsStrictModeForDevtools(newIsStrictMode){{if(typeof unstable_yieldValue==='function'){// We're in a test because Scheduler.unstable_yieldValue only exists\n\t// in SchedulerMock. To reduce the noise in strict mode tests,\n\t// suppress warnings and disable scheduler yielding during the double render\n\tunstable_setDisableYieldValue(newIsStrictMode);setSuppressWarning(newIsStrictMode);}if(injectedHook&&typeof injectedHook.setStrictMode==='function'){try{injectedHook.setStrictMode(rendererID,newIsStrictMode);}catch(err){{if(!hasLoggedError){hasLoggedError=true;error('React instrumentation encountered an error: %s',err);}}}}}}// Profiler API hooks\n\tfunction injectProfilingHooks(profilingHooks){injectedProfilingHooks=profilingHooks;}function getLaneLabelMap(){{var map=new Map();var lane=1;for(var index=0;index<TotalLanes;index++){var label=getLabelForLane(lane);map.set(lane,label);lane*=2;}return map;}}function markCommitStarted(lanes){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markCommitStarted==='function'){injectedProfilingHooks.markCommitStarted(lanes);}}}function markCommitStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markCommitStopped==='function'){injectedProfilingHooks.markCommitStopped();}}}function markComponentRenderStarted(fiber){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentRenderStarted==='function'){injectedProfilingHooks.markComponentRenderStarted(fiber);}}}function markComponentRenderStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentRenderStopped==='function'){injectedProfilingHooks.markComponentRenderStopped();}}}function markComponentPassiveEffectMountStarted(fiber){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted==='function'){injectedProfilingHooks.markComponentPassiveEffectMountStarted(fiber);}}}function markComponentPassiveEffectMountStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped==='function'){injectedProfilingHooks.markComponentPassiveEffectMountStopped();}}}function markComponentPassiveEffectUnmountStarted(fiber){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted==='function'){injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(fiber);}}}function markComponentPassiveEffectUnmountStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped==='function'){injectedProfilingHooks.markComponentPassiveEffectUnmountStopped();}}}function markComponentLayoutEffectMountStarted(fiber){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted==='function'){injectedProfilingHooks.markComponentLayoutEffectMountStarted(fiber);}}}function markComponentLayoutEffectMountStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped==='function'){injectedProfilingHooks.markComponentLayoutEffectMountStopped();}}}function markComponentLayoutEffectUnmountStarted(fiber){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted==='function'){injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(fiber);}}}function markComponentLayoutEffectUnmountStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped==='function'){injectedProfilingHooks.markComponentLayoutEffectUnmountStopped();}}}function markComponentErrored(fiber,thrownValue,lanes){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentErrored==='function'){injectedProfilingHooks.markComponentErrored(fiber,thrownValue,lanes);}}}function markComponentSuspended(fiber,wakeable,lanes){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentSuspended==='function'){injectedProfilingHooks.markComponentSuspended(fiber,wakeable,lanes);}}}function markLayoutEffectsStarted(lanes){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markLayoutEffectsStarted==='function'){injectedProfilingHooks.markLayoutEffectsStarted(lanes);}}}function markLayoutEffectsStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markLayoutEffectsStopped==='function'){injectedProfilingHooks.markLayoutEffectsStopped();}}}function markPassiveEffectsStarted(lanes){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markPassiveEffectsStarted==='function'){injectedProfilingHooks.markPassiveEffectsStarted(lanes);}}}function markPassiveEffectsStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markPassiveEffectsStopped==='function'){injectedProfilingHooks.markPassiveEffectsStopped();}}}function markRenderStarted(lanes){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markRenderStarted==='function'){injectedProfilingHooks.markRenderStarted(lanes);}}}function markRenderYielded(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markRenderYielded==='function'){injectedProfilingHooks.markRenderYielded();}}}function markRenderStopped(){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markRenderStopped==='function'){injectedProfilingHooks.markRenderStopped();}}}function markRenderScheduled(lane){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markRenderScheduled==='function'){injectedProfilingHooks.markRenderScheduled(lane);}}}function markForceUpdateScheduled(fiber,lane){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markForceUpdateScheduled==='function'){injectedProfilingHooks.markForceUpdateScheduled(fiber,lane);}}}function markStateUpdateScheduled(fiber,lane){{if(injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markStateUpdateScheduled==='function'){injectedProfilingHooks.markStateUpdateScheduled(fiber,lane);}}}var NoMode=/*                         */0;// TODO: Remove ConcurrentMode by reading from the root tag instead\n\tvar ConcurrentMode=/*                 */1;var ProfileMode=/*                    */2;var StrictLegacyMode=/*               */8;var StrictEffectsMode=/*              */16;// TODO: This is pretty well supported by browsers. Maybe we can drop it.\n\tvar clz32=Math.clz32?Math.clz32:clz32Fallback;// Count leading zeros.\n\t// Based on:\n\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32\n\tvar log=Math.log;var LN2=Math.LN2;function clz32Fallback(x){var asUint=x>>>0;if(asUint===0){return 32;}return 31-(log(asUint)/LN2|0)|0;}// If those values are changed that package should be rebuilt and redeployed.\n\tvar TotalLanes=31;var NoLanes=/*                        */0;var NoLane=/*                          */0;var SyncLane=/*                        */1;var InputContinuousHydrationLane=/*    */2;var InputContinuousLane=/*             */4;var DefaultHydrationLane=/*            */8;var DefaultLane=/*                     */16;var TransitionHydrationLane=/*                */32;var TransitionLanes=/*                       */4194240;var TransitionLane1=/*                        */64;var TransitionLane2=/*                        */128;var TransitionLane3=/*                        */256;var TransitionLane4=/*                        */512;var TransitionLane5=/*                        */1024;var TransitionLane6=/*                        */2048;var TransitionLane7=/*                        */4096;var TransitionLane8=/*                        */8192;var TransitionLane9=/*                        */16384;var TransitionLane10=/*                       */32768;var TransitionLane11=/*                       */65536;var TransitionLane12=/*                       */131072;var TransitionLane13=/*                       */262144;var TransitionLane14=/*                       */524288;var TransitionLane15=/*                       */1048576;var TransitionLane16=/*                       */2097152;var RetryLanes=/*                            */130023424;var RetryLane1=/*                             */4194304;var RetryLane2=/*                             */8388608;var RetryLane3=/*                             */16777216;var RetryLane4=/*                             */33554432;var RetryLane5=/*                             */67108864;var SomeRetryLane=RetryLane1;var SelectiveHydrationLane=/*          */134217728;var NonIdleLanes=/*                          */268435455;var IdleHydrationLane=/*               */268435456;var IdleLane=/*                        */536870912;var OffscreenLane=/*                   */1073741824;// This function is used for the experimental timeline (react-devtools-timeline)\n\t// It should be kept in sync with the Lanes values above.\n\tfunction getLabelForLane(lane){{if(lane&SyncLane){return 'Sync';}if(lane&InputContinuousHydrationLane){return 'InputContinuousHydration';}if(lane&InputContinuousLane){return 'InputContinuous';}if(lane&DefaultHydrationLane){return 'DefaultHydration';}if(lane&DefaultLane){return 'Default';}if(lane&TransitionHydrationLane){return 'TransitionHydration';}if(lane&TransitionLanes){return 'Transition';}if(lane&RetryLanes){return 'Retry';}if(lane&SelectiveHydrationLane){return 'SelectiveHydration';}if(lane&IdleHydrationLane){return 'IdleHydration';}if(lane&IdleLane){return 'Idle';}if(lane&OffscreenLane){return 'Offscreen';}}}var NoTimestamp=-1;var nextTransitionLane=TransitionLane1;var nextRetryLane=RetryLane1;function getHighestPriorityLanes(lanes){switch(getHighestPriorityLane(lanes)){case SyncLane:return SyncLane;case InputContinuousHydrationLane:return InputContinuousHydrationLane;case InputContinuousLane:return InputContinuousLane;case DefaultHydrationLane:return DefaultHydrationLane;case DefaultLane:return DefaultLane;case TransitionHydrationLane:return TransitionHydrationLane;case TransitionLane1:case TransitionLane2:case TransitionLane3:case TransitionLane4:case TransitionLane5:case TransitionLane6:case TransitionLane7:case TransitionLane8:case TransitionLane9:case TransitionLane10:case TransitionLane11:case TransitionLane12:case TransitionLane13:case TransitionLane14:case TransitionLane15:case TransitionLane16:return lanes&TransitionLanes;case RetryLane1:case RetryLane2:case RetryLane3:case RetryLane4:case RetryLane5:return lanes&RetryLanes;case SelectiveHydrationLane:return SelectiveHydrationLane;case IdleHydrationLane:return IdleHydrationLane;case IdleLane:return IdleLane;case OffscreenLane:return OffscreenLane;default:{error('Should have found matching lanes. This is a bug in React.');}// This shouldn't be reachable, but as a fallback, return the entire bitmask.\n\treturn lanes;}}function getNextLanes(root,wipLanes){// Early bailout if there's no pending work left.\n\tvar pendingLanes=root.pendingLanes;if(pendingLanes===NoLanes){return NoLanes;}var nextLanes=NoLanes;var suspendedLanes=root.suspendedLanes;var pingedLanes=root.pingedLanes;// Do not work on any idle work until all the non-idle work has finished,\n\t// even if the work is suspended.\n\tvar nonIdlePendingLanes=pendingLanes&NonIdleLanes;if(nonIdlePendingLanes!==NoLanes){var nonIdleUnblockedLanes=nonIdlePendingLanes&~suspendedLanes;if(nonIdleUnblockedLanes!==NoLanes){nextLanes=getHighestPriorityLanes(nonIdleUnblockedLanes);}else {var nonIdlePingedLanes=nonIdlePendingLanes&pingedLanes;if(nonIdlePingedLanes!==NoLanes){nextLanes=getHighestPriorityLanes(nonIdlePingedLanes);}}}else {// The only remaining work is Idle.\n\tvar unblockedLanes=pendingLanes&~suspendedLanes;if(unblockedLanes!==NoLanes){nextLanes=getHighestPriorityLanes(unblockedLanes);}else {if(pingedLanes!==NoLanes){nextLanes=getHighestPriorityLanes(pingedLanes);}}}if(nextLanes===NoLanes){// This should only be reachable if we're suspended\n\t// TODO: Consider warning in this path if a fallback timer is not scheduled.\n\treturn NoLanes;}// If we're already in the middle of a render, switching lanes will interrupt\n\t// it and we'll lose our progress. We should only do this if the new lanes are\n\t// higher priority.\n\tif(wipLanes!==NoLanes&&wipLanes!==nextLanes&&// If we already suspended with a delay, then interrupting is fine. Don't\n\t// bother waiting until the root is complete.\n\t(wipLanes&suspendedLanes)===NoLanes){var nextLane=getHighestPriorityLane(nextLanes);var wipLane=getHighestPriorityLane(wipLanes);if(// Tests whether the next lane is equal or lower priority than the wip\n\t// one. This works because the bits decrease in priority as you go left.\n\tnextLane>=wipLane||// Default priority updates should not interrupt transition updates. The\n\t// only difference between default updates and transition updates is that\n\t// default updates do not support refresh transitions.\n\tnextLane===DefaultLane&&(wipLane&TransitionLanes)!==NoLanes){// Keep working on the existing in-progress tree. Do not interrupt.\n\treturn wipLanes;}}if((nextLanes&InputContinuousLane)!==NoLanes){// When updates are sync by default, we entangle continuous priority updates\n\t// and default updates, so they render in the same batch. The only reason\n\t// they use separate lanes is because continuous updates should interrupt\n\t// transitions, but default updates should not.\n\tnextLanes|=pendingLanes&DefaultLane;}// Check for entangled lanes and add them to the batch.\n\t//\n\t// A lane is said to be entangled with another when it's not allowed to render\n\t// in a batch that does not also include the other lane. Typically we do this\n\t// when multiple updates have the same source, and we only want to respond to\n\t// the most recent event from that source.\n\t//\n\t// Note that we apply entanglements *after* checking for partial work above.\n\t// This means that if a lane is entangled during an interleaved event while\n\t// it's already rendering, we won't interrupt it. This is intentional, since\n\t// entanglement is usually \"best effort\": we'll try our best to render the\n\t// lanes in the same batch, but it's not worth throwing out partially\n\t// completed work in order to do it.\n\t// TODO: Reconsider this. The counter-argument is that the partial work\n\t// represents an intermediate state, which we don't want to show to the user.\n\t// And by spending extra time finishing it, we're increasing the amount of\n\t// time it takes to show the final state, which is what they are actually\n\t// waiting for.\n\t//\n\t// For those exceptions where entanglement is semantically important, like\n\t// useMutableSource, we should ensure that there is no partial work at the\n\t// time we apply the entanglement.\n\tvar entangledLanes=root.entangledLanes;if(entangledLanes!==NoLanes){var entanglements=root.entanglements;var lanes=nextLanes&entangledLanes;while(lanes>0){var index=pickArbitraryLaneIndex(lanes);var lane=1<<index;nextLanes|=entanglements[index];lanes&=~lane;}}return nextLanes;}function getMostRecentEventTime(root,lanes){var eventTimes=root.eventTimes;var mostRecentEventTime=NoTimestamp;while(lanes>0){var index=pickArbitraryLaneIndex(lanes);var lane=1<<index;var eventTime=eventTimes[index];if(eventTime>mostRecentEventTime){mostRecentEventTime=eventTime;}lanes&=~lane;}return mostRecentEventTime;}function computeExpirationTime(lane,currentTime){switch(lane){case SyncLane:case InputContinuousHydrationLane:case InputContinuousLane:// User interactions should expire slightly more quickly.\n\t//\n\t// NOTE: This is set to the corresponding constant as in Scheduler.js.\n\t// When we made it larger, a product metric in www regressed, suggesting\n\t// there's a user interaction that's being starved by a series of\n\t// synchronous updates. If that theory is correct, the proper solution is\n\t// to fix the starvation. However, this scenario supports the idea that\n\t// expiration times are an important safeguard when starvation\n\t// does happen.\n\treturn currentTime+250;case DefaultHydrationLane:case DefaultLane:case TransitionHydrationLane:case TransitionLane1:case TransitionLane2:case TransitionLane3:case TransitionLane4:case TransitionLane5:case TransitionLane6:case TransitionLane7:case TransitionLane8:case TransitionLane9:case TransitionLane10:case TransitionLane11:case TransitionLane12:case TransitionLane13:case TransitionLane14:case TransitionLane15:case TransitionLane16:return currentTime+5000;case RetryLane1:case RetryLane2:case RetryLane3:case RetryLane4:case RetryLane5:// TODO: Retries should be allowed to expire if they are CPU bound for\n\t// too long, but when I made this change it caused a spike in browser\n\t// crashes. There must be some other underlying bug; not super urgent but\n\t// ideally should figure out why and fix it. Unfortunately we don't have\n\t// a repro for the crashes, only detected via production metrics.\n\treturn NoTimestamp;case SelectiveHydrationLane:case IdleHydrationLane:case IdleLane:case OffscreenLane:// Anything idle priority or lower should never expire.\n\treturn NoTimestamp;default:{error('Should have found matching lanes. This is a bug in React.');}return NoTimestamp;}}function markStarvedLanesAsExpired(root,currentTime){// TODO: This gets called every time we yield. We can optimize by storing\n\t// the earliest expiration time on the root. Then use that to quickly bail out\n\t// of this function.\n\tvar pendingLanes=root.pendingLanes;var suspendedLanes=root.suspendedLanes;var pingedLanes=root.pingedLanes;var expirationTimes=root.expirationTimes;// Iterate through the pending lanes and check if we've reached their\n\t// expiration time. If so, we'll assume the update is being starved and mark\n\t// it as expired to force it to finish.\n\tvar lanes=pendingLanes;while(lanes>0){var index=pickArbitraryLaneIndex(lanes);var lane=1<<index;var expirationTime=expirationTimes[index];if(expirationTime===NoTimestamp){// Found a pending lane with no expiration time. If it's not suspended, or\n\t// if it's pinged, assume it's CPU-bound. Compute a new expiration time\n\t// using the current time.\n\tif((lane&suspendedLanes)===NoLanes||(lane&pingedLanes)!==NoLanes){// Assumes timestamps are monotonically increasing.\n\texpirationTimes[index]=computeExpirationTime(lane,currentTime);}}else if(expirationTime<=currentTime){// This lane expired\n\troot.expiredLanes|=lane;}lanes&=~lane;}}// This returns the highest priority pending lanes regardless of whether they\n\t// are suspended.\n\tfunction getHighestPriorityPendingLanes(root){return getHighestPriorityLanes(root.pendingLanes);}function getLanesToRetrySynchronouslyOnError(root){var everythingButOffscreen=root.pendingLanes&~OffscreenLane;if(everythingButOffscreen!==NoLanes){return everythingButOffscreen;}if(everythingButOffscreen&OffscreenLane){return OffscreenLane;}return NoLanes;}function includesSyncLane(lanes){return (lanes&SyncLane)!==NoLanes;}function includesNonIdleWork(lanes){return (lanes&NonIdleLanes)!==NoLanes;}function includesOnlyRetries(lanes){return (lanes&RetryLanes)===lanes;}function includesOnlyNonUrgentLanes(lanes){var UrgentLanes=SyncLane|InputContinuousLane|DefaultLane;return (lanes&UrgentLanes)===NoLanes;}function includesOnlyTransitions(lanes){return (lanes&TransitionLanes)===lanes;}function includesBlockingLane(root,lanes){var SyncDefaultLanes=InputContinuousHydrationLane|InputContinuousLane|DefaultHydrationLane|DefaultLane;return (lanes&SyncDefaultLanes)!==NoLanes;}function includesExpiredLane(root,lanes){// This is a separate check from includesBlockingLane because a lane can\n\t// expire after a render has already started.\n\treturn (lanes&root.expiredLanes)!==NoLanes;}function isTransitionLane(lane){return (lane&TransitionLanes)!==NoLanes;}function claimNextTransitionLane(){// Cycle through the lanes, assigning each new transition to the next lane.\n\t// In most cases, this means every transition gets its own lane, until we\n\t// run out of lanes and cycle back to the beginning.\n\tvar lane=nextTransitionLane;nextTransitionLane<<=1;if((nextTransitionLane&TransitionLanes)===NoLanes){nextTransitionLane=TransitionLane1;}return lane;}function claimNextRetryLane(){var lane=nextRetryLane;nextRetryLane<<=1;if((nextRetryLane&RetryLanes)===NoLanes){nextRetryLane=RetryLane1;}return lane;}function getHighestPriorityLane(lanes){return lanes&-lanes;}function pickArbitraryLane(lanes){// This wrapper function gets inlined. Only exists so to communicate that it\n\t// doesn't matter which bit is selected; you can pick any bit without\n\t// affecting the algorithms where its used. Here I'm using\n\t// getHighestPriorityLane because it requires the fewest operations.\n\treturn getHighestPriorityLane(lanes);}function pickArbitraryLaneIndex(lanes){return 31-clz32(lanes);}function laneToIndex(lane){return pickArbitraryLaneIndex(lane);}function includesSomeLane(a,b){return (a&b)!==NoLanes;}function isSubsetOfLanes(set,subset){return (set&subset)===subset;}function mergeLanes(a,b){return a|b;}function removeLanes(set,subset){return set&~subset;}function intersectLanes(a,b){return a&b;}// Seems redundant, but it changes the type from a single lane (used for\n\t// updates) to a group of lanes (used for flushing work).\n\tfunction laneToLanes(lane){return lane;}function higherPriorityLane(a,b){// This works because the bit ranges decrease in priority as you go left.\n\treturn a!==NoLane&&a<b?a:b;}function createLaneMap(initial){// Intentionally pushing one by one.\n\t// https://v8.dev/blog/elements-kinds#avoid-creating-holes\n\tvar laneMap=[];for(var i=0;i<TotalLanes;i++){laneMap.push(initial);}return laneMap;}function markRootUpdated(root,updateLane,eventTime){root.pendingLanes|=updateLane;// If there are any suspended transitions, it's possible this new update\n\t// could unblock them. Clear the suspended lanes so that we can try rendering\n\t// them again.\n\t//\n\t// TODO: We really only need to unsuspend only lanes that are in the\n\t// `subtreeLanes` of the updated fiber, or the update lanes of the return\n\t// path. This would exclude suspended updates in an unrelated sibling tree,\n\t// since there's no way for this update to unblock it.\n\t//\n\t// We don't do this if the incoming update is idle, because we never process\n\t// idle updates until after all the regular updates have finished; there's no\n\t// way it could unblock a transition.\n\tif(updateLane!==IdleLane){root.suspendedLanes=NoLanes;root.pingedLanes=NoLanes;}var eventTimes=root.eventTimes;var index=laneToIndex(updateLane);// We can always overwrite an existing timestamp because we prefer the most\n\t// recent event, and we assume time is monotonically increasing.\n\teventTimes[index]=eventTime;}function markRootSuspended(root,suspendedLanes){root.suspendedLanes|=suspendedLanes;root.pingedLanes&=~suspendedLanes;// The suspended lanes are no longer CPU-bound. Clear their expiration times.\n\tvar expirationTimes=root.expirationTimes;var lanes=suspendedLanes;while(lanes>0){var index=pickArbitraryLaneIndex(lanes);var lane=1<<index;expirationTimes[index]=NoTimestamp;lanes&=~lane;}}function markRootPinged(root,pingedLanes,eventTime){root.pingedLanes|=root.suspendedLanes&pingedLanes;}function markRootFinished(root,remainingLanes){var noLongerPendingLanes=root.pendingLanes&~remainingLanes;root.pendingLanes=remainingLanes;// Let's try everything again\n\troot.suspendedLanes=NoLanes;root.pingedLanes=NoLanes;root.expiredLanes&=remainingLanes;root.mutableReadLanes&=remainingLanes;root.entangledLanes&=remainingLanes;var entanglements=root.entanglements;var eventTimes=root.eventTimes;var expirationTimes=root.expirationTimes;// Clear the lanes that no longer have pending work\n\tvar lanes=noLongerPendingLanes;while(lanes>0){var index=pickArbitraryLaneIndex(lanes);var lane=1<<index;entanglements[index]=NoLanes;eventTimes[index]=NoTimestamp;expirationTimes[index]=NoTimestamp;lanes&=~lane;}}function markRootEntangled(root,entangledLanes){// In addition to entangling each of the given lanes with each other, we also\n\t// have to consider _transitive_ entanglements. For each lane that is already\n\t// entangled with *any* of the given lanes, that lane is now transitively\n\t// entangled with *all* the given lanes.\n\t//\n\t// Translated: If C is entangled with A, then entangling A with B also\n\t// entangles C with B.\n\t//\n\t// If this is hard to grasp, it might help to intentionally break this\n\t// function and look at the tests that fail in ReactTransition-test.js. Try\n\t// commenting out one of the conditions below.\n\tvar rootEntangledLanes=root.entangledLanes|=entangledLanes;var entanglements=root.entanglements;var lanes=rootEntangledLanes;while(lanes){var index=pickArbitraryLaneIndex(lanes);var lane=1<<index;if(// Is this one of the newly entangled lanes?\n\tlane&entangledLanes|// Is this lane transitively entangled with the newly entangled lanes?\n\tentanglements[index]&entangledLanes){entanglements[index]|=entangledLanes;}lanes&=~lane;}}function getBumpedLaneForHydration(root,renderLanes){var renderLane=getHighestPriorityLane(renderLanes);var lane;switch(renderLane){case InputContinuousLane:lane=InputContinuousHydrationLane;break;case DefaultLane:lane=DefaultHydrationLane;break;case TransitionLane1:case TransitionLane2:case TransitionLane3:case TransitionLane4:case TransitionLane5:case TransitionLane6:case TransitionLane7:case TransitionLane8:case TransitionLane9:case TransitionLane10:case TransitionLane11:case TransitionLane12:case TransitionLane13:case TransitionLane14:case TransitionLane15:case TransitionLane16:case RetryLane1:case RetryLane2:case RetryLane3:case RetryLane4:case RetryLane5:lane=TransitionHydrationLane;break;case IdleLane:lane=IdleHydrationLane;break;default:// Everything else is already either a hydration lane, or shouldn't\n\t// be retried at a hydration lane.\n\tlane=NoLane;break;}// Check if the lane we chose is suspended. If so, that indicates that we\n\t// already attempted and failed to hydrate at that level. Also check if we're\n\t// already rendering that lane, which is rare but could happen.\n\tif((lane&(root.suspendedLanes|renderLanes))!==NoLane){// Give up trying to hydrate and fall back to client render.\n\treturn NoLane;}return lane;}function addFiberToLanesMap(root,fiber,lanes){if(!isDevToolsPresent){return;}var pendingUpdatersLaneMap=root.pendingUpdatersLaneMap;while(lanes>0){var index=laneToIndex(lanes);var lane=1<<index;var updaters=pendingUpdatersLaneMap[index];updaters.add(fiber);lanes&=~lane;}}function movePendingFibersToMemoized(root,lanes){if(!isDevToolsPresent){return;}var pendingUpdatersLaneMap=root.pendingUpdatersLaneMap;var memoizedUpdaters=root.memoizedUpdaters;while(lanes>0){var index=laneToIndex(lanes);var lane=1<<index;var updaters=pendingUpdatersLaneMap[index];if(updaters.size>0){updaters.forEach(function(fiber){var alternate=fiber.alternate;if(alternate===null||!memoizedUpdaters.has(alternate)){memoizedUpdaters.add(fiber);}});updaters.clear();}lanes&=~lane;}}function getTransitionsForLanes(root,lanes){{return null;}}var DiscreteEventPriority=SyncLane;var ContinuousEventPriority=InputContinuousLane;var DefaultEventPriority=DefaultLane;var IdleEventPriority=IdleLane;var currentUpdatePriority=NoLane;function getCurrentUpdatePriority(){return currentUpdatePriority;}function setCurrentUpdatePriority(newPriority){currentUpdatePriority=newPriority;}function runWithPriority(priority,fn){var previousPriority=currentUpdatePriority;try{currentUpdatePriority=priority;return fn();}finally{currentUpdatePriority=previousPriority;}}function higherEventPriority(a,b){return a!==0&&a<b?a:b;}function lowerEventPriority(a,b){return a===0||a>b?a:b;}function isHigherEventPriority(a,b){return a!==0&&a<b;}function lanesToEventPriority(lanes){var lane=getHighestPriorityLane(lanes);if(!isHigherEventPriority(DiscreteEventPriority,lane)){return DiscreteEventPriority;}if(!isHigherEventPriority(ContinuousEventPriority,lane)){return ContinuousEventPriority;}if(includesNonIdleWork(lane)){return DefaultEventPriority;}return IdleEventPriority;}// This is imported by the event replaying implementation in React DOM. It's\n\t// in a separate file to break a circular dependency between the renderer and\n\t// the reconciler.\n\tfunction isRootDehydrated(root){var currentState=root.current.memoizedState;return currentState.isDehydrated;}var _attemptSynchronousHydration;function setAttemptSynchronousHydration(fn){_attemptSynchronousHydration=fn;}function attemptSynchronousHydration(fiber){_attemptSynchronousHydration(fiber);}var attemptContinuousHydration;function setAttemptContinuousHydration(fn){attemptContinuousHydration=fn;}var attemptHydrationAtCurrentPriority;function setAttemptHydrationAtCurrentPriority(fn){attemptHydrationAtCurrentPriority=fn;}var getCurrentUpdatePriority$1;function setGetCurrentUpdatePriority(fn){getCurrentUpdatePriority$1=fn;}var attemptHydrationAtPriority;function setAttemptHydrationAtPriority(fn){attemptHydrationAtPriority=fn;}// TODO: Upgrade this definition once we're on a newer version of Flow that\n\t// has this definition built-in.\n\tvar hasScheduledReplayAttempt=false;// The queue of discrete events to be replayed.\n\tvar queuedDiscreteEvents=[];// Indicates if any continuous event targets are non-null for early bailout.\n\t// if the last target was dehydrated.\n\tvar queuedFocus=null;var queuedDrag=null;var queuedMouse=null;// For pointer events there can be one latest event per pointerId.\n\tvar queuedPointers=new Map();var queuedPointerCaptures=new Map();// We could consider replaying selectionchange and touchmoves too.\n\tvar queuedExplicitHydrationTargets=[];var discreteReplayableEvents=['mousedown','mouseup','touchcancel','touchend','touchstart','auxclick','dblclick','pointercancel','pointerdown','pointerup','dragend','dragstart','drop','compositionend','compositionstart','keydown','keypress','keyup','input','textInput',// Intentionally camelCase\n\t'copy','cut','paste','click','change','contextmenu','reset','submit'];function isDiscreteEventThatRequiresHydration(eventType){return discreteReplayableEvents.indexOf(eventType)>-1;}function createQueuedReplayableEvent(blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent){return {blockedOn:blockedOn,domEventName:domEventName,eventSystemFlags:eventSystemFlags,nativeEvent:nativeEvent,targetContainers:[targetContainer]};}function clearIfContinuousEvent(domEventName,nativeEvent){switch(domEventName){case'focusin':case'focusout':queuedFocus=null;break;case'dragenter':case'dragleave':queuedDrag=null;break;case'mouseover':case'mouseout':queuedMouse=null;break;case'pointerover':case'pointerout':{var pointerId=nativeEvent.pointerId;queuedPointers.delete(pointerId);break;}case'gotpointercapture':case'lostpointercapture':{var _pointerId=nativeEvent.pointerId;queuedPointerCaptures.delete(_pointerId);break;}}}function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent,blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent){if(existingQueuedEvent===null||existingQueuedEvent.nativeEvent!==nativeEvent){var queuedEvent=createQueuedReplayableEvent(blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent);if(blockedOn!==null){var _fiber2=getInstanceFromNode(blockedOn);if(_fiber2!==null){// Attempt to increase the priority of this target.\n\tattemptContinuousHydration(_fiber2);}}return queuedEvent;}// If we have already queued this exact event, then it's because\n\t// the different event systems have different DOM event listeners.\n\t// We can accumulate the flags, and the targetContainers, and\n\t// store a single event to be replayed.\n\texistingQueuedEvent.eventSystemFlags|=eventSystemFlags;var targetContainers=existingQueuedEvent.targetContainers;if(targetContainer!==null&&targetContainers.indexOf(targetContainer)===-1){targetContainers.push(targetContainer);}return existingQueuedEvent;}function queueIfContinuousEvent(blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent){// These set relatedTarget to null because the replayed event will be treated as if we\n\t// moved from outside the window (no target) onto the target once it hydrates.\n\t// Instead of mutating we could clone the event.\n\tswitch(domEventName){case'focusin':{var focusEvent=nativeEvent;queuedFocus=accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus,blockedOn,domEventName,eventSystemFlags,targetContainer,focusEvent);return true;}case'dragenter':{var dragEvent=nativeEvent;queuedDrag=accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag,blockedOn,domEventName,eventSystemFlags,targetContainer,dragEvent);return true;}case'mouseover':{var mouseEvent=nativeEvent;queuedMouse=accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse,blockedOn,domEventName,eventSystemFlags,targetContainer,mouseEvent);return true;}case'pointerover':{var pointerEvent=nativeEvent;var pointerId=pointerEvent.pointerId;queuedPointers.set(pointerId,accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId)||null,blockedOn,domEventName,eventSystemFlags,targetContainer,pointerEvent));return true;}case'gotpointercapture':{var _pointerEvent=nativeEvent;var _pointerId2=_pointerEvent.pointerId;queuedPointerCaptures.set(_pointerId2,accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(_pointerId2)||null,blockedOn,domEventName,eventSystemFlags,targetContainer,_pointerEvent));return true;}}return false;}// Check if this target is unblocked. Returns true if it's unblocked.\n\tfunction attemptExplicitHydrationTarget(queuedTarget){// TODO: This function shares a lot of logic with findInstanceBlockingEvent.\n\t// Try to unify them. It's a bit tricky since it would require two return\n\t// values.\n\tvar targetInst=getClosestInstanceFromNode(queuedTarget.target);if(targetInst!==null){var nearestMounted=getNearestMountedFiber(targetInst);if(nearestMounted!==null){var tag=nearestMounted.tag;if(tag===SuspenseComponent){var instance=getSuspenseInstanceFromFiber(nearestMounted);if(instance!==null){// We're blocked on hydrating this boundary.\n\t// Increase its priority.\n\tqueuedTarget.blockedOn=instance;attemptHydrationAtPriority(queuedTarget.priority,function(){attemptHydrationAtCurrentPriority(nearestMounted);});return;}}else if(tag===HostRoot){var root=nearestMounted.stateNode;if(isRootDehydrated(root)){queuedTarget.blockedOn=getContainerFromFiber(nearestMounted);// We don't currently have a way to increase the priority of\n\t// a root other than sync.\n\treturn;}}}}queuedTarget.blockedOn=null;}function queueExplicitHydrationTarget(target){// TODO: This will read the priority if it's dispatched by the React\n\t// event system but not native events. Should read window.event.type, like\n\t// we do for updates (getCurrentEventPriority).\n\tvar updatePriority=getCurrentUpdatePriority$1();var queuedTarget={blockedOn:null,target:target,priority:updatePriority};var i=0;for(;i<queuedExplicitHydrationTargets.length;i++){// Stop once we hit the first target with lower priority than\n\tif(!isHigherEventPriority(updatePriority,queuedExplicitHydrationTargets[i].priority)){break;}}queuedExplicitHydrationTargets.splice(i,0,queuedTarget);if(i===0){attemptExplicitHydrationTarget(queuedTarget);}}function attemptReplayContinuousQueuedEvent(queuedEvent){if(queuedEvent.blockedOn!==null){return false;}var targetContainers=queuedEvent.targetContainers;while(targetContainers.length>0){var targetContainer=targetContainers[0];var nextBlockedOn=findInstanceBlockingEvent(queuedEvent.domEventName,queuedEvent.eventSystemFlags,targetContainer,queuedEvent.nativeEvent);if(nextBlockedOn===null){{var nativeEvent=queuedEvent.nativeEvent;var nativeEventClone=new nativeEvent.constructor(nativeEvent.type,nativeEvent);setReplayingEvent(nativeEventClone);nativeEvent.target.dispatchEvent(nativeEventClone);resetReplayingEvent();}}else {// We're still blocked. Try again later.\n\tvar _fiber3=getInstanceFromNode(nextBlockedOn);if(_fiber3!==null){attemptContinuousHydration(_fiber3);}queuedEvent.blockedOn=nextBlockedOn;return false;}// This target container was successfully dispatched. Try the next.\n\ttargetContainers.shift();}return true;}function attemptReplayContinuousQueuedEventInMap(queuedEvent,key,map){if(attemptReplayContinuousQueuedEvent(queuedEvent)){map.delete(key);}}function replayUnblockedEvents(){hasScheduledReplayAttempt=false;if(queuedFocus!==null&&attemptReplayContinuousQueuedEvent(queuedFocus)){queuedFocus=null;}if(queuedDrag!==null&&attemptReplayContinuousQueuedEvent(queuedDrag)){queuedDrag=null;}if(queuedMouse!==null&&attemptReplayContinuousQueuedEvent(queuedMouse)){queuedMouse=null;}queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);}function scheduleCallbackIfUnblocked(queuedEvent,unblocked){if(queuedEvent.blockedOn===unblocked){queuedEvent.blockedOn=null;if(!hasScheduledReplayAttempt){hasScheduledReplayAttempt=true;// Schedule a callback to attempt replaying as many events as are\n\t// now unblocked. This first might not actually be unblocked yet.\n\t// We could check it early to avoid scheduling an unnecessary callback.\n\tScheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority,replayUnblockedEvents);}}}function retryIfBlockedOn(unblocked){// Mark anything that was blocked on this as no longer blocked\n\t// and eligible for a replay.\n\tif(queuedDiscreteEvents.length>0){scheduleCallbackIfUnblocked(queuedDiscreteEvents[0],unblocked);// This is a exponential search for each boundary that commits. I think it's\n\t// worth it because we expect very few discrete events to queue up and once\n\t// we are actually fully unblocked it will be fast to replay them.\n\tfor(var i=1;i<queuedDiscreteEvents.length;i++){var queuedEvent=queuedDiscreteEvents[i];if(queuedEvent.blockedOn===unblocked){queuedEvent.blockedOn=null;}}}if(queuedFocus!==null){scheduleCallbackIfUnblocked(queuedFocus,unblocked);}if(queuedDrag!==null){scheduleCallbackIfUnblocked(queuedDrag,unblocked);}if(queuedMouse!==null){scheduleCallbackIfUnblocked(queuedMouse,unblocked);}var unblock=function(queuedEvent){return scheduleCallbackIfUnblocked(queuedEvent,unblocked);};queuedPointers.forEach(unblock);queuedPointerCaptures.forEach(unblock);for(var _i=0;_i<queuedExplicitHydrationTargets.length;_i++){var queuedTarget=queuedExplicitHydrationTargets[_i];if(queuedTarget.blockedOn===unblocked){queuedTarget.blockedOn=null;}}while(queuedExplicitHydrationTargets.length>0){var nextExplicitTarget=queuedExplicitHydrationTargets[0];if(nextExplicitTarget.blockedOn!==null){// We're still blocked.\n\tbreak;}else {attemptExplicitHydrationTarget(nextExplicitTarget);if(nextExplicitTarget.blockedOn===null){// We're unblocked.\n\tqueuedExplicitHydrationTargets.shift();}}}}var ReactCurrentBatchConfig=ReactSharedInternals.ReactCurrentBatchConfig;// TODO: can we stop exporting these?\n\tvar _enabled=true;// This is exported in FB builds for use by legacy FB layer infra.\n\t// We'd like to remove this but it's not clear if this is safe.\n\tfunction setEnabled(enabled){_enabled=!!enabled;}function isEnabled(){return _enabled;}function createEventListenerWrapperWithPriority(targetContainer,domEventName,eventSystemFlags){var eventPriority=getEventPriority(domEventName);var listenerWrapper;switch(eventPriority){case DiscreteEventPriority:listenerWrapper=dispatchDiscreteEvent;break;case ContinuousEventPriority:listenerWrapper=dispatchContinuousEvent;break;case DefaultEventPriority:default:listenerWrapper=dispatchEvent;break;}return listenerWrapper.bind(null,domEventName,eventSystemFlags,targetContainer);}function dispatchDiscreteEvent(domEventName,eventSystemFlags,container,nativeEvent){var previousPriority=getCurrentUpdatePriority();var prevTransition=ReactCurrentBatchConfig.transition;ReactCurrentBatchConfig.transition=null;try{setCurrentUpdatePriority(DiscreteEventPriority);dispatchEvent(domEventName,eventSystemFlags,container,nativeEvent);}finally{setCurrentUpdatePriority(previousPriority);ReactCurrentBatchConfig.transition=prevTransition;}}function dispatchContinuousEvent(domEventName,eventSystemFlags,container,nativeEvent){var previousPriority=getCurrentUpdatePriority();var prevTransition=ReactCurrentBatchConfig.transition;ReactCurrentBatchConfig.transition=null;try{setCurrentUpdatePriority(ContinuousEventPriority);dispatchEvent(domEventName,eventSystemFlags,container,nativeEvent);}finally{setCurrentUpdatePriority(previousPriority);ReactCurrentBatchConfig.transition=prevTransition;}}function dispatchEvent(domEventName,eventSystemFlags,targetContainer,nativeEvent){if(!_enabled){return;}{dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName,eventSystemFlags,targetContainer,nativeEvent);}}function dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName,eventSystemFlags,targetContainer,nativeEvent){var blockedOn=findInstanceBlockingEvent(domEventName,eventSystemFlags,targetContainer,nativeEvent);if(blockedOn===null){dispatchEventForPluginEventSystem(domEventName,eventSystemFlags,nativeEvent,return_targetInst,targetContainer);clearIfContinuousEvent(domEventName,nativeEvent);return;}if(queueIfContinuousEvent(blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent)){nativeEvent.stopPropagation();return;}// We need to clear only if we didn't queue because\n\t// queueing is accumulative.\n\tclearIfContinuousEvent(domEventName,nativeEvent);if(eventSystemFlags&IS_CAPTURE_PHASE&&isDiscreteEventThatRequiresHydration(domEventName)){while(blockedOn!==null){var fiber=getInstanceFromNode(blockedOn);if(fiber!==null){attemptSynchronousHydration(fiber);}var nextBlockedOn=findInstanceBlockingEvent(domEventName,eventSystemFlags,targetContainer,nativeEvent);if(nextBlockedOn===null){dispatchEventForPluginEventSystem(domEventName,eventSystemFlags,nativeEvent,return_targetInst,targetContainer);}if(nextBlockedOn===blockedOn){break;}blockedOn=nextBlockedOn;}if(blockedOn!==null){nativeEvent.stopPropagation();}return;}// This is not replayable so we'll invoke it but without a target,\n\t// in case the event system needs to trace it.\n\tdispatchEventForPluginEventSystem(domEventName,eventSystemFlags,nativeEvent,null,targetContainer);}var return_targetInst=null;// Returns a SuspenseInstance or Container if it's blocked.\n\t// The return_targetInst field above is conceptually part of the return value.\n\tfunction findInstanceBlockingEvent(domEventName,eventSystemFlags,targetContainer,nativeEvent){// TODO: Warn if _enabled is false.\n\treturn_targetInst=null;var nativeEventTarget=getEventTarget(nativeEvent);var targetInst=getClosestInstanceFromNode(nativeEventTarget);if(targetInst!==null){var nearestMounted=getNearestMountedFiber(targetInst);if(nearestMounted===null){// This tree has been unmounted already. Dispatch without a target.\n\ttargetInst=null;}else {var tag=nearestMounted.tag;if(tag===SuspenseComponent){var instance=getSuspenseInstanceFromFiber(nearestMounted);if(instance!==null){// Queue the event to be replayed later. Abort dispatching since we\n\t// don't want this event dispatched twice through the event system.\n\t// TODO: If this is the first discrete event in the queue. Schedule an increased\n\t// priority for this boundary.\n\treturn instance;}// This shouldn't happen, something went wrong but to avoid blocking\n\t// the whole system, dispatch the event without a target.\n\t// TODO: Warn.\n\ttargetInst=null;}else if(tag===HostRoot){var root=nearestMounted.stateNode;if(isRootDehydrated(root)){// If this happens during a replay something went wrong and it might block\n\t// the whole system.\n\treturn getContainerFromFiber(nearestMounted);}targetInst=null;}else if(nearestMounted!==targetInst){// If we get an event (ex: img onload) before committing that\n\t// component's mount, ignore it for now (that is, treat it as if it was an\n\t// event on a non-React tree). We might also consider queueing events and\n\t// dispatching them after the mount.\n\ttargetInst=null;}}}return_targetInst=targetInst;// We're not blocked on anything.\n\treturn null;}function getEventPriority(domEventName){switch(domEventName){// Used by SimpleEventPlugin:\n\tcase'cancel':case'click':case'close':case'contextmenu':case'copy':case'cut':case'auxclick':case'dblclick':case'dragend':case'dragstart':case'drop':case'focusin':case'focusout':case'input':case'invalid':case'keydown':case'keypress':case'keyup':case'mousedown':case'mouseup':case'paste':case'pause':case'play':case'pointercancel':case'pointerdown':case'pointerup':case'ratechange':case'reset':case'resize':case'seeked':case'submit':case'touchcancel':case'touchend':case'touchstart':case'volumechange':// Used by polyfills:\n\t// eslint-disable-next-line no-fallthrough\n\tcase'change':case'selectionchange':case'textInput':case'compositionstart':case'compositionend':case'compositionupdate':// Only enableCreateEventHandleAPI:\n\t// eslint-disable-next-line no-fallthrough\n\tcase'beforeblur':case'afterblur':// Not used by React but could be by user code:\n\t// eslint-disable-next-line no-fallthrough\n\tcase'beforeinput':case'blur':case'fullscreenchange':case'focus':case'hashchange':case'popstate':case'select':case'selectstart':return DiscreteEventPriority;case'drag':case'dragenter':case'dragexit':case'dragleave':case'dragover':case'mousemove':case'mouseout':case'mouseover':case'pointermove':case'pointerout':case'pointerover':case'scroll':case'toggle':case'touchmove':case'wheel':// Not used by React but could be by user code:\n\t// eslint-disable-next-line no-fallthrough\n\tcase'mouseenter':case'mouseleave':case'pointerenter':case'pointerleave':return ContinuousEventPriority;case'message':{// We might be in the Scheduler callback.\n\t// Eventually this mechanism will be replaced by a check\n\t// of the current priority on the native scheduler.\n\tvar schedulerPriority=getCurrentPriorityLevel();switch(schedulerPriority){case ImmediatePriority:return DiscreteEventPriority;case UserBlockingPriority:return ContinuousEventPriority;case NormalPriority:case LowPriority:// TODO: Handle LowSchedulerPriority, somehow. Maybe the same lane as hydration.\n\treturn DefaultEventPriority;case IdlePriority:return IdleEventPriority;default:return DefaultEventPriority;}}default:return DefaultEventPriority;}}function addEventBubbleListener(target,eventType,listener){target.addEventListener(eventType,listener,false);return listener;}function addEventCaptureListener(target,eventType,listener){target.addEventListener(eventType,listener,true);return listener;}function addEventCaptureListenerWithPassiveFlag(target,eventType,listener,passive){target.addEventListener(eventType,listener,{capture:true,passive:passive});return listener;}function addEventBubbleListenerWithPassiveFlag(target,eventType,listener,passive){target.addEventListener(eventType,listener,{passive:passive});return listener;}/**\n\t * These variables store information about text content of a target node,\n\t * allowing comparison of content before and after a given event.\n\t *\n\t * Identify the node where selection currently begins, then observe\n\t * both its text content and its current position in the DOM. Since the\n\t * browser may natively replace the target node during composition, we can\n\t * use its position to find its replacement.\n\t *\n\t *\n\t */var root=null;var startText=null;var fallbackText=null;function initialize(nativeEventTarget){root=nativeEventTarget;startText=getText();return true;}function reset(){root=null;startText=null;fallbackText=null;}function getData(){if(fallbackText){return fallbackText;}var start;var startValue=startText;var startLength=startValue.length;var end;var endValue=getText();var endLength=endValue.length;for(start=0;start<startLength;start++){if(startValue[start]!==endValue[start]){break;}}var minEnd=startLength-start;for(end=1;end<=minEnd;end++){if(startValue[startLength-end]!==endValue[endLength-end]){break;}}var sliceTail=end>1?1-end:undefined;fallbackText=endValue.slice(start,sliceTail);return fallbackText;}function getText(){if('value'in root){return root.value;}return root.textContent;}/**\n\t * `charCode` represents the actual \"character code\" and is safe to use with\n\t * `String.fromCharCode`. As such, only keys that correspond to printable\n\t * characters produce a valid `charCode`, the only exception to this is Enter.\n\t * The Tab-key is considered non-printable and does not have a `charCode`,\n\t * presumably because it does not produce a tab-character in browsers.\n\t *\n\t * @param {object} nativeEvent Native browser event.\n\t * @return {number} Normalized `charCode` property.\n\t */function getEventCharCode(nativeEvent){var charCode;var keyCode=nativeEvent.keyCode;if('charCode'in nativeEvent){charCode=nativeEvent.charCode;// FF does not set `charCode` for the Enter-key, check against `keyCode`.\n\tif(charCode===0&&keyCode===13){charCode=13;}}else {// IE8 does not implement `charCode`, but `keyCode` has the correct value.\n\tcharCode=keyCode;}// IE and Edge (on Windows) and Chrome / Safari (on Windows and Linux)\n\t// report Enter as charCode 10 when ctrl is pressed.\n\tif(charCode===10){charCode=13;}// Some non-printable keys are reported in `charCode`/`keyCode`, discard them.\n\t// Must not discard the (non-)printable Enter-key.\n\tif(charCode>=32||charCode===13){return charCode;}return 0;}function functionThatReturnsTrue(){return true;}function functionThatReturnsFalse(){return false;}// This is intentionally a factory so that we have different returned constructors.\n\t// If we had a single constructor, it would be megamorphic and engines would deopt.\n\tfunction createSyntheticEvent(Interface){/**\n\t   * Synthetic events are dispatched by event plugins, typically in response to a\n\t   * top-level event delegation handler.\n\t   *\n\t   * These systems should generally use pooling to reduce the frequency of garbage\n\t   * collection. The system should check `isPersistent` to determine whether the\n\t   * event should be released into the pool after being dispatched. Users that\n\t   * need a persisted event should invoke `persist`.\n\t   *\n\t   * Synthetic events (and subclasses) implement the DOM Level 3 Events API by\n\t   * normalizing browser quirks. Subclasses do not necessarily have to implement a\n\t   * DOM interface; custom application-specific events can also subclass this.\n\t   */function SyntheticBaseEvent(reactName,reactEventType,targetInst,nativeEvent,nativeEventTarget){this._reactName=reactName;this._targetInst=targetInst;this.type=reactEventType;this.nativeEvent=nativeEvent;this.target=nativeEventTarget;this.currentTarget=null;for(var _propName in Interface){if(!Interface.hasOwnProperty(_propName)){continue;}var normalize=Interface[_propName];if(normalize){this[_propName]=normalize(nativeEvent);}else {this[_propName]=nativeEvent[_propName];}}var defaultPrevented=nativeEvent.defaultPrevented!=null?nativeEvent.defaultPrevented:nativeEvent.returnValue===false;if(defaultPrevented){this.isDefaultPrevented=functionThatReturnsTrue;}else {this.isDefaultPrevented=functionThatReturnsFalse;}this.isPropagationStopped=functionThatReturnsFalse;return this;}assign(SyntheticBaseEvent.prototype,{preventDefault:function(){this.defaultPrevented=true;var event=this.nativeEvent;if(!event){return;}if(event.preventDefault){event.preventDefault();// $FlowFixMe - flow is not aware of `unknown` in IE\n\t}else if(typeof event.returnValue!=='unknown'){event.returnValue=false;}this.isDefaultPrevented=functionThatReturnsTrue;},stopPropagation:function(){var event=this.nativeEvent;if(!event){return;}if(event.stopPropagation){event.stopPropagation();// $FlowFixMe - flow is not aware of `unknown` in IE\n\t}else if(typeof event.cancelBubble!=='unknown'){// The ChangeEventPlugin registers a \"propertychange\" event for\n\t// IE. This event does not support bubbling or cancelling, and\n\t// any references to cancelBubble throw \"Member not found\".  A\n\t// typeof check of \"unknown\" circumvents this issue (and is also\n\t// IE specific).\n\tevent.cancelBubble=true;}this.isPropagationStopped=functionThatReturnsTrue;},/**\n\t     * We release all dispatched `SyntheticEvent`s after each event loop, adding\n\t     * them back into the pool. This allows a way to hold onto a reference that\n\t     * won't be added back into the pool.\n\t     */persist:function(){// Modern event system doesn't use pooling.\n\t},/**\n\t     * Checks if this event should be released back into the pool.\n\t     *\n\t     * @return {boolean} True if this should not be released, false otherwise.\n\t     */isPersistent:functionThatReturnsTrue});return SyntheticBaseEvent;}/**\n\t * @interface Event\n\t * @see http://www.w3.org/TR/DOM-Level-3-Events/\n\t */var EventInterface={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(event){return event.timeStamp||Date.now();},defaultPrevented:0,isTrusted:0};var SyntheticEvent=createSyntheticEvent(EventInterface);var UIEventInterface=assign({},EventInterface,{view:0,detail:0});var SyntheticUIEvent=createSyntheticEvent(UIEventInterface);var lastMovementX;var lastMovementY;var lastMouseEvent;function updateMouseMovementPolyfillState(event){if(event!==lastMouseEvent){if(lastMouseEvent&&event.type==='mousemove'){lastMovementX=event.screenX-lastMouseEvent.screenX;lastMovementY=event.screenY-lastMouseEvent.screenY;}else {lastMovementX=0;lastMovementY=0;}lastMouseEvent=event;}}/**\n\t * @interface MouseEvent\n\t * @see http://www.w3.org/TR/DOM-Level-3-Events/\n\t */var MouseEventInterface=assign({},UIEventInterface,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:getEventModifierState,button:0,buttons:0,relatedTarget:function(event){if(event.relatedTarget===undefined)return event.fromElement===event.srcElement?event.toElement:event.fromElement;return event.relatedTarget;},movementX:function(event){if('movementX'in event){return event.movementX;}updateMouseMovementPolyfillState(event);return lastMovementX;},movementY:function(event){if('movementY'in event){return event.movementY;}// Don't need to call updateMouseMovementPolyfillState() here\n\t// because it's guaranteed to have already run when movementX\n\t// was copied.\n\treturn lastMovementY;}});var SyntheticMouseEvent=createSyntheticEvent(MouseEventInterface);/**\n\t * @interface DragEvent\n\t * @see http://www.w3.org/TR/DOM-Level-3-Events/\n\t */var DragEventInterface=assign({},MouseEventInterface,{dataTransfer:0});var SyntheticDragEvent=createSyntheticEvent(DragEventInterface);/**\n\t * @interface FocusEvent\n\t * @see http://www.w3.org/TR/DOM-Level-3-Events/\n\t */var FocusEventInterface=assign({},UIEventInterface,{relatedTarget:0});var SyntheticFocusEvent=createSyntheticEvent(FocusEventInterface);/**\n\t * @interface Event\n\t * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface\n\t * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent\n\t */var AnimationEventInterface=assign({},EventInterface,{animationName:0,elapsedTime:0,pseudoElement:0});var SyntheticAnimationEvent=createSyntheticEvent(AnimationEventInterface);/**\n\t * @interface Event\n\t * @see http://www.w3.org/TR/clipboard-apis/\n\t */var ClipboardEventInterface=assign({},EventInterface,{clipboardData:function(event){return 'clipboardData'in event?event.clipboardData:window.clipboardData;}});var SyntheticClipboardEvent=createSyntheticEvent(ClipboardEventInterface);/**\n\t * @interface Event\n\t * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents\n\t */var CompositionEventInterface=assign({},EventInterface,{data:0});var SyntheticCompositionEvent=createSyntheticEvent(CompositionEventInterface);/**\n\t * @interface Event\n\t * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105\n\t *      /#events-inputevents\n\t */ // Happens to share the same list for now.\n\tvar SyntheticInputEvent=SyntheticCompositionEvent;/**\n\t * Normalization of deprecated HTML5 `key` values\n\t * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names\n\t */var normalizeKey={Esc:'Escape',Spacebar:' ',Left:'ArrowLeft',Up:'ArrowUp',Right:'ArrowRight',Down:'ArrowDown',Del:'Delete',Win:'OS',Menu:'ContextMenu',Apps:'ContextMenu',Scroll:'ScrollLock',MozPrintableKey:'Unidentified'};/**\n\t * Translation from legacy `keyCode` to HTML5 `key`\n\t * Only special keys supported, all others depend on keyboard layout or browser\n\t * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names\n\t */var translateToKey={'8':'Backspace','9':'Tab','12':'Clear','13':'Enter','16':'Shift','17':'Control','18':'Alt','19':'Pause','20':'CapsLock','27':'Escape','32':' ','33':'PageUp','34':'PageDown','35':'End','36':'Home','37':'ArrowLeft','38':'ArrowUp','39':'ArrowRight','40':'ArrowDown','45':'Insert','46':'Delete','112':'F1','113':'F2','114':'F3','115':'F4','116':'F5','117':'F6','118':'F7','119':'F8','120':'F9','121':'F10','122':'F11','123':'F12','144':'NumLock','145':'ScrollLock','224':'Meta'};/**\n\t * @param {object} nativeEvent Native browser event.\n\t * @return {string} Normalized `key` property.\n\t */function getEventKey(nativeEvent){if(nativeEvent.key){// Normalize inconsistent values reported by browsers due to\n\t// implementations of a working draft specification.\n\t// FireFox implements `key` but returns `MozPrintableKey` for all\n\t// printable characters (normalized to `Unidentified`), ignore it.\n\tvar key=normalizeKey[nativeEvent.key]||nativeEvent.key;if(key!=='Unidentified'){return key;}}// Browser does not implement `key`, polyfill as much of it as we can.\n\tif(nativeEvent.type==='keypress'){var charCode=getEventCharCode(nativeEvent);// The enter-key is technically both printable and non-printable and can\n\t// thus be captured by `keypress`, no other non-printable key should.\n\treturn charCode===13?'Enter':String.fromCharCode(charCode);}if(nativeEvent.type==='keydown'||nativeEvent.type==='keyup'){// While user keyboard layout determines the actual meaning of each\n\t// `keyCode` value, almost all function keys have a universal value.\n\treturn translateToKey[nativeEvent.keyCode]||'Unidentified';}return '';}/**\n\t * Translation from modifier key to the associated property in the event.\n\t * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers\n\t */var modifierKeyToProp={Alt:'altKey',Control:'ctrlKey',Meta:'metaKey',Shift:'shiftKey'};// Older browsers (Safari <= 10, iOS Safari <= 10.2) do not support\n\t// getModifierState. If getModifierState is not supported, we map it to a set of\n\t// modifier keys exposed by the event. In this case, Lock-keys are not supported.\n\tfunction modifierStateGetter(keyArg){var syntheticEvent=this;var nativeEvent=syntheticEvent.nativeEvent;if(nativeEvent.getModifierState){return nativeEvent.getModifierState(keyArg);}var keyProp=modifierKeyToProp[keyArg];return keyProp?!!nativeEvent[keyProp]:false;}function getEventModifierState(nativeEvent){return modifierStateGetter;}/**\n\t * @interface KeyboardEvent\n\t * @see http://www.w3.org/TR/DOM-Level-3-Events/\n\t */var KeyboardEventInterface=assign({},UIEventInterface,{key:getEventKey,code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:getEventModifierState,// Legacy Interface\n\tcharCode:function(event){// `charCode` is the result of a KeyPress event and represents the value of\n\t// the actual printable character.\n\t// KeyPress is deprecated, but its replacement is not yet final and not\n\t// implemented in any major browser. Only KeyPress has charCode.\n\tif(event.type==='keypress'){return getEventCharCode(event);}return 0;},keyCode:function(event){// `keyCode` is the result of a KeyDown/Up event and represents the value of\n\t// physical keyboard key.\n\t// The actual meaning of the value depends on the users' keyboard layout\n\t// which cannot be detected. Assuming that it is a US keyboard layout\n\t// provides a surprisingly accurate mapping for US and European users.\n\t// Due to this, it is left to the user to implement at this time.\n\tif(event.type==='keydown'||event.type==='keyup'){return event.keyCode;}return 0;},which:function(event){// `which` is an alias for either `keyCode` or `charCode` depending on the\n\t// type of the event.\n\tif(event.type==='keypress'){return getEventCharCode(event);}if(event.type==='keydown'||event.type==='keyup'){return event.keyCode;}return 0;}});var SyntheticKeyboardEvent=createSyntheticEvent(KeyboardEventInterface);/**\n\t * @interface PointerEvent\n\t * @see http://www.w3.org/TR/pointerevents/\n\t */var PointerEventInterface=assign({},MouseEventInterface,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0});var SyntheticPointerEvent=createSyntheticEvent(PointerEventInterface);/**\n\t * @interface TouchEvent\n\t * @see http://www.w3.org/TR/touch-events/\n\t */var TouchEventInterface=assign({},UIEventInterface,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:getEventModifierState});var SyntheticTouchEvent=createSyntheticEvent(TouchEventInterface);/**\n\t * @interface Event\n\t * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-\n\t * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent\n\t */var TransitionEventInterface=assign({},EventInterface,{propertyName:0,elapsedTime:0,pseudoElement:0});var SyntheticTransitionEvent=createSyntheticEvent(TransitionEventInterface);/**\n\t * @interface WheelEvent\n\t * @see http://www.w3.org/TR/DOM-Level-3-Events/\n\t */var WheelEventInterface=assign({},MouseEventInterface,{deltaX:function(event){return 'deltaX'in event?event.deltaX:// Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).\n\t'wheelDeltaX'in event?-event.wheelDeltaX:0;},deltaY:function(event){return 'deltaY'in event?event.deltaY:// Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).\n\t'wheelDeltaY'in event?-event.wheelDeltaY:// Fallback to `wheelDelta` for IE<9 and normalize (down is positive).\n\t'wheelDelta'in event?-event.wheelDelta:0;},deltaZ:0,// Browsers without \"deltaMode\" is reporting in raw wheel delta where one\n\t// notch on the scroll is always +/- 120, roughly equivalent to pixels.\n\t// A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or\n\t// ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.\n\tdeltaMode:0});var SyntheticWheelEvent=createSyntheticEvent(WheelEventInterface);var END_KEYCODES=[9,13,27,32];// Tab, Return, Esc, Space\n\tvar START_KEYCODE=229;var canUseCompositionEvent=canUseDOM&&'CompositionEvent'in window;var documentMode=null;if(canUseDOM&&'documentMode'in document){documentMode=document.documentMode;}// Webkit offers a very useful `textInput` event that can be used to\n\t// directly represent `beforeInput`. The IE `textinput` event is not as\n\t// useful, so we don't use it.\n\tvar canUseTextInputEvent=canUseDOM&&'TextEvent'in window&&!documentMode;// In IE9+, we have access to composition events, but the data supplied\n\t// by the native compositionend event may be incorrect. Japanese ideographic\n\t// spaces, for instance (\\u3000) are not recorded correctly.\n\tvar useFallbackCompositionData=canUseDOM&&(!canUseCompositionEvent||documentMode&&documentMode>8&&documentMode<=11);var SPACEBAR_CODE=32;var SPACEBAR_CHAR=String.fromCharCode(SPACEBAR_CODE);function registerEvents(){registerTwoPhaseEvent('onBeforeInput',['compositionend','keypress','textInput','paste']);registerTwoPhaseEvent('onCompositionEnd',['compositionend','focusout','keydown','keypress','keyup','mousedown']);registerTwoPhaseEvent('onCompositionStart',['compositionstart','focusout','keydown','keypress','keyup','mousedown']);registerTwoPhaseEvent('onCompositionUpdate',['compositionupdate','focusout','keydown','keypress','keyup','mousedown']);}// Track whether we've ever handled a keypress on the space key.\n\tvar hasSpaceKeypress=false;/**\n\t * Return whether a native keypress event is assumed to be a command.\n\t * This is required because Firefox fires `keypress` events for key commands\n\t * (cut, copy, select-all, etc.) even though no character is inserted.\n\t */function isKeypressCommand(nativeEvent){return (nativeEvent.ctrlKey||nativeEvent.altKey||nativeEvent.metaKey)&&// ctrlKey && altKey is equivalent to AltGr, and is not a command.\n\t!(nativeEvent.ctrlKey&&nativeEvent.altKey);}/**\n\t * Translate native top level events into event types.\n\t */function getCompositionEventType(domEventName){switch(domEventName){case'compositionstart':return 'onCompositionStart';case'compositionend':return 'onCompositionEnd';case'compositionupdate':return 'onCompositionUpdate';}}/**\n\t * Does our fallback best-guess model think this event signifies that\n\t * composition has begun?\n\t */function isFallbackCompositionStart(domEventName,nativeEvent){return domEventName==='keydown'&&nativeEvent.keyCode===START_KEYCODE;}/**\n\t * Does our fallback mode think that this event is the end of composition?\n\t */function isFallbackCompositionEnd(domEventName,nativeEvent){switch(domEventName){case'keyup':// Command keys insert or clear IME input.\n\treturn END_KEYCODES.indexOf(nativeEvent.keyCode)!==-1;case'keydown':// Expect IME keyCode on each keydown. If we get any other\n\t// code we must have exited earlier.\n\treturn nativeEvent.keyCode!==START_KEYCODE;case'keypress':case'mousedown':case'focusout':// Events are not possible without cancelling IME.\n\treturn true;default:return false;}}/**\n\t * Google Input Tools provides composition data via a CustomEvent,\n\t * with the `data` property populated in the `detail` object. If this\n\t * is available on the event object, use it. If not, this is a plain\n\t * composition event and we have nothing special to extract.\n\t *\n\t * @param {object} nativeEvent\n\t * @return {?string}\n\t */function getDataFromCustomEvent(nativeEvent){var detail=nativeEvent.detail;if(typeof detail==='object'&&'data'in detail){return detail.data;}return null;}/**\n\t * Check if a composition event was triggered by Korean IME.\n\t * Our fallback mode does not work well with IE's Korean IME,\n\t * so just use native composition events when Korean IME is used.\n\t * Although CompositionEvent.locale property is deprecated,\n\t * it is available in IE, where our fallback mode is enabled.\n\t *\n\t * @param {object} nativeEvent\n\t * @return {boolean}\n\t */function isUsingKoreanIME(nativeEvent){return nativeEvent.locale==='ko';}// Track the current IME composition status, if any.\n\tvar isComposing=false;/**\n\t * @return {?object} A SyntheticCompositionEvent.\n\t */function extractCompositionEvent(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget){var eventType;var fallbackData;if(canUseCompositionEvent){eventType=getCompositionEventType(domEventName);}else if(!isComposing){if(isFallbackCompositionStart(domEventName,nativeEvent)){eventType='onCompositionStart';}}else if(isFallbackCompositionEnd(domEventName,nativeEvent)){eventType='onCompositionEnd';}if(!eventType){return null;}if(useFallbackCompositionData&&!isUsingKoreanIME(nativeEvent)){// The current composition is stored statically and must not be\n\t// overwritten while composition continues.\n\tif(!isComposing&&eventType==='onCompositionStart'){isComposing=initialize(nativeEventTarget);}else if(eventType==='onCompositionEnd'){if(isComposing){fallbackData=getData();}}}var listeners=accumulateTwoPhaseListeners(targetInst,eventType);if(listeners.length>0){var event=new SyntheticCompositionEvent(eventType,domEventName,null,nativeEvent,nativeEventTarget);dispatchQueue.push({event:event,listeners:listeners});if(fallbackData){// Inject data generated from fallback path into the synthetic event.\n\t// This matches the property of native CompositionEventInterface.\n\tevent.data=fallbackData;}else {var customData=getDataFromCustomEvent(nativeEvent);if(customData!==null){event.data=customData;}}}}function getNativeBeforeInputChars(domEventName,nativeEvent){switch(domEventName){case'compositionend':return getDataFromCustomEvent(nativeEvent);case'keypress':/**\n\t       * If native `textInput` events are available, our goal is to make\n\t       * use of them. However, there is a special case: the spacebar key.\n\t       * In Webkit, preventing default on a spacebar `textInput` event\n\t       * cancels character insertion, but it *also* causes the browser\n\t       * to fall back to its default spacebar behavior of scrolling the\n\t       * page.\n\t       *\n\t       * Tracking at:\n\t       * https://code.google.com/p/chromium/issues/detail?id=355103\n\t       *\n\t       * To avoid this issue, use the keypress event as if no `textInput`\n\t       * event is available.\n\t       */var which=nativeEvent.which;if(which!==SPACEBAR_CODE){return null;}hasSpaceKeypress=true;return SPACEBAR_CHAR;case'textInput':// Record the characters to be added to the DOM.\n\tvar chars=nativeEvent.data;// If it's a spacebar character, assume that we have already handled\n\t// it at the keypress level and bail immediately. Android Chrome\n\t// doesn't give us keycodes, so we need to ignore it.\n\tif(chars===SPACEBAR_CHAR&&hasSpaceKeypress){return null;}return chars;default:// For other native event types, do nothing.\n\treturn null;}}/**\n\t * For browsers that do not provide the `textInput` event, extract the\n\t * appropriate string to use for SyntheticInputEvent.\n\t */function getFallbackBeforeInputChars(domEventName,nativeEvent){// If we are currently composing (IME) and using a fallback to do so,\n\t// try to extract the composed characters from the fallback object.\n\t// If composition event is available, we extract a string only at\n\t// compositionevent, otherwise extract it at fallback events.\n\tif(isComposing){if(domEventName==='compositionend'||!canUseCompositionEvent&&isFallbackCompositionEnd(domEventName,nativeEvent)){var chars=getData();reset();isComposing=false;return chars;}return null;}switch(domEventName){case'paste':// If a paste event occurs after a keypress, throw out the input\n\t// chars. Paste events should not lead to BeforeInput events.\n\treturn null;case'keypress':/**\n\t       * As of v27, Firefox may fire keypress events even when no character\n\t       * will be inserted. A few possibilities:\n\t       *\n\t       * - `which` is `0`. Arrow keys, Esc key, etc.\n\t       *\n\t       * - `which` is the pressed key code, but no char is available.\n\t       *   Ex: 'AltGr + d` in Polish. There is no modified character for\n\t       *   this key combination and no character is inserted into the\n\t       *   document, but FF fires the keypress for char code `100` anyway.\n\t       *   No `input` event will occur.\n\t       *\n\t       * - `which` is the pressed key code, but a command combination is\n\t       *   being used. Ex: `Cmd+C`. No character is inserted, and no\n\t       *   `input` event will occur.\n\t       */if(!isKeypressCommand(nativeEvent)){// IE fires the `keypress` event when a user types an emoji via\n\t// Touch keyboard of Windows.  In such a case, the `char` property\n\t// holds an emoji character like `\\uD83D\\uDE0A`.  Because its length\n\t// is 2, the property `which` does not represent an emoji correctly.\n\t// In such a case, we directly return the `char` property instead of\n\t// using `which`.\n\tif(nativeEvent.char&&nativeEvent.char.length>1){return nativeEvent.char;}else if(nativeEvent.which){return String.fromCharCode(nativeEvent.which);}}return null;case'compositionend':return useFallbackCompositionData&&!isUsingKoreanIME(nativeEvent)?null:nativeEvent.data;default:return null;}}/**\n\t * Extract a SyntheticInputEvent for `beforeInput`, based on either native\n\t * `textInput` or fallback behavior.\n\t *\n\t * @return {?object} A SyntheticInputEvent.\n\t */function extractBeforeInputEvent(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget){var chars;if(canUseTextInputEvent){chars=getNativeBeforeInputChars(domEventName,nativeEvent);}else {chars=getFallbackBeforeInputChars(domEventName,nativeEvent);}// If no characters are being inserted, no BeforeInput event should\n\t// be fired.\n\tif(!chars){return null;}var listeners=accumulateTwoPhaseListeners(targetInst,'onBeforeInput');if(listeners.length>0){var event=new SyntheticInputEvent('onBeforeInput','beforeinput',null,nativeEvent,nativeEventTarget);dispatchQueue.push({event:event,listeners:listeners});event.data=chars;}}/**\n\t * Create an `onBeforeInput` event to match\n\t * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.\n\t *\n\t * This event plugin is based on the native `textInput` event\n\t * available in Chrome, Safari, Opera, and IE. This event fires after\n\t * `onKeyPress` and `onCompositionEnd`, but before `onInput`.\n\t *\n\t * `beforeInput` is spec'd but not implemented in any browsers, and\n\t * the `input` event does not provide any useful information about what has\n\t * actually been added, contrary to the spec. Thus, `textInput` is the best\n\t * available event to identify the characters that have actually been inserted\n\t * into the target node.\n\t *\n\t * This plugin is also responsible for emitting `composition` events, thus\n\t * allowing us to share composition fallback code for both `beforeInput` and\n\t * `composition` event types.\n\t */function extractEvents(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){extractCompositionEvent(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget);extractBeforeInputEvent(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget);}/**\n\t * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary\n\t */var supportedInputTypes={color:true,date:true,datetime:true,'datetime-local':true,email:true,month:true,number:true,password:true,range:true,search:true,tel:true,text:true,time:true,url:true,week:true};function isTextInputElement(elem){var nodeName=elem&&elem.nodeName&&elem.nodeName.toLowerCase();if(nodeName==='input'){return !!supportedInputTypes[elem.type];}if(nodeName==='textarea'){return true;}return false;}/**\n\t * Checks if an event is supported in the current execution environment.\n\t *\n\t * NOTE: This will not work correctly for non-generic events such as `change`,\n\t * `reset`, `load`, `error`, and `select`.\n\t *\n\t * Borrows from Modernizr.\n\t *\n\t * @param {string} eventNameSuffix Event name, e.g. \"click\".\n\t * @return {boolean} True if the event is supported.\n\t * @internal\n\t * @license Modernizr 3.0.0pre (Custom Build) | MIT\n\t */function isEventSupported(eventNameSuffix){if(!canUseDOM){return false;}var eventName='on'+eventNameSuffix;var isSupported=(eventName in document);if(!isSupported){var element=document.createElement('div');element.setAttribute(eventName,'return;');isSupported=typeof element[eventName]==='function';}return isSupported;}function registerEvents$1(){registerTwoPhaseEvent('onChange',['change','click','focusin','focusout','input','keydown','keyup','selectionchange']);}function createAndAccumulateChangeEvent(dispatchQueue,inst,nativeEvent,target){// Flag this event loop as needing state restore.\n\tenqueueStateRestore(target);var listeners=accumulateTwoPhaseListeners(inst,'onChange');if(listeners.length>0){var event=new SyntheticEvent('onChange','change',null,nativeEvent,target);dispatchQueue.push({event:event,listeners:listeners});}}/**\n\t * For IE shims\n\t */var activeElement=null;var activeElementInst=null;/**\n\t * SECTION: handle `change` event\n\t */function shouldUseChangeEvent(elem){var nodeName=elem.nodeName&&elem.nodeName.toLowerCase();return nodeName==='select'||nodeName==='input'&&elem.type==='file';}function manualDispatchChangeEvent(nativeEvent){var dispatchQueue=[];createAndAccumulateChangeEvent(dispatchQueue,activeElementInst,nativeEvent,getEventTarget(nativeEvent));// If change and propertychange bubbled, we'd just bind to it like all the\n\t// other events and have it go through ReactBrowserEventEmitter. Since it\n\t// doesn't, we manually listen for the events and so we have to enqueue and\n\t// process the abstract event manually.\n\t//\n\t// Batching is necessary here in order to ensure that all event handlers run\n\t// before the next rerender (including event handlers attached to ancestor\n\t// elements instead of directly on the input). Without this, controlled\n\t// components don't work properly in conjunction with event bubbling because\n\t// the component is rerendered and the value reverted before all the event\n\t// handlers can run. See https://github.com/facebook/react/issues/708.\n\tbatchedUpdates(runEventInBatch,dispatchQueue);}function runEventInBatch(dispatchQueue){processDispatchQueue(dispatchQueue,0);}function getInstIfValueChanged(targetInst){var targetNode=getNodeFromInstance(targetInst);if(updateValueIfChanged(targetNode)){return targetInst;}}function getTargetInstForChangeEvent(domEventName,targetInst){if(domEventName==='change'){return targetInst;}}/**\n\t * SECTION: handle `input` event\n\t */var isInputEventSupported=false;if(canUseDOM){// IE9 claims to support the input event but fails to trigger it when\n\t// deleting text, so we ignore its input events.\n\tisInputEventSupported=isEventSupported('input')&&(!document.documentMode||document.documentMode>9);}/**\n\t * (For IE <=9) Starts tracking propertychange events on the passed-in element\n\t * and override the value property so that we can distinguish user events from\n\t * value changes in JS.\n\t */function startWatchingForValueChange(target,targetInst){activeElement=target;activeElementInst=targetInst;activeElement.attachEvent('onpropertychange',handlePropertyChange);}/**\n\t * (For IE <=9) Removes the event listeners from the currently-tracked element,\n\t * if any exists.\n\t */function stopWatchingForValueChange(){if(!activeElement){return;}activeElement.detachEvent('onpropertychange',handlePropertyChange);activeElement=null;activeElementInst=null;}/**\n\t * (For IE <=9) Handles a propertychange event, sending a `change` event if\n\t * the value of the active element has changed.\n\t */function handlePropertyChange(nativeEvent){if(nativeEvent.propertyName!=='value'){return;}if(getInstIfValueChanged(activeElementInst)){manualDispatchChangeEvent(nativeEvent);}}function handleEventsForInputEventPolyfill(domEventName,target,targetInst){if(domEventName==='focusin'){// In IE9, propertychange fires for most input events but is buggy and\n\t// doesn't fire when text is deleted, but conveniently, selectionchange\n\t// appears to fire in all of the remaining cases so we catch those and\n\t// forward the event if the value has changed\n\t// In either case, we don't want to call the event handler if the value\n\t// is changed from JS so we redefine a setter for `.value` that updates\n\t// our activeElementValue variable, allowing us to ignore those changes\n\t//\n\t// stopWatching() should be a noop here but we call it just in case we\n\t// missed a blur event somehow.\n\tstopWatchingForValueChange();startWatchingForValueChange(target,targetInst);}else if(domEventName==='focusout'){stopWatchingForValueChange();}}// For IE8 and IE9.\n\tfunction getTargetInstForInputEventPolyfill(domEventName,targetInst){if(domEventName==='selectionchange'||domEventName==='keyup'||domEventName==='keydown'){// On the selectionchange event, the target is just document which isn't\n\t// helpful for us so just check activeElement instead.\n\t//\n\t// 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire\n\t// propertychange on the first input event after setting `value` from a\n\t// script and fires only keydown, keypress, keyup. Catching keyup usually\n\t// gets it and catching keydown lets us fire an event for the first\n\t// keystroke if user does a key repeat (it'll be a little delayed: right\n\t// before the second keystroke). Other input methods (e.g., paste) seem to\n\t// fire selectionchange normally.\n\treturn getInstIfValueChanged(activeElementInst);}}/**\n\t * SECTION: handle `click` event\n\t */function shouldUseClickEvent(elem){// Use the `click` event to detect changes to checkbox and radio inputs.\n\t// This approach works across all browsers, whereas `change` does not fire\n\t// until `blur` in IE8.\n\tvar nodeName=elem.nodeName;return nodeName&&nodeName.toLowerCase()==='input'&&(elem.type==='checkbox'||elem.type==='radio');}function getTargetInstForClickEvent(domEventName,targetInst){if(domEventName==='click'){return getInstIfValueChanged(targetInst);}}function getTargetInstForInputOrChangeEvent(domEventName,targetInst){if(domEventName==='input'||domEventName==='change'){return getInstIfValueChanged(targetInst);}}function handleControlledInputBlur(node){var state=node._wrapperState;if(!state||!state.controlled||node.type!=='number'){return;}{// If controlled, assign the value attribute to the current value on blur\n\tsetDefaultValue(node,'number',node.value);}}/**\n\t * This plugin creates an `onChange` event that normalizes change events\n\t * across form elements. This event fires at a time when it's possible to\n\t * change the element's value without seeing a flicker.\n\t *\n\t * Supported elements are:\n\t * - input (see `isTextInputElement`)\n\t * - textarea\n\t * - select\n\t */function extractEvents$1(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){var targetNode=targetInst?getNodeFromInstance(targetInst):window;var getTargetInstFunc,handleEventFunc;if(shouldUseChangeEvent(targetNode)){getTargetInstFunc=getTargetInstForChangeEvent;}else if(isTextInputElement(targetNode)){if(isInputEventSupported){getTargetInstFunc=getTargetInstForInputOrChangeEvent;}else {getTargetInstFunc=getTargetInstForInputEventPolyfill;handleEventFunc=handleEventsForInputEventPolyfill;}}else if(shouldUseClickEvent(targetNode)){getTargetInstFunc=getTargetInstForClickEvent;}if(getTargetInstFunc){var inst=getTargetInstFunc(domEventName,targetInst);if(inst){createAndAccumulateChangeEvent(dispatchQueue,inst,nativeEvent,nativeEventTarget);return;}}if(handleEventFunc){handleEventFunc(domEventName,targetNode,targetInst);}// When blurring, set the value attribute for number inputs\n\tif(domEventName==='focusout'){handleControlledInputBlur(targetNode);}}function registerEvents$2(){registerDirectEvent('onMouseEnter',['mouseout','mouseover']);registerDirectEvent('onMouseLeave',['mouseout','mouseover']);registerDirectEvent('onPointerEnter',['pointerout','pointerover']);registerDirectEvent('onPointerLeave',['pointerout','pointerover']);}/**\n\t * For almost every interaction we care about, there will be both a top-level\n\t * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that\n\t * we do not extract duplicate events. However, moving the mouse into the\n\t * browser from outside will not fire a `mouseout` event. In this case, we use\n\t * the `mouseover` top-level event.\n\t */function extractEvents$2(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){var isOverEvent=domEventName==='mouseover'||domEventName==='pointerover';var isOutEvent=domEventName==='mouseout'||domEventName==='pointerout';if(isOverEvent&&!isReplayingEvent(nativeEvent)){// If this is an over event with a target, we might have already dispatched\n\t// the event in the out event of the other target. If this is replayed,\n\t// then it's because we couldn't dispatch against this target previously\n\t// so we have to do it now instead.\n\tvar related=nativeEvent.relatedTarget||nativeEvent.fromElement;if(related){// If the related node is managed by React, we can assume that we have\n\t// already dispatched the corresponding events during its mouseout.\n\tif(getClosestInstanceFromNode(related)||isContainerMarkedAsRoot(related)){return;}}}if(!isOutEvent&&!isOverEvent){// Must not be a mouse or pointer in or out - ignoring.\n\treturn;}var win;// TODO: why is this nullable in the types but we read from it?\n\tif(nativeEventTarget.window===nativeEventTarget){// `nativeEventTarget` is probably a window object.\n\twin=nativeEventTarget;}else {// TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.\n\tvar doc=nativeEventTarget.ownerDocument;if(doc){win=doc.defaultView||doc.parentWindow;}else {win=window;}}var from;var to;if(isOutEvent){var _related=nativeEvent.relatedTarget||nativeEvent.toElement;from=targetInst;to=_related?getClosestInstanceFromNode(_related):null;if(to!==null){var nearestMounted=getNearestMountedFiber(to);if(to!==nearestMounted||to.tag!==HostComponent&&to.tag!==HostText){to=null;}}}else {// Moving to a node from outside the window.\n\tfrom=null;to=targetInst;}if(from===to){// Nothing pertains to our managed components.\n\treturn;}var SyntheticEventCtor=SyntheticMouseEvent;var leaveEventType='onMouseLeave';var enterEventType='onMouseEnter';var eventTypePrefix='mouse';if(domEventName==='pointerout'||domEventName==='pointerover'){SyntheticEventCtor=SyntheticPointerEvent;leaveEventType='onPointerLeave';enterEventType='onPointerEnter';eventTypePrefix='pointer';}var fromNode=from==null?win:getNodeFromInstance(from);var toNode=to==null?win:getNodeFromInstance(to);var leave=new SyntheticEventCtor(leaveEventType,eventTypePrefix+'leave',from,nativeEvent,nativeEventTarget);leave.target=fromNode;leave.relatedTarget=toNode;var enter=null;// We should only process this nativeEvent if we are processing\n\t// the first ancestor. Next time, we will ignore the event.\n\tvar nativeTargetInst=getClosestInstanceFromNode(nativeEventTarget);if(nativeTargetInst===targetInst){var enterEvent=new SyntheticEventCtor(enterEventType,eventTypePrefix+'enter',to,nativeEvent,nativeEventTarget);enterEvent.target=toNode;enterEvent.relatedTarget=fromNode;enter=enterEvent;}accumulateEnterLeaveTwoPhaseListeners(dispatchQueue,leave,enter,from,to);}/**\n\t * inlined Object.is polyfill to avoid requiring consumers ship their own\n\t * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n\t */function is(x,y){return x===y&&(x!==0||1/x===1/y)||x!==x&&y!==y// eslint-disable-line no-self-compare\n\t;}var objectIs=typeof Object.is==='function'?Object.is:is;/**\n\t * Performs equality by iterating through keys on an object and returning false\n\t * when any key has values which are not strictly equal between the arguments.\n\t * Returns true when the values of all keys are strictly equal.\n\t */function shallowEqual(objA,objB){if(objectIs(objA,objB)){return true;}if(typeof objA!=='object'||objA===null||typeof objB!=='object'||objB===null){return false;}var keysA=Object.keys(objA);var keysB=Object.keys(objB);if(keysA.length!==keysB.length){return false;}// Test for A's keys different from B.\n\tfor(var i=0;i<keysA.length;i++){var currentKey=keysA[i];if(!hasOwnProperty.call(objB,currentKey)||!objectIs(objA[currentKey],objB[currentKey])){return false;}}return true;}/**\n\t * Given any node return the first leaf node without children.\n\t *\n\t * @param {DOMElement|DOMTextNode} node\n\t * @return {DOMElement|DOMTextNode}\n\t */function getLeafNode(node){while(node&&node.firstChild){node=node.firstChild;}return node;}/**\n\t * Get the next sibling within a container. This will walk up the\n\t * DOM if a node's siblings have been exhausted.\n\t *\n\t * @param {DOMElement|DOMTextNode} node\n\t * @return {?DOMElement|DOMTextNode}\n\t */function getSiblingNode(node){while(node){if(node.nextSibling){return node.nextSibling;}node=node.parentNode;}}/**\n\t * Get object describing the nodes which contain characters at offset.\n\t *\n\t * @param {DOMElement|DOMTextNode} root\n\t * @param {number} offset\n\t * @return {?object}\n\t */function getNodeForCharacterOffset(root,offset){var node=getLeafNode(root);var nodeStart=0;var nodeEnd=0;while(node){if(node.nodeType===TEXT_NODE){nodeEnd=nodeStart+node.textContent.length;if(nodeStart<=offset&&nodeEnd>=offset){return {node:node,offset:offset-nodeStart};}nodeStart=nodeEnd;}node=getLeafNode(getSiblingNode(node));}}/**\n\t * @param {DOMElement} outerNode\n\t * @return {?object}\n\t */function getOffsets(outerNode){var ownerDocument=outerNode.ownerDocument;var win=ownerDocument&&ownerDocument.defaultView||window;var selection=win.getSelection&&win.getSelection();if(!selection||selection.rangeCount===0){return null;}var anchorNode=selection.anchorNode,anchorOffset=selection.anchorOffset,focusNode=selection.focusNode,focusOffset=selection.focusOffset;// In Firefox, anchorNode and focusNode can be \"anonymous divs\", e.g. the\n\t// up/down buttons on an <input type=\"number\">. Anonymous divs do not seem to\n\t// expose properties, triggering a \"Permission denied error\" if any of its\n\t// properties are accessed. The only seemingly possible way to avoid erroring\n\t// is to access a property that typically works for non-anonymous divs and\n\t// catch any error that may otherwise arise. See\n\t// https://bugzilla.mozilla.org/show_bug.cgi?id=208427\n\ttry{/* eslint-disable no-unused-expressions */anchorNode.nodeType;focusNode.nodeType;/* eslint-enable no-unused-expressions */}catch(e){return null;}return getModernOffsetsFromPoints(outerNode,anchorNode,anchorOffset,focusNode,focusOffset);}/**\n\t * Returns {start, end} where `start` is the character/codepoint index of\n\t * (anchorNode, anchorOffset) within the textContent of `outerNode`, and\n\t * `end` is the index of (focusNode, focusOffset).\n\t *\n\t * Returns null if you pass in garbage input but we should probably just crash.\n\t *\n\t * Exported only for testing.\n\t */function getModernOffsetsFromPoints(outerNode,anchorNode,anchorOffset,focusNode,focusOffset){var length=0;var start=-1;var end=-1;var indexWithinAnchor=0;var indexWithinFocus=0;var node=outerNode;var parentNode=null;outer:while(true){var next=null;while(true){if(node===anchorNode&&(anchorOffset===0||node.nodeType===TEXT_NODE)){start=length+anchorOffset;}if(node===focusNode&&(focusOffset===0||node.nodeType===TEXT_NODE)){end=length+focusOffset;}if(node.nodeType===TEXT_NODE){length+=node.nodeValue.length;}if((next=node.firstChild)===null){break;}// Moving from `node` to its first child `next`.\n\tparentNode=node;node=next;}while(true){if(node===outerNode){// If `outerNode` has children, this is always the second time visiting\n\t// it. If it has no children, this is still the first loop, and the only\n\t// valid selection is anchorNode and focusNode both equal to this node\n\t// and both offsets 0, in which case we will have handled above.\n\tbreak outer;}if(parentNode===anchorNode&&++indexWithinAnchor===anchorOffset){start=length;}if(parentNode===focusNode&&++indexWithinFocus===focusOffset){end=length;}if((next=node.nextSibling)!==null){break;}node=parentNode;parentNode=node.parentNode;}// Moving from `node` to its next sibling `next`.\n\tnode=next;}if(start===-1||end===-1){// This should never happen. (Would happen if the anchor/focus nodes aren't\n\t// actually inside the passed-in node.)\n\treturn null;}return {start:start,end:end};}/**\n\t * In modern non-IE browsers, we can support both forward and backward\n\t * selections.\n\t *\n\t * Note: IE10+ supports the Selection object, but it does not support\n\t * the `extend` method, which means that even in modern IE, it's not possible\n\t * to programmatically create a backward selection. Thus, for all IE\n\t * versions, we use the old IE API to create our selections.\n\t *\n\t * @param {DOMElement|DOMTextNode} node\n\t * @param {object} offsets\n\t */function setOffsets(node,offsets){var doc=node.ownerDocument||document;var win=doc&&doc.defaultView||window;// Edge fails with \"Object expected\" in some scenarios.\n\t// (For instance: TinyMCE editor used in a list component that supports pasting to add more,\n\t// fails when pasting 100+ items)\n\tif(!win.getSelection){return;}var selection=win.getSelection();var length=node.textContent.length;var start=Math.min(offsets.start,length);var end=offsets.end===undefined?start:Math.min(offsets.end,length);// IE 11 uses modern selection, but doesn't support the extend method.\n\t// Flip backward selections, so we can set with a single range.\n\tif(!selection.extend&&start>end){var temp=end;end=start;start=temp;}var startMarker=getNodeForCharacterOffset(node,start);var endMarker=getNodeForCharacterOffset(node,end);if(startMarker&&endMarker){if(selection.rangeCount===1&&selection.anchorNode===startMarker.node&&selection.anchorOffset===startMarker.offset&&selection.focusNode===endMarker.node&&selection.focusOffset===endMarker.offset){return;}var range=doc.createRange();range.setStart(startMarker.node,startMarker.offset);selection.removeAllRanges();if(start>end){selection.addRange(range);selection.extend(endMarker.node,endMarker.offset);}else {range.setEnd(endMarker.node,endMarker.offset);selection.addRange(range);}}}function isTextNode(node){return node&&node.nodeType===TEXT_NODE;}function containsNode(outerNode,innerNode){if(!outerNode||!innerNode){return false;}else if(outerNode===innerNode){return true;}else if(isTextNode(outerNode)){return false;}else if(isTextNode(innerNode)){return containsNode(outerNode,innerNode.parentNode);}else if('contains'in outerNode){return outerNode.contains(innerNode);}else if(outerNode.compareDocumentPosition){return !!(outerNode.compareDocumentPosition(innerNode)&16);}else {return false;}}function isInDocument(node){return node&&node.ownerDocument&&containsNode(node.ownerDocument.documentElement,node);}function isSameOriginFrame(iframe){try{// Accessing the contentDocument of a HTMLIframeElement can cause the browser\n\t// to throw, e.g. if it has a cross-origin src attribute.\n\t// Safari will show an error in the console when the access results in \"Blocked a frame with origin\". e.g:\n\t// iframe.contentDocument.defaultView;\n\t// A safety way is to access one of the cross origin properties: Window or Location\n\t// Which might result in \"SecurityError\" DOM Exception and it is compatible to Safari.\n\t// https://html.spec.whatwg.org/multipage/browsers.html#integration-with-idl\n\treturn typeof iframe.contentWindow.location.href==='string';}catch(err){return false;}}function getActiveElementDeep(){var win=window;var element=getActiveElement();while(element instanceof win.HTMLIFrameElement){if(isSameOriginFrame(element)){win=element.contentWindow;}else {return element;}element=getActiveElement(win.document);}return element;}/**\n\t * @ReactInputSelection: React input selection module. Based on Selection.js,\n\t * but modified to be suitable for react and has a couple of bug fixes (doesn't\n\t * assume buttons have range selections allowed).\n\t * Input selection module for React.\n\t */ /**\n\t * @hasSelectionCapabilities: we get the element types that support selection\n\t * from https://html.spec.whatwg.org/#do-not-apply, looking at `selectionStart`\n\t * and `selectionEnd` rows.\n\t */function hasSelectionCapabilities(elem){var nodeName=elem&&elem.nodeName&&elem.nodeName.toLowerCase();return nodeName&&(nodeName==='input'&&(elem.type==='text'||elem.type==='search'||elem.type==='tel'||elem.type==='url'||elem.type==='password')||nodeName==='textarea'||elem.contentEditable==='true');}function getSelectionInformation(){var focusedElem=getActiveElementDeep();return {focusedElem:focusedElem,selectionRange:hasSelectionCapabilities(focusedElem)?getSelection(focusedElem):null};}/**\n\t * @restoreSelection: If any selection information was potentially lost,\n\t * restore it. This is useful when performing operations that could remove dom\n\t * nodes and place them back in, resulting in focus being lost.\n\t */function restoreSelection(priorSelectionInformation){var curFocusedElem=getActiveElementDeep();var priorFocusedElem=priorSelectionInformation.focusedElem;var priorSelectionRange=priorSelectionInformation.selectionRange;if(curFocusedElem!==priorFocusedElem&&isInDocument(priorFocusedElem)){if(priorSelectionRange!==null&&hasSelectionCapabilities(priorFocusedElem)){setSelection(priorFocusedElem,priorSelectionRange);}// Focusing a node can change the scroll position, which is undesirable\n\tvar ancestors=[];var ancestor=priorFocusedElem;while(ancestor=ancestor.parentNode){if(ancestor.nodeType===ELEMENT_NODE){ancestors.push({element:ancestor,left:ancestor.scrollLeft,top:ancestor.scrollTop});}}if(typeof priorFocusedElem.focus==='function'){priorFocusedElem.focus();}for(var i=0;i<ancestors.length;i++){var info=ancestors[i];info.element.scrollLeft=info.left;info.element.scrollTop=info.top;}}}/**\n\t * @getSelection: Gets the selection bounds of a focused textarea, input or\n\t * contentEditable node.\n\t * -@input: Look up selection bounds of this input\n\t * -@return {start: selectionStart, end: selectionEnd}\n\t */function getSelection(input){var selection;if('selectionStart'in input){// Modern browser with input or textarea.\n\tselection={start:input.selectionStart,end:input.selectionEnd};}else {// Content editable or old IE textarea.\n\tselection=getOffsets(input);}return selection||{start:0,end:0};}/**\n\t * @setSelection: Sets the selection bounds of a textarea or input and focuses\n\t * the input.\n\t * -@input     Set selection bounds of this input or textarea\n\t * -@offsets   Object of same form that is returned from get*\n\t */function setSelection(input,offsets){var start=offsets.start;var end=offsets.end;if(end===undefined){end=start;}if('selectionStart'in input){input.selectionStart=start;input.selectionEnd=Math.min(end,input.value.length);}else {setOffsets(input,offsets);}}var skipSelectionChangeEvent=canUseDOM&&'documentMode'in document&&document.documentMode<=11;function registerEvents$3(){registerTwoPhaseEvent('onSelect',['focusout','contextmenu','dragend','focusin','keydown','keyup','mousedown','mouseup','selectionchange']);}var activeElement$1=null;var activeElementInst$1=null;var lastSelection=null;var mouseDown=false;/**\n\t * Get an object which is a unique representation of the current selection.\n\t *\n\t * The return value will not be consistent across nodes or browsers, but\n\t * two identical selections on the same node will return identical objects.\n\t */function getSelection$1(node){if('selectionStart'in node&&hasSelectionCapabilities(node)){return {start:node.selectionStart,end:node.selectionEnd};}else {var win=node.ownerDocument&&node.ownerDocument.defaultView||window;var selection=win.getSelection();return {anchorNode:selection.anchorNode,anchorOffset:selection.anchorOffset,focusNode:selection.focusNode,focusOffset:selection.focusOffset};}}/**\n\t * Get document associated with the event target.\n\t */function getEventTargetDocument(eventTarget){return eventTarget.window===eventTarget?eventTarget.document:eventTarget.nodeType===DOCUMENT_NODE?eventTarget:eventTarget.ownerDocument;}/**\n\t * Poll selection to see whether it's changed.\n\t *\n\t * @param {object} nativeEvent\n\t * @param {object} nativeEventTarget\n\t * @return {?SyntheticEvent}\n\t */function constructSelectEvent(dispatchQueue,nativeEvent,nativeEventTarget){// Ensure we have the right element, and that the user is not dragging a\n\t// selection (this matches native `select` event behavior). In HTML5, select\n\t// fires only on input and textarea thus if there's no focused element we\n\t// won't dispatch.\n\tvar doc=getEventTargetDocument(nativeEventTarget);if(mouseDown||activeElement$1==null||activeElement$1!==getActiveElement(doc)){return;}// Only fire when selection has actually changed.\n\tvar currentSelection=getSelection$1(activeElement$1);if(!lastSelection||!shallowEqual(lastSelection,currentSelection)){lastSelection=currentSelection;var listeners=accumulateTwoPhaseListeners(activeElementInst$1,'onSelect');if(listeners.length>0){var event=new SyntheticEvent('onSelect','select',null,nativeEvent,nativeEventTarget);dispatchQueue.push({event:event,listeners:listeners});event.target=activeElement$1;}}}/**\n\t * This plugin creates an `onSelect` event that normalizes select events\n\t * across form elements.\n\t *\n\t * Supported elements are:\n\t * - input (see `isTextInputElement`)\n\t * - textarea\n\t * - contentEditable\n\t *\n\t * This differs from native browser implementations in the following ways:\n\t * - Fires on contentEditable fields as well as inputs.\n\t * - Fires for collapsed selection.\n\t * - Fires after user input.\n\t */function extractEvents$3(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){var targetNode=targetInst?getNodeFromInstance(targetInst):window;switch(domEventName){// Track the input node that has focus.\n\tcase'focusin':if(isTextInputElement(targetNode)||targetNode.contentEditable==='true'){activeElement$1=targetNode;activeElementInst$1=targetInst;lastSelection=null;}break;case'focusout':activeElement$1=null;activeElementInst$1=null;lastSelection=null;break;// Don't fire the event while the user is dragging. This matches the\n\t// semantics of the native select event.\n\tcase'mousedown':mouseDown=true;break;case'contextmenu':case'mouseup':case'dragend':mouseDown=false;constructSelectEvent(dispatchQueue,nativeEvent,nativeEventTarget);break;// Chrome and IE fire non-standard event when selection is changed (and\n\t// sometimes when it hasn't). IE's event fires out of order with respect\n\t// to key and input events on deletion, so we discard it.\n\t//\n\t// Firefox doesn't support selectionchange, so check selection status\n\t// after each key entry. The selection changes after keydown and before\n\t// keyup, but we check on keydown as well in the case of holding down a\n\t// key, when multiple keydown events are fired but only one keyup is.\n\t// This is also our approach for IE handling, for the reason above.\n\tcase'selectionchange':if(skipSelectionChangeEvent){break;}// falls through\n\tcase'keydown':case'keyup':constructSelectEvent(dispatchQueue,nativeEvent,nativeEventTarget);}}/**\n\t * Generate a mapping of standard vendor prefixes using the defined style property and event name.\n\t *\n\t * @param {string} styleProp\n\t * @param {string} eventName\n\t * @returns {object}\n\t */function makePrefixMap(styleProp,eventName){var prefixes={};prefixes[styleProp.toLowerCase()]=eventName.toLowerCase();prefixes['Webkit'+styleProp]='webkit'+eventName;prefixes['Moz'+styleProp]='moz'+eventName;return prefixes;}/**\n\t * A list of event names to a configurable list of vendor prefixes.\n\t */var vendorPrefixes={animationend:makePrefixMap('Animation','AnimationEnd'),animationiteration:makePrefixMap('Animation','AnimationIteration'),animationstart:makePrefixMap('Animation','AnimationStart'),transitionend:makePrefixMap('Transition','TransitionEnd')};/**\n\t * Event names that have already been detected and prefixed (if applicable).\n\t */var prefixedEventNames={};/**\n\t * Element to check for prefixes on.\n\t */var style={};/**\n\t * Bootstrap if a DOM exists.\n\t */if(canUseDOM){style=document.createElement('div').style;// On some platforms, in particular some releases of Android 4.x,\n\t// the un-prefixed \"animation\" and \"transition\" properties are defined on the\n\t// style object but the events that fire will still be prefixed, so we need\n\t// to check if the un-prefixed events are usable, and if not remove them from the map.\n\tif(!('AnimationEvent'in window)){delete vendorPrefixes.animationend.animation;delete vendorPrefixes.animationiteration.animation;delete vendorPrefixes.animationstart.animation;}// Same as above\n\tif(!('TransitionEvent'in window)){delete vendorPrefixes.transitionend.transition;}}/**\n\t * Attempts to determine the correct vendor prefixed event name.\n\t *\n\t * @param {string} eventName\n\t * @returns {string}\n\t */function getVendorPrefixedEventName(eventName){if(prefixedEventNames[eventName]){return prefixedEventNames[eventName];}else if(!vendorPrefixes[eventName]){return eventName;}var prefixMap=vendorPrefixes[eventName];for(var styleProp in prefixMap){if(prefixMap.hasOwnProperty(styleProp)&&styleProp in style){return prefixedEventNames[eventName]=prefixMap[styleProp];}}return eventName;}var ANIMATION_END=getVendorPrefixedEventName('animationend');var ANIMATION_ITERATION=getVendorPrefixedEventName('animationiteration');var ANIMATION_START=getVendorPrefixedEventName('animationstart');var TRANSITION_END=getVendorPrefixedEventName('transitionend');var topLevelEventsToReactNames=new Map();// NOTE: Capitalization is important in this list!\n\t//\n\t// E.g. it needs \"pointerDown\", not \"pointerdown\".\n\t// This is because we derive both React name (\"onPointerDown\")\n\t// and DOM name (\"pointerdown\") from the same list.\n\t//\n\t// Exceptions that don't match this convention are listed separately.\n\t//\n\t// prettier-ignore\n\tvar simpleEventPluginEvents=['abort','auxClick','cancel','canPlay','canPlayThrough','click','close','contextMenu','copy','cut','drag','dragEnd','dragEnter','dragExit','dragLeave','dragOver','dragStart','drop','durationChange','emptied','encrypted','ended','error','gotPointerCapture','input','invalid','keyDown','keyPress','keyUp','load','loadedData','loadedMetadata','loadStart','lostPointerCapture','mouseDown','mouseMove','mouseOut','mouseOver','mouseUp','paste','pause','play','playing','pointerCancel','pointerDown','pointerMove','pointerOut','pointerOver','pointerUp','progress','rateChange','reset','resize','seeked','seeking','stalled','submit','suspend','timeUpdate','touchCancel','touchEnd','touchStart','volumeChange','scroll','toggle','touchMove','waiting','wheel'];function registerSimpleEvent(domEventName,reactName){topLevelEventsToReactNames.set(domEventName,reactName);registerTwoPhaseEvent(reactName,[domEventName]);}function registerSimpleEvents(){for(var i=0;i<simpleEventPluginEvents.length;i++){var eventName=simpleEventPluginEvents[i];var domEventName=eventName.toLowerCase();var capitalizedEvent=eventName[0].toUpperCase()+eventName.slice(1);registerSimpleEvent(domEventName,'on'+capitalizedEvent);}// Special cases where event names don't match.\n\tregisterSimpleEvent(ANIMATION_END,'onAnimationEnd');registerSimpleEvent(ANIMATION_ITERATION,'onAnimationIteration');registerSimpleEvent(ANIMATION_START,'onAnimationStart');registerSimpleEvent('dblclick','onDoubleClick');registerSimpleEvent('focusin','onFocus');registerSimpleEvent('focusout','onBlur');registerSimpleEvent(TRANSITION_END,'onTransitionEnd');}function extractEvents$4(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){var reactName=topLevelEventsToReactNames.get(domEventName);if(reactName===undefined){return;}var SyntheticEventCtor=SyntheticEvent;var reactEventType=domEventName;switch(domEventName){case'keypress':// Firefox creates a keypress event for function keys too. This removes\n\t// the unwanted keypress events. Enter is however both printable and\n\t// non-printable. One would expect Tab to be as well (but it isn't).\n\tif(getEventCharCode(nativeEvent)===0){return;}/* falls through */case'keydown':case'keyup':SyntheticEventCtor=SyntheticKeyboardEvent;break;case'focusin':reactEventType='focus';SyntheticEventCtor=SyntheticFocusEvent;break;case'focusout':reactEventType='blur';SyntheticEventCtor=SyntheticFocusEvent;break;case'beforeblur':case'afterblur':SyntheticEventCtor=SyntheticFocusEvent;break;case'click':// Firefox creates a click event on right mouse clicks. This removes the\n\t// unwanted click events.\n\tif(nativeEvent.button===2){return;}/* falls through */case'auxclick':case'dblclick':case'mousedown':case'mousemove':case'mouseup':// TODO: Disabled elements should not respond to mouse events\n\t/* falls through */case'mouseout':case'mouseover':case'contextmenu':SyntheticEventCtor=SyntheticMouseEvent;break;case'drag':case'dragend':case'dragenter':case'dragexit':case'dragleave':case'dragover':case'dragstart':case'drop':SyntheticEventCtor=SyntheticDragEvent;break;case'touchcancel':case'touchend':case'touchmove':case'touchstart':SyntheticEventCtor=SyntheticTouchEvent;break;case ANIMATION_END:case ANIMATION_ITERATION:case ANIMATION_START:SyntheticEventCtor=SyntheticAnimationEvent;break;case TRANSITION_END:SyntheticEventCtor=SyntheticTransitionEvent;break;case'scroll':SyntheticEventCtor=SyntheticUIEvent;break;case'wheel':SyntheticEventCtor=SyntheticWheelEvent;break;case'copy':case'cut':case'paste':SyntheticEventCtor=SyntheticClipboardEvent;break;case'gotpointercapture':case'lostpointercapture':case'pointercancel':case'pointerdown':case'pointermove':case'pointerout':case'pointerover':case'pointerup':SyntheticEventCtor=SyntheticPointerEvent;break;}var inCapturePhase=(eventSystemFlags&IS_CAPTURE_PHASE)!==0;{// Some events don't bubble in the browser.\n\t// In the past, React has always bubbled them, but this can be surprising.\n\t// We're going to try aligning closer to the browser behavior by not bubbling\n\t// them in React either. We'll start by not bubbling onScroll, and then expand.\n\tvar accumulateTargetOnly=!inCapturePhase&&// TODO: ideally, we'd eventually add all events from\n\t// nonDelegatedEvents list in DOMPluginEventSystem.\n\t// Then we can remove this special list.\n\t// This is a breaking change that can wait until React 18.\n\tdomEventName==='scroll';var _listeners=accumulateSinglePhaseListeners(targetInst,reactName,nativeEvent.type,inCapturePhase,accumulateTargetOnly);if(_listeners.length>0){// Intentionally create event lazily.\n\tvar _event=new SyntheticEventCtor(reactName,reactEventType,null,nativeEvent,nativeEventTarget);dispatchQueue.push({event:_event,listeners:_listeners});}}}// TODO: remove top-level side effect.\n\tregisterSimpleEvents();registerEvents$2();registerEvents$1();registerEvents$3();registerEvents();function extractEvents$5(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){// TODO: we should remove the concept of a \"SimpleEventPlugin\".\n\t// This is the basic functionality of the event system. All\n\t// the other plugins are essentially polyfills. So the plugin\n\t// should probably be inlined somewhere and have its logic\n\t// be core the to event system. This would potentially allow\n\t// us to ship builds of React without the polyfilled plugins below.\n\textractEvents$4(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags);var shouldProcessPolyfillPlugins=(eventSystemFlags&SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS)===0;// We don't process these events unless we are in the\n\t// event's native \"bubble\" phase, which means that we're\n\t// not in the capture phase. That's because we emulate\n\t// the capture phase here still. This is a trade-off,\n\t// because in an ideal world we would not emulate and use\n\t// the phases properly, like we do with the SimpleEvent\n\t// plugin. However, the plugins below either expect\n\t// emulation (EnterLeave) or use state localized to that\n\t// plugin (BeforeInput, Change, Select). The state in\n\t// these modules complicates things, as you'll essentially\n\t// get the case where the capture phase event might change\n\t// state, only for the following bubble event to come in\n\t// later and not trigger anything as the state now\n\t// invalidates the heuristics of the event plugin. We\n\t// could alter all these plugins to work in such ways, but\n\t// that might cause other unknown side-effects that we\n\t// can't foresee right now.\n\tif(shouldProcessPolyfillPlugins){extractEvents$2(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget);extractEvents$1(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget);extractEvents$3(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget);extractEvents(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget);}}// List of events that need to be individually attached to media elements.\n\tvar mediaEventTypes=['abort','canplay','canplaythrough','durationchange','emptied','encrypted','ended','error','loadeddata','loadedmetadata','loadstart','pause','play','playing','progress','ratechange','resize','seeked','seeking','stalled','suspend','timeupdate','volumechange','waiting'];// We should not delegate these events to the container, but rather\n\t// set them on the actual target element itself. This is primarily\n\t// because these events do not consistently bubble in the DOM.\n\tvar nonDelegatedEvents=new Set(['cancel','close','invalid','load','scroll','toggle'].concat(mediaEventTypes));function executeDispatch(event,listener,currentTarget){var type=event.type||'unknown-event';event.currentTarget=currentTarget;invokeGuardedCallbackAndCatchFirstError(type,listener,undefined,event);event.currentTarget=null;}function processDispatchQueueItemsInOrder(event,dispatchListeners,inCapturePhase){var previousInstance;if(inCapturePhase){for(var i=dispatchListeners.length-1;i>=0;i--){var _dispatchListeners$i=dispatchListeners[i],instance=_dispatchListeners$i.instance,currentTarget=_dispatchListeners$i.currentTarget,listener=_dispatchListeners$i.listener;if(instance!==previousInstance&&event.isPropagationStopped()){return;}executeDispatch(event,listener,currentTarget);previousInstance=instance;}}else {for(var _i=0;_i<dispatchListeners.length;_i++){var _dispatchListeners$_i=dispatchListeners[_i],_instance=_dispatchListeners$_i.instance,_currentTarget=_dispatchListeners$_i.currentTarget,_listener=_dispatchListeners$_i.listener;if(_instance!==previousInstance&&event.isPropagationStopped()){return;}executeDispatch(event,_listener,_currentTarget);previousInstance=_instance;}}}function processDispatchQueue(dispatchQueue,eventSystemFlags){var inCapturePhase=(eventSystemFlags&IS_CAPTURE_PHASE)!==0;for(var i=0;i<dispatchQueue.length;i++){var _dispatchQueue$i=dispatchQueue[i],event=_dispatchQueue$i.event,listeners=_dispatchQueue$i.listeners;processDispatchQueueItemsInOrder(event,listeners,inCapturePhase);//  event system doesn't use pooling.\n\t}// This would be a good time to rethrow if any of the event handlers threw.\n\trethrowCaughtError();}function dispatchEventsForPlugins(domEventName,eventSystemFlags,nativeEvent,targetInst,targetContainer){var nativeEventTarget=getEventTarget(nativeEvent);var dispatchQueue=[];extractEvents$5(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags);processDispatchQueue(dispatchQueue,eventSystemFlags);}function listenToNonDelegatedEvent(domEventName,targetElement){{if(!nonDelegatedEvents.has(domEventName)){error('Did not expect a listenToNonDelegatedEvent() call for \"%s\". '+'This is a bug in React. Please file an issue.',domEventName);}}var isCapturePhaseListener=false;var listenerSet=getEventListenerSet(targetElement);var listenerSetKey=getListenerSetKey(domEventName,isCapturePhaseListener);if(!listenerSet.has(listenerSetKey)){addTrappedEventListener(targetElement,domEventName,IS_NON_DELEGATED,isCapturePhaseListener);listenerSet.add(listenerSetKey);}}function listenToNativeEvent(domEventName,isCapturePhaseListener,target){{if(nonDelegatedEvents.has(domEventName)&&!isCapturePhaseListener){error('Did not expect a listenToNativeEvent() call for \"%s\" in the bubble phase. '+'This is a bug in React. Please file an issue.',domEventName);}}var eventSystemFlags=0;if(isCapturePhaseListener){eventSystemFlags|=IS_CAPTURE_PHASE;}addTrappedEventListener(target,domEventName,eventSystemFlags,isCapturePhaseListener);}// This is only used by createEventHandle when the\n\tvar listeningMarker='_reactListening'+Math.random().toString(36).slice(2);function listenToAllSupportedEvents(rootContainerElement){if(!rootContainerElement[listeningMarker]){rootContainerElement[listeningMarker]=true;allNativeEvents.forEach(function(domEventName){// We handle selectionchange separately because it\n\t// doesn't bubble and needs to be on the document.\n\tif(domEventName!=='selectionchange'){if(!nonDelegatedEvents.has(domEventName)){listenToNativeEvent(domEventName,false,rootContainerElement);}listenToNativeEvent(domEventName,true,rootContainerElement);}});var ownerDocument=rootContainerElement.nodeType===DOCUMENT_NODE?rootContainerElement:rootContainerElement.ownerDocument;if(ownerDocument!==null){// The selectionchange event also needs deduplication\n\t// but it is attached to the document.\n\tif(!ownerDocument[listeningMarker]){ownerDocument[listeningMarker]=true;listenToNativeEvent('selectionchange',false,ownerDocument);}}}}function addTrappedEventListener(targetContainer,domEventName,eventSystemFlags,isCapturePhaseListener,isDeferredListenerForLegacyFBSupport){var listener=createEventListenerWrapperWithPriority(targetContainer,domEventName,eventSystemFlags);// If passive option is not supported, then the event will be\n\t// active and not passive.\n\tvar isPassiveListener=undefined;if(passiveBrowserEventsSupported){// Browsers introduced an intervention, making these events\n\t// passive by default on document. React doesn't bind them\n\t// to document anymore, but changing this now would undo\n\t// the performance wins from the change. So we emulate\n\t// the existing behavior manually on the roots now.\n\t// https://github.com/facebook/react/issues/19651\n\tif(domEventName==='touchstart'||domEventName==='touchmove'||domEventName==='wheel'){isPassiveListener=true;}}targetContainer=targetContainer;if(isCapturePhaseListener){if(isPassiveListener!==undefined){addEventCaptureListenerWithPassiveFlag(targetContainer,domEventName,listener,isPassiveListener);}else {addEventCaptureListener(targetContainer,domEventName,listener);}}else {if(isPassiveListener!==undefined){addEventBubbleListenerWithPassiveFlag(targetContainer,domEventName,listener,isPassiveListener);}else {addEventBubbleListener(targetContainer,domEventName,listener);}}}function isMatchingRootContainer(grandContainer,targetContainer){return grandContainer===targetContainer||grandContainer.nodeType===COMMENT_NODE&&grandContainer.parentNode===targetContainer;}function dispatchEventForPluginEventSystem(domEventName,eventSystemFlags,nativeEvent,targetInst,targetContainer){var ancestorInst=targetInst;if((eventSystemFlags&IS_EVENT_HANDLE_NON_MANAGED_NODE)===0&&(eventSystemFlags&IS_NON_DELEGATED)===0){var targetContainerNode=targetContainer;// If we are using the legacy FB support flag, we\n\tif(targetInst!==null){// The below logic attempts to work out if we need to change\n\t// the target fiber to a different ancestor. We had similar logic\n\t// in the legacy event system, except the big difference between\n\t// systems is that the modern event system now has an event listener\n\t// attached to each React Root and React Portal Root. Together,\n\t// the DOM nodes representing these roots are the \"rootContainer\".\n\t// To figure out which ancestor instance we should use, we traverse\n\t// up the fiber tree from the target instance and attempt to find\n\t// root boundaries that match that of our current \"rootContainer\".\n\t// If we find that \"rootContainer\", we find the parent fiber\n\t// sub-tree for that root and make that our ancestor instance.\n\tvar node=targetInst;mainLoop:while(true){if(node===null){return;}var nodeTag=node.tag;if(nodeTag===HostRoot||nodeTag===HostPortal){var container=node.stateNode.containerInfo;if(isMatchingRootContainer(container,targetContainerNode)){break;}if(nodeTag===HostPortal){// The target is a portal, but it's not the rootContainer we're looking for.\n\t// Normally portals handle their own events all the way down to the root.\n\t// So we should be able to stop now. However, we don't know if this portal\n\t// was part of *our* root.\n\tvar grandNode=node.return;while(grandNode!==null){var grandTag=grandNode.tag;if(grandTag===HostRoot||grandTag===HostPortal){var grandContainer=grandNode.stateNode.containerInfo;if(isMatchingRootContainer(grandContainer,targetContainerNode)){// This is the rootContainer we're looking for and we found it as\n\t// a parent of the Portal. That means we can ignore it because the\n\t// Portal will bubble through to us.\n\treturn;}}grandNode=grandNode.return;}}// Now we need to find it's corresponding host fiber in the other\n\t// tree. To do this we can use getClosestInstanceFromNode, but we\n\t// need to validate that the fiber is a host instance, otherwise\n\t// we need to traverse up through the DOM till we find the correct\n\t// node that is from the other tree.\n\twhile(container!==null){var parentNode=getClosestInstanceFromNode(container);if(parentNode===null){return;}var parentTag=parentNode.tag;if(parentTag===HostComponent||parentTag===HostText){node=ancestorInst=parentNode;continue mainLoop;}container=container.parentNode;}}node=node.return;}}}batchedUpdates(function(){return dispatchEventsForPlugins(domEventName,eventSystemFlags,nativeEvent,ancestorInst);});}function createDispatchListener(instance,listener,currentTarget){return {instance:instance,listener:listener,currentTarget:currentTarget};}function accumulateSinglePhaseListeners(targetFiber,reactName,nativeEventType,inCapturePhase,accumulateTargetOnly,nativeEvent){var captureName=reactName!==null?reactName+'Capture':null;var reactEventName=inCapturePhase?captureName:reactName;var listeners=[];var instance=targetFiber;var lastHostComponent=null;// Accumulate all instances and listeners via the target -> root path.\n\twhile(instance!==null){var _instance2=instance,stateNode=_instance2.stateNode,tag=_instance2.tag;// Handle listeners that are on HostComponents (i.e. <div>)\n\tif(tag===HostComponent&&stateNode!==null){lastHostComponent=stateNode;// createEventHandle listeners\n\tif(reactEventName!==null){var listener=getListener(instance,reactEventName);if(listener!=null){listeners.push(createDispatchListener(instance,listener,lastHostComponent));}}}// If we are only accumulating events for the target, then we don't\n\t// continue to propagate through the React fiber tree to find other\n\t// listeners.\n\tif(accumulateTargetOnly){break;}// If we are processing the onBeforeBlur event, then we need to take\n\tinstance=instance.return;}return listeners;}// We should only use this function for:\n\t// - BeforeInputEventPlugin\n\t// - ChangeEventPlugin\n\t// - SelectEventPlugin\n\t// This is because we only process these plugins\n\t// in the bubble phase, so we need to accumulate two\n\t// phase event listeners (via emulation).\n\tfunction accumulateTwoPhaseListeners(targetFiber,reactName){var captureName=reactName+'Capture';var listeners=[];var instance=targetFiber;// Accumulate all instances and listeners via the target -> root path.\n\twhile(instance!==null){var _instance3=instance,stateNode=_instance3.stateNode,tag=_instance3.tag;// Handle listeners that are on HostComponents (i.e. <div>)\n\tif(tag===HostComponent&&stateNode!==null){var currentTarget=stateNode;var captureListener=getListener(instance,captureName);if(captureListener!=null){listeners.unshift(createDispatchListener(instance,captureListener,currentTarget));}var bubbleListener=getListener(instance,reactName);if(bubbleListener!=null){listeners.push(createDispatchListener(instance,bubbleListener,currentTarget));}}instance=instance.return;}return listeners;}function getParent(inst){if(inst===null){return null;}do{inst=inst.return;// TODO: If this is a HostRoot we might want to bail out.\n\t// That is depending on if we want nested subtrees (layers) to bubble\n\t// events to their parent. We could also go through parentNode on the\n\t// host node but that wouldn't work for React Native and doesn't let us\n\t// do the portal feature.\n\t}while(inst&&inst.tag!==HostComponent);if(inst){return inst;}return null;}/**\n\t * Return the lowest common ancestor of A and B, or null if they are in\n\t * different trees.\n\t */function getLowestCommonAncestor(instA,instB){var nodeA=instA;var nodeB=instB;var depthA=0;for(var tempA=nodeA;tempA;tempA=getParent(tempA)){depthA++;}var depthB=0;for(var tempB=nodeB;tempB;tempB=getParent(tempB)){depthB++;}// If A is deeper, crawl up.\n\twhile(depthA-depthB>0){nodeA=getParent(nodeA);depthA--;}// If B is deeper, crawl up.\n\twhile(depthB-depthA>0){nodeB=getParent(nodeB);depthB--;}// Walk in lockstep until we find a match.\n\tvar depth=depthA;while(depth--){if(nodeA===nodeB||nodeB!==null&&nodeA===nodeB.alternate){return nodeA;}nodeA=getParent(nodeA);nodeB=getParent(nodeB);}return null;}function accumulateEnterLeaveListenersForEvent(dispatchQueue,event,target,common,inCapturePhase){var registrationName=event._reactName;var listeners=[];var instance=target;while(instance!==null){if(instance===common){break;}var _instance4=instance,alternate=_instance4.alternate,stateNode=_instance4.stateNode,tag=_instance4.tag;if(alternate!==null&&alternate===common){break;}if(tag===HostComponent&&stateNode!==null){var currentTarget=stateNode;if(inCapturePhase){var captureListener=getListener(instance,registrationName);if(captureListener!=null){listeners.unshift(createDispatchListener(instance,captureListener,currentTarget));}}else if(!inCapturePhase){var bubbleListener=getListener(instance,registrationName);if(bubbleListener!=null){listeners.push(createDispatchListener(instance,bubbleListener,currentTarget));}}}instance=instance.return;}if(listeners.length!==0){dispatchQueue.push({event:event,listeners:listeners});}}// We should only use this function for:\n\t// - EnterLeaveEventPlugin\n\t// This is because we only process this plugin\n\t// in the bubble phase, so we need to accumulate two\n\t// phase event listeners.\n\tfunction accumulateEnterLeaveTwoPhaseListeners(dispatchQueue,leaveEvent,enterEvent,from,to){var common=from&&to?getLowestCommonAncestor(from,to):null;if(from!==null){accumulateEnterLeaveListenersForEvent(dispatchQueue,leaveEvent,from,common,false);}if(to!==null&&enterEvent!==null){accumulateEnterLeaveListenersForEvent(dispatchQueue,enterEvent,to,common,true);}}function getListenerSetKey(domEventName,capture){return domEventName+\"__\"+(capture?'capture':'bubble');}var didWarnInvalidHydration=false;var DANGEROUSLY_SET_INNER_HTML='dangerouslySetInnerHTML';var SUPPRESS_CONTENT_EDITABLE_WARNING='suppressContentEditableWarning';var SUPPRESS_HYDRATION_WARNING='suppressHydrationWarning';var AUTOFOCUS='autoFocus';var CHILDREN='children';var STYLE='style';var HTML$1='__html';var warnedUnknownTags;var validatePropertiesInDevelopment;var warnForPropDifference;var warnForExtraAttributes;var warnForInvalidEventListener;var canDiffStyleForHydrationWarning;var normalizeHTML;{warnedUnknownTags={// There are working polyfills for <dialog>. Let people use it.\n\tdialog:true,// Electron ships a custom <webview> tag to display external web content in\n\t// an isolated frame and process.\n\t// This tag is not present in non Electron environments such as JSDom which\n\t// is often used for testing purposes.\n\t// @see https://electronjs.org/docs/api/webview-tag\n\twebview:true};validatePropertiesInDevelopment=function(type,props){validateProperties(type,props);validateProperties$1(type,props);validateProperties$2(type,props,{registrationNameDependencies:registrationNameDependencies,possibleRegistrationNames:possibleRegistrationNames});};// IE 11 parses & normalizes the style attribute as opposed to other\n\t// browsers. It adds spaces and sorts the properties in some\n\t// non-alphabetical order. Handling that would require sorting CSS\n\t// properties in the client & server versions or applying\n\t// `expectedStyle` to a temporary DOM node to read its `style` attribute\n\t// normalized. Since it only affects IE, we're skipping style warnings\n\t// in that browser completely in favor of doing all that work.\n\t// See https://github.com/facebook/react/issues/11807\n\tcanDiffStyleForHydrationWarning=canUseDOM&&!document.documentMode;warnForPropDifference=function(propName,serverValue,clientValue){if(didWarnInvalidHydration){return;}var normalizedClientValue=normalizeMarkupForTextOrAttribute(clientValue);var normalizedServerValue=normalizeMarkupForTextOrAttribute(serverValue);if(normalizedServerValue===normalizedClientValue){return;}didWarnInvalidHydration=true;error('Prop `%s` did not match. Server: %s Client: %s',propName,JSON.stringify(normalizedServerValue),JSON.stringify(normalizedClientValue));};warnForExtraAttributes=function(attributeNames){if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;var names=[];attributeNames.forEach(function(name){names.push(name);});error('Extra attributes from the server: %s',names);};warnForInvalidEventListener=function(registrationName,listener){if(listener===false){error('Expected `%s` listener to be a function, instead got `false`.\\n\\n'+'If you used to conditionally omit it with %s={condition && value}, '+'pass %s={condition ? value : undefined} instead.',registrationName,registrationName,registrationName);}else {error('Expected `%s` listener to be a function, instead got a value of `%s` type.',registrationName,typeof listener);}};// Parse the HTML and read it back to normalize the HTML string so that it\n\t// can be used for comparison.\n\tnormalizeHTML=function(parent,html){// We could have created a separate document here to avoid\n\t// re-initializing custom elements if they exist. But this breaks\n\t// how <noscript> is being handled. So we use the same document.\n\t// See the discussion in https://github.com/facebook/react/pull/11157.\n\tvar testElement=parent.namespaceURI===HTML_NAMESPACE?parent.ownerDocument.createElement(parent.tagName):parent.ownerDocument.createElementNS(parent.namespaceURI,parent.tagName);testElement.innerHTML=html;return testElement.innerHTML;};}// HTML parsing normalizes CR and CRLF to LF.\n\t// It also can turn \\u0000 into \\uFFFD inside attributes.\n\t// https://www.w3.org/TR/html5/single-page.html#preprocessing-the-input-stream\n\t// If we have a mismatch, it might be caused by that.\n\t// We will still patch up in this case but not fire the warning.\n\tvar NORMALIZE_NEWLINES_REGEX=/\\r\\n?/g;var NORMALIZE_NULL_AND_REPLACEMENT_REGEX=/\\u0000|\\uFFFD/g;function normalizeMarkupForTextOrAttribute(markup){{checkHtmlStringCoercion(markup);}var markupString=typeof markup==='string'?markup:''+markup;return markupString.replace(NORMALIZE_NEWLINES_REGEX,'\\n').replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX,'');}function checkForUnmatchedText(serverText,clientText,isConcurrentMode,shouldWarnDev){var normalizedClientText=normalizeMarkupForTextOrAttribute(clientText);var normalizedServerText=normalizeMarkupForTextOrAttribute(serverText);if(normalizedServerText===normalizedClientText){return;}if(shouldWarnDev){{if(!didWarnInvalidHydration){didWarnInvalidHydration=true;error('Text content did not match. Server: \"%s\" Client: \"%s\"',normalizedServerText,normalizedClientText);}}}if(isConcurrentMode&&enableClientRenderFallbackOnTextMismatch){// In concurrent roots, we throw when there's a text mismatch and revert to\n\t// client rendering, up to the nearest Suspense boundary.\n\tthrow new Error('Text content does not match server-rendered HTML.');}}function getOwnerDocumentFromRootContainer(rootContainerElement){return rootContainerElement.nodeType===DOCUMENT_NODE?rootContainerElement:rootContainerElement.ownerDocument;}function noop(){}function trapClickOnNonInteractiveElement(node){// Mobile Safari does not fire properly bubble click events on\n\t// non-interactive elements, which means delegated click listeners do not\n\t// fire. The workaround for this bug involves attaching an empty click\n\t// listener on the target node.\n\t// https://www.quirksmode.org/blog/archives/2010/09/click_event_del.html\n\t// Just set it using the onclick property so that we don't have to manage any\n\t// bookkeeping for it. Not sure if we need to clear it when the listener is\n\t// removed.\n\t// TODO: Only do this for the relevant Safaris maybe?\n\tnode.onclick=noop;}function setInitialDOMProperties(tag,domElement,rootContainerElement,nextProps,isCustomComponentTag){for(var propKey in nextProps){if(!nextProps.hasOwnProperty(propKey)){continue;}var nextProp=nextProps[propKey];if(propKey===STYLE){{if(nextProp){// Freeze the next style object so that we can assume it won't be\n\t// mutated. We have already warned for this in the past.\n\tObject.freeze(nextProp);}}// Relies on `updateStylesByID` not mutating `styleUpdates`.\n\tsetValueForStyles(domElement,nextProp);}else if(propKey===DANGEROUSLY_SET_INNER_HTML){var nextHtml=nextProp?nextProp[HTML$1]:undefined;if(nextHtml!=null){setInnerHTML(domElement,nextHtml);}}else if(propKey===CHILDREN){if(typeof nextProp==='string'){// Avoid setting initial textContent when the text is empty. In IE11 setting\n\t// textContent on a <textarea> will cause the placeholder to not\n\t// show within the <textarea> until it has been focused and blurred again.\n\t// https://github.com/facebook/react/issues/6731#issuecomment-254874553\n\tvar canSetTextContent=tag!=='textarea'||nextProp!=='';if(canSetTextContent){setTextContent(domElement,nextProp);}}else if(typeof nextProp==='number'){setTextContent(domElement,''+nextProp);}}else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING);else if(propKey===AUTOFOCUS);else if(registrationNameDependencies.hasOwnProperty(propKey)){if(nextProp!=null){if(typeof nextProp!=='function'){warnForInvalidEventListener(propKey,nextProp);}if(propKey==='onScroll'){listenToNonDelegatedEvent('scroll',domElement);}}}else if(nextProp!=null){setValueForProperty(domElement,propKey,nextProp,isCustomComponentTag);}}}function updateDOMProperties(domElement,updatePayload,wasCustomComponentTag,isCustomComponentTag){// TODO: Handle wasCustomComponentTag\n\tfor(var i=0;i<updatePayload.length;i+=2){var propKey=updatePayload[i];var propValue=updatePayload[i+1];if(propKey===STYLE){setValueForStyles(domElement,propValue);}else if(propKey===DANGEROUSLY_SET_INNER_HTML){setInnerHTML(domElement,propValue);}else if(propKey===CHILDREN){setTextContent(domElement,propValue);}else {setValueForProperty(domElement,propKey,propValue,isCustomComponentTag);}}}function createElement(type,props,rootContainerElement,parentNamespace){var isCustomComponentTag;// We create tags in the namespace of their parent container, except HTML\n\t// tags get no namespace.\n\tvar ownerDocument=getOwnerDocumentFromRootContainer(rootContainerElement);var domElement;var namespaceURI=parentNamespace;if(namespaceURI===HTML_NAMESPACE){namespaceURI=getIntrinsicNamespace(type);}if(namespaceURI===HTML_NAMESPACE){{isCustomComponentTag=isCustomComponent(type,props);// Should this check be gated by parent namespace? Not sure we want to\n\t// allow <SVG> or <mATH>.\n\tif(!isCustomComponentTag&&type!==type.toLowerCase()){error('<%s /> is using incorrect casing. '+'Use PascalCase for React components, '+'or lowercase for HTML elements.',type);}}if(type==='script'){// Create the script via .innerHTML so its \"parser-inserted\" flag is\n\t// set to true and it does not execute\n\tvar div=ownerDocument.createElement('div');div.innerHTML='<script><'+'/script>';// eslint-disable-line\n\t// This is guaranteed to yield a script element.\n\tvar firstChild=div.firstChild;domElement=div.removeChild(firstChild);}else if(typeof props.is==='string'){// $FlowIssue `createElement` should be updated for Web Components\n\tdomElement=ownerDocument.createElement(type,{is:props.is});}else {// Separate else branch instead of using `props.is || undefined` above because of a Firefox bug.\n\t// See discussion in https://github.com/facebook/react/pull/6896\n\t// and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240\n\tdomElement=ownerDocument.createElement(type);// Normally attributes are assigned in `setInitialDOMProperties`, however the `multiple` and `size`\n\t// attributes on `select`s needs to be added before `option`s are inserted.\n\t// This prevents:\n\t// - a bug where the `select` does not scroll to the correct option because singular\n\t//  `select` elements automatically pick the first item #13222\n\t// - a bug where the `select` set the first item as selected despite the `size` attribute #14239\n\t// See https://github.com/facebook/react/issues/13222\n\t// and https://github.com/facebook/react/issues/14239\n\tif(type==='select'){var node=domElement;if(props.multiple){node.multiple=true;}else if(props.size){// Setting a size greater than 1 causes a select to behave like `multiple=true`, where\n\t// it is possible that no option is selected.\n\t//\n\t// This is only necessary when a select in \"single selection mode\".\n\tnode.size=props.size;}}}}else {domElement=ownerDocument.createElementNS(namespaceURI,type);}{if(namespaceURI===HTML_NAMESPACE){if(!isCustomComponentTag&&Object.prototype.toString.call(domElement)==='[object HTMLUnknownElement]'&&!hasOwnProperty.call(warnedUnknownTags,type)){warnedUnknownTags[type]=true;error('The tag <%s> is unrecognized in this browser. '+'If you meant to render a React component, start its name with '+'an uppercase letter.',type);}}}return domElement;}function createTextNode(text,rootContainerElement){return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);}function setInitialProperties(domElement,tag,rawProps,rootContainerElement){var isCustomComponentTag=isCustomComponent(tag,rawProps);{validatePropertiesInDevelopment(tag,rawProps);}// TODO: Make sure that we check isMounted before firing any of these events.\n\tvar props;switch(tag){case'dialog':listenToNonDelegatedEvent('cancel',domElement);listenToNonDelegatedEvent('close',domElement);props=rawProps;break;case'iframe':case'object':case'embed':// We listen to this event in case to ensure emulated bubble\n\t// listeners still fire for the load event.\n\tlistenToNonDelegatedEvent('load',domElement);props=rawProps;break;case'video':case'audio':// We listen to these events in case to ensure emulated bubble\n\t// listeners still fire for all the media events.\n\tfor(var i=0;i<mediaEventTypes.length;i++){listenToNonDelegatedEvent(mediaEventTypes[i],domElement);}props=rawProps;break;case'source':// We listen to this event in case to ensure emulated bubble\n\t// listeners still fire for the error event.\n\tlistenToNonDelegatedEvent('error',domElement);props=rawProps;break;case'img':case'image':case'link':// We listen to these events in case to ensure emulated bubble\n\t// listeners still fire for error and load events.\n\tlistenToNonDelegatedEvent('error',domElement);listenToNonDelegatedEvent('load',domElement);props=rawProps;break;case'details':// We listen to this event in case to ensure emulated bubble\n\t// listeners still fire for the toggle event.\n\tlistenToNonDelegatedEvent('toggle',domElement);props=rawProps;break;case'input':initWrapperState(domElement,rawProps);props=getHostProps(domElement,rawProps);// We listen to this event in case to ensure emulated bubble\n\t// listeners still fire for the invalid event.\n\tlistenToNonDelegatedEvent('invalid',domElement);break;case'option':validateProps(domElement,rawProps);props=rawProps;break;case'select':initWrapperState$1(domElement,rawProps);props=getHostProps$1(domElement,rawProps);// We listen to this event in case to ensure emulated bubble\n\t// listeners still fire for the invalid event.\n\tlistenToNonDelegatedEvent('invalid',domElement);break;case'textarea':initWrapperState$2(domElement,rawProps);props=getHostProps$2(domElement,rawProps);// We listen to this event in case to ensure emulated bubble\n\t// listeners still fire for the invalid event.\n\tlistenToNonDelegatedEvent('invalid',domElement);break;default:props=rawProps;}assertValidProps(tag,props);setInitialDOMProperties(tag,domElement,rootContainerElement,props,isCustomComponentTag);switch(tag){case'input':// TODO: Make sure we check if this is still unmounted or do any clean\n\t// up necessary since we never stop tracking anymore.\n\ttrack(domElement);postMountWrapper(domElement,rawProps,false);break;case'textarea':// TODO: Make sure we check if this is still unmounted or do any clean\n\t// up necessary since we never stop tracking anymore.\n\ttrack(domElement);postMountWrapper$3(domElement);break;case'option':postMountWrapper$1(domElement,rawProps);break;case'select':postMountWrapper$2(domElement,rawProps);break;default:if(typeof props.onClick==='function'){// TODO: This cast may not be sound for SVG, MathML or custom elements.\n\ttrapClickOnNonInteractiveElement(domElement);}break;}}// Calculate the diff between the two objects.\n\tfunction diffProperties(domElement,tag,lastRawProps,nextRawProps,rootContainerElement){{validatePropertiesInDevelopment(tag,nextRawProps);}var updatePayload=null;var lastProps;var nextProps;switch(tag){case'input':lastProps=getHostProps(domElement,lastRawProps);nextProps=getHostProps(domElement,nextRawProps);updatePayload=[];break;case'select':lastProps=getHostProps$1(domElement,lastRawProps);nextProps=getHostProps$1(domElement,nextRawProps);updatePayload=[];break;case'textarea':lastProps=getHostProps$2(domElement,lastRawProps);nextProps=getHostProps$2(domElement,nextRawProps);updatePayload=[];break;default:lastProps=lastRawProps;nextProps=nextRawProps;if(typeof lastProps.onClick!=='function'&&typeof nextProps.onClick==='function'){// TODO: This cast may not be sound for SVG, MathML or custom elements.\n\ttrapClickOnNonInteractiveElement(domElement);}break;}assertValidProps(tag,nextProps);var propKey;var styleName;var styleUpdates=null;for(propKey in lastProps){if(nextProps.hasOwnProperty(propKey)||!lastProps.hasOwnProperty(propKey)||lastProps[propKey]==null){continue;}if(propKey===STYLE){var lastStyle=lastProps[propKey];for(styleName in lastStyle){if(lastStyle.hasOwnProperty(styleName)){if(!styleUpdates){styleUpdates={};}styleUpdates[styleName]='';}}}else if(propKey===DANGEROUSLY_SET_INNER_HTML||propKey===CHILDREN);else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING);else if(propKey===AUTOFOCUS);else if(registrationNameDependencies.hasOwnProperty(propKey)){// This is a special case. If any listener updates we need to ensure\n\t// that the \"current\" fiber pointer gets updated so we need a commit\n\t// to update this element.\n\tif(!updatePayload){updatePayload=[];}}else {// For all other deleted properties we add it to the queue. We use\n\t// the allowed property list in the commit phase instead.\n\t(updatePayload=updatePayload||[]).push(propKey,null);}}for(propKey in nextProps){var nextProp=nextProps[propKey];var lastProp=lastProps!=null?lastProps[propKey]:undefined;if(!nextProps.hasOwnProperty(propKey)||nextProp===lastProp||nextProp==null&&lastProp==null){continue;}if(propKey===STYLE){{if(nextProp){// Freeze the next style object so that we can assume it won't be\n\t// mutated. We have already warned for this in the past.\n\tObject.freeze(nextProp);}}if(lastProp){// Unset styles on `lastProp` but not on `nextProp`.\n\tfor(styleName in lastProp){if(lastProp.hasOwnProperty(styleName)&&(!nextProp||!nextProp.hasOwnProperty(styleName))){if(!styleUpdates){styleUpdates={};}styleUpdates[styleName]='';}}// Update styles that changed since `lastProp`.\n\tfor(styleName in nextProp){if(nextProp.hasOwnProperty(styleName)&&lastProp[styleName]!==nextProp[styleName]){if(!styleUpdates){styleUpdates={};}styleUpdates[styleName]=nextProp[styleName];}}}else {// Relies on `updateStylesByID` not mutating `styleUpdates`.\n\tif(!styleUpdates){if(!updatePayload){updatePayload=[];}updatePayload.push(propKey,styleUpdates);}styleUpdates=nextProp;}}else if(propKey===DANGEROUSLY_SET_INNER_HTML){var nextHtml=nextProp?nextProp[HTML$1]:undefined;var lastHtml=lastProp?lastProp[HTML$1]:undefined;if(nextHtml!=null){if(lastHtml!==nextHtml){(updatePayload=updatePayload||[]).push(propKey,nextHtml);}}}else if(propKey===CHILDREN){if(typeof nextProp==='string'||typeof nextProp==='number'){(updatePayload=updatePayload||[]).push(propKey,''+nextProp);}}else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING);else if(registrationNameDependencies.hasOwnProperty(propKey)){if(nextProp!=null){// We eagerly listen to this even though we haven't committed yet.\n\tif(typeof nextProp!=='function'){warnForInvalidEventListener(propKey,nextProp);}if(propKey==='onScroll'){listenToNonDelegatedEvent('scroll',domElement);}}if(!updatePayload&&lastProp!==nextProp){// This is a special case. If any listener updates we need to ensure\n\t// that the \"current\" props pointer gets updated so we need a commit\n\t// to update this element.\n\tupdatePayload=[];}}else {// For any other property we always add it to the queue and then we\n\t// filter it out using the allowed property list during the commit.\n\t(updatePayload=updatePayload||[]).push(propKey,nextProp);}}if(styleUpdates){{validateShorthandPropertyCollisionInDev(styleUpdates,nextProps[STYLE]);}(updatePayload=updatePayload||[]).push(STYLE,styleUpdates);}return updatePayload;}// Apply the diff.\n\tfunction updateProperties(domElement,updatePayload,tag,lastRawProps,nextRawProps){// Update checked *before* name.\n\t// In the middle of an update, it is possible to have multiple checked.\n\t// When a checked radio tries to change name, browser makes another radio's checked false.\n\tif(tag==='input'&&nextRawProps.type==='radio'&&nextRawProps.name!=null){updateChecked(domElement,nextRawProps);}var wasCustomComponentTag=isCustomComponent(tag,lastRawProps);var isCustomComponentTag=isCustomComponent(tag,nextRawProps);// Apply the diff.\n\tupdateDOMProperties(domElement,updatePayload,wasCustomComponentTag,isCustomComponentTag);// TODO: Ensure that an update gets scheduled if any of the special props\n\t// changed.\n\tswitch(tag){case'input':// Update the wrapper around inputs *after* updating props. This has to\n\t// happen after `updateDOMProperties`. Otherwise HTML5 input validations\n\t// raise warnings and prevent the new value from being assigned.\n\tupdateWrapper(domElement,nextRawProps);break;case'textarea':updateWrapper$1(domElement,nextRawProps);break;case'select':// <select> value update needs to occur after <option> children\n\t// reconciliation\n\tpostUpdateWrapper(domElement,nextRawProps);break;}}function getPossibleStandardName(propName){{var lowerCasedName=propName.toLowerCase();if(!possibleStandardNames.hasOwnProperty(lowerCasedName)){return null;}return possibleStandardNames[lowerCasedName]||null;}}function diffHydratedProperties(domElement,tag,rawProps,parentNamespace,rootContainerElement,isConcurrentMode,shouldWarnDev){var isCustomComponentTag;var extraAttributeNames;{isCustomComponentTag=isCustomComponent(tag,rawProps);validatePropertiesInDevelopment(tag,rawProps);}// TODO: Make sure that we check isMounted before firing any of these events.\n\tswitch(tag){case'dialog':listenToNonDelegatedEvent('cancel',domElement);listenToNonDelegatedEvent('close',domElement);break;case'iframe':case'object':case'embed':// We listen to this event in case to ensure emulated bubble\n\t// listeners still fire for the load event.\n\tlistenToNonDelegatedEvent('load',domElement);break;case'video':case'audio':// We listen to these events in case to ensure emulated bubble\n\t// listeners still fire for all the media events.\n\tfor(var i=0;i<mediaEventTypes.length;i++){listenToNonDelegatedEvent(mediaEventTypes[i],domElement);}break;case'source':// We listen to this event in case to ensure emulated bubble\n\t// listeners still fire for the error event.\n\tlistenToNonDelegatedEvent('error',domElement);break;case'img':case'image':case'link':// We listen to these events in case to ensure emulated bubble\n\t// listeners still fire for error and load events.\n\tlistenToNonDelegatedEvent('error',domElement);listenToNonDelegatedEvent('load',domElement);break;case'details':// We listen to this event in case to ensure emulated bubble\n\t// listeners still fire for the toggle event.\n\tlistenToNonDelegatedEvent('toggle',domElement);break;case'input':initWrapperState(domElement,rawProps);// We listen to this event in case to ensure emulated bubble\n\t// listeners still fire for the invalid event.\n\tlistenToNonDelegatedEvent('invalid',domElement);break;case'option':validateProps(domElement,rawProps);break;case'select':initWrapperState$1(domElement,rawProps);// We listen to this event in case to ensure emulated bubble\n\t// listeners still fire for the invalid event.\n\tlistenToNonDelegatedEvent('invalid',domElement);break;case'textarea':initWrapperState$2(domElement,rawProps);// We listen to this event in case to ensure emulated bubble\n\t// listeners still fire for the invalid event.\n\tlistenToNonDelegatedEvent('invalid',domElement);break;}assertValidProps(tag,rawProps);{extraAttributeNames=new Set();var attributes=domElement.attributes;for(var _i=0;_i<attributes.length;_i++){var name=attributes[_i].name.toLowerCase();switch(name){// Controlled attributes are not validated\n\t// TODO: Only ignore them on controlled tags.\n\tcase'value':break;case'checked':break;case'selected':break;default:// Intentionally use the original name.\n\t// See discussion in https://github.com/facebook/react/pull/10676.\n\textraAttributeNames.add(attributes[_i].name);}}}var updatePayload=null;for(var propKey in rawProps){if(!rawProps.hasOwnProperty(propKey)){continue;}var nextProp=rawProps[propKey];if(propKey===CHILDREN){// For text content children we compare against textContent. This\n\t// might match additional HTML that is hidden when we read it using\n\t// textContent. E.g. \"foo\" will match \"f<span>oo</span>\" but that still\n\t// satisfies our requirement. Our requirement is not to produce perfect\n\t// HTML and attributes. Ideally we should preserve structure but it's\n\t// ok not to if the visible content is still enough to indicate what\n\t// even listeners these nodes might be wired up to.\n\t// TODO: Warn if there is more than a single textNode as a child.\n\t// TODO: Should we use domElement.firstChild.nodeValue to compare?\n\tif(typeof nextProp==='string'){if(domElement.textContent!==nextProp){if(rawProps[SUPPRESS_HYDRATION_WARNING]!==true){checkForUnmatchedText(domElement.textContent,nextProp,isConcurrentMode,shouldWarnDev);}updatePayload=[CHILDREN,nextProp];}}else if(typeof nextProp==='number'){if(domElement.textContent!==''+nextProp){if(rawProps[SUPPRESS_HYDRATION_WARNING]!==true){checkForUnmatchedText(domElement.textContent,nextProp,isConcurrentMode,shouldWarnDev);}updatePayload=[CHILDREN,''+nextProp];}}}else if(registrationNameDependencies.hasOwnProperty(propKey)){if(nextProp!=null){if(typeof nextProp!=='function'){warnForInvalidEventListener(propKey,nextProp);}if(propKey==='onScroll'){listenToNonDelegatedEvent('scroll',domElement);}}}else if(shouldWarnDev&&true&&// Convince Flow we've calculated it (it's DEV-only in this method.)\n\ttypeof isCustomComponentTag==='boolean'){// Validate that the properties correspond to their expected values.\n\tvar serverValue=void 0;var propertyInfo=isCustomComponentTag&&enableCustomElementPropertySupport?null:getPropertyInfo(propKey);if(rawProps[SUPPRESS_HYDRATION_WARNING]===true);else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING||// Controlled attributes are not validated\n\t// TODO: Only ignore them on controlled tags.\n\tpropKey==='value'||propKey==='checked'||propKey==='selected');else if(propKey===DANGEROUSLY_SET_INNER_HTML){var serverHTML=domElement.innerHTML;var nextHtml=nextProp?nextProp[HTML$1]:undefined;if(nextHtml!=null){var expectedHTML=normalizeHTML(domElement,nextHtml);if(expectedHTML!==serverHTML){warnForPropDifference(propKey,serverHTML,expectedHTML);}}}else if(propKey===STYLE){// $FlowFixMe - Should be inferred as not undefined.\n\textraAttributeNames.delete(propKey);if(canDiffStyleForHydrationWarning){var expectedStyle=createDangerousStringForStyles(nextProp);serverValue=domElement.getAttribute('style');if(expectedStyle!==serverValue){warnForPropDifference(propKey,serverValue,expectedStyle);}}}else if(isCustomComponentTag&&!enableCustomElementPropertySupport){// $FlowFixMe - Should be inferred as not undefined.\n\textraAttributeNames.delete(propKey.toLowerCase());serverValue=getValueForAttribute(domElement,propKey,nextProp);if(nextProp!==serverValue){warnForPropDifference(propKey,serverValue,nextProp);}}else if(!shouldIgnoreAttribute(propKey,propertyInfo,isCustomComponentTag)&&!shouldRemoveAttribute(propKey,nextProp,propertyInfo,isCustomComponentTag)){var isMismatchDueToBadCasing=false;if(propertyInfo!==null){// $FlowFixMe - Should be inferred as not undefined.\n\textraAttributeNames.delete(propertyInfo.attributeName);serverValue=getValueForProperty(domElement,propKey,nextProp,propertyInfo);}else {var ownNamespace=parentNamespace;if(ownNamespace===HTML_NAMESPACE){ownNamespace=getIntrinsicNamespace(tag);}if(ownNamespace===HTML_NAMESPACE){// $FlowFixMe - Should be inferred as not undefined.\n\textraAttributeNames.delete(propKey.toLowerCase());}else {var standardName=getPossibleStandardName(propKey);if(standardName!==null&&standardName!==propKey){// If an SVG prop is supplied with bad casing, it will\n\t// be successfully parsed from HTML, but will produce a mismatch\n\t// (and would be incorrectly rendered on the client).\n\t// However, we already warn about bad casing elsewhere.\n\t// So we'll skip the misleading extra mismatch warning in this case.\n\tisMismatchDueToBadCasing=true;// $FlowFixMe - Should be inferred as not undefined.\n\textraAttributeNames.delete(standardName);}// $FlowFixMe - Should be inferred as not undefined.\n\textraAttributeNames.delete(propKey);}serverValue=getValueForAttribute(domElement,propKey,nextProp);}var dontWarnCustomElement=enableCustomElementPropertySupport;if(!dontWarnCustomElement&&nextProp!==serverValue&&!isMismatchDueToBadCasing){warnForPropDifference(propKey,serverValue,nextProp);}}}}{if(shouldWarnDev){if(// $FlowFixMe - Should be inferred as not undefined.\n\textraAttributeNames.size>0&&rawProps[SUPPRESS_HYDRATION_WARNING]!==true){// $FlowFixMe - Should be inferred as not undefined.\n\twarnForExtraAttributes(extraAttributeNames);}}}switch(tag){case'input':// TODO: Make sure we check if this is still unmounted or do any clean\n\t// up necessary since we never stop tracking anymore.\n\ttrack(domElement);postMountWrapper(domElement,rawProps,true);break;case'textarea':// TODO: Make sure we check if this is still unmounted or do any clean\n\t// up necessary since we never stop tracking anymore.\n\ttrack(domElement);postMountWrapper$3(domElement);break;case'select':case'option':// For input and textarea we current always set the value property at\n\t// post mount to force it to diverge from attributes. However, for\n\t// option and select we don't quite do the same thing and select\n\t// is not resilient to the DOM state changing so we don't do that here.\n\t// TODO: Consider not doing this for input and textarea.\n\tbreak;default:if(typeof rawProps.onClick==='function'){// TODO: This cast may not be sound for SVG, MathML or custom elements.\n\ttrapClickOnNonInteractiveElement(domElement);}break;}return updatePayload;}function diffHydratedText(textNode,text,isConcurrentMode){var isDifferent=textNode.nodeValue!==text;return isDifferent;}function warnForDeletedHydratableElement(parentNode,child){{if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;error('Did not expect server HTML to contain a <%s> in <%s>.',child.nodeName.toLowerCase(),parentNode.nodeName.toLowerCase());}}function warnForDeletedHydratableText(parentNode,child){{if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;error('Did not expect server HTML to contain the text node \"%s\" in <%s>.',child.nodeValue,parentNode.nodeName.toLowerCase());}}function warnForInsertedHydratedElement(parentNode,tag,props){{if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;error('Expected server HTML to contain a matching <%s> in <%s>.',tag,parentNode.nodeName.toLowerCase());}}function warnForInsertedHydratedText(parentNode,text){{if(text===''){// We expect to insert empty text nodes since they're not represented in\n\t// the HTML.\n\t// TODO: Remove this special case if we can just avoid inserting empty\n\t// text nodes.\n\treturn;}if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;error('Expected server HTML to contain a matching text node for \"%s\" in <%s>.',text,parentNode.nodeName.toLowerCase());}}function restoreControlledState$3(domElement,tag,props){switch(tag){case'input':restoreControlledState(domElement,props);return;case'textarea':restoreControlledState$2(domElement,props);return;case'select':restoreControlledState$1(domElement,props);return;}}var validateDOMNesting=function(){};var updatedAncestorInfo=function(){};{// This validation code was written based on the HTML5 parsing spec:\n\t// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope\n\t//\n\t// Note: this does not catch all invalid nesting, nor does it try to (as it's\n\t// not clear what practical benefit doing so provides); instead, we warn only\n\t// for cases where the parser will give a parse tree differing from what React\n\t// intended. For example, <b><div></div></b> is invalid but we don't warn\n\t// because it still parses correctly; we do warn for other cases like nested\n\t// <p> tags where the beginning of the second element implicitly closes the\n\t// first, causing a confusing mess.\n\t// https://html.spec.whatwg.org/multipage/syntax.html#special\n\tvar specialTags=['address','applet','area','article','aside','base','basefont','bgsound','blockquote','body','br','button','caption','center','col','colgroup','dd','details','dir','div','dl','dt','embed','fieldset','figcaption','figure','footer','form','frame','frameset','h1','h2','h3','h4','h5','h6','head','header','hgroup','hr','html','iframe','img','input','isindex','li','link','listing','main','marquee','menu','menuitem','meta','nav','noembed','noframes','noscript','object','ol','p','param','plaintext','pre','script','section','select','source','style','summary','table','tbody','td','template','textarea','tfoot','th','thead','title','tr','track','ul','wbr','xmp'];// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope\n\tvar inScopeTags=['applet','caption','html','table','td','th','marquee','object','template',// https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point\n\t// TODO: Distinguish by namespace here -- for <title>, including it here\n\t// errs on the side of fewer warnings\n\t'foreignObject','desc','title'];// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope\n\tvar buttonScopeTags=inScopeTags.concat(['button']);// https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags\n\tvar impliedEndTags=['dd','dt','li','option','optgroup','p','rp','rt'];var emptyAncestorInfo={current:null,formTag:null,aTagInScope:null,buttonTagInScope:null,nobrTagInScope:null,pTagInButtonScope:null,listItemTagAutoclosing:null,dlItemTagAutoclosing:null};updatedAncestorInfo=function(oldInfo,tag){var ancestorInfo=assign({},oldInfo||emptyAncestorInfo);var info={tag:tag};if(inScopeTags.indexOf(tag)!==-1){ancestorInfo.aTagInScope=null;ancestorInfo.buttonTagInScope=null;ancestorInfo.nobrTagInScope=null;}if(buttonScopeTags.indexOf(tag)!==-1){ancestorInfo.pTagInButtonScope=null;}// See rules for 'li', 'dd', 'dt' start tags in\n\t// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody\n\tif(specialTags.indexOf(tag)!==-1&&tag!=='address'&&tag!=='div'&&tag!=='p'){ancestorInfo.listItemTagAutoclosing=null;ancestorInfo.dlItemTagAutoclosing=null;}ancestorInfo.current=info;if(tag==='form'){ancestorInfo.formTag=info;}if(tag==='a'){ancestorInfo.aTagInScope=info;}if(tag==='button'){ancestorInfo.buttonTagInScope=info;}if(tag==='nobr'){ancestorInfo.nobrTagInScope=info;}if(tag==='p'){ancestorInfo.pTagInButtonScope=info;}if(tag==='li'){ancestorInfo.listItemTagAutoclosing=info;}if(tag==='dd'||tag==='dt'){ancestorInfo.dlItemTagAutoclosing=info;}return ancestorInfo;};/**\n\t   * Returns whether\n\t   */var isTagValidWithParent=function(tag,parentTag){// First, let's check if we're in an unusual parsing mode...\n\tswitch(parentTag){// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect\n\tcase'select':return tag==='option'||tag==='optgroup'||tag==='#text';case'optgroup':return tag==='option'||tag==='#text';// Strictly speaking, seeing an <option> doesn't mean we're in a <select>\n\t// but\n\tcase'option':return tag==='#text';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd\n\t// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption\n\t// No special behavior since these rules fall back to \"in body\" mode for\n\t// all except special table nodes which cause bad parsing behavior anyway.\n\t// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr\n\tcase'tr':return tag==='th'||tag==='td'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody\n\tcase'tbody':case'thead':case'tfoot':return tag==='tr'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup\n\tcase'colgroup':return tag==='col'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable\n\tcase'table':return tag==='caption'||tag==='colgroup'||tag==='tbody'||tag==='tfoot'||tag==='thead'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead\n\tcase'head':return tag==='base'||tag==='basefont'||tag==='bgsound'||tag==='link'||tag==='meta'||tag==='title'||tag==='noscript'||tag==='noframes'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/semantics.html#the-html-element\n\tcase'html':return tag==='head'||tag==='body'||tag==='frameset';case'frameset':return tag==='frame';case'#document':return tag==='html';}// Probably in the \"in body\" parsing mode, so we outlaw only tag combos\n\t// where the parsing rules cause implicit opens or closes to be added.\n\t// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody\n\tswitch(tag){case'h1':case'h2':case'h3':case'h4':case'h5':case'h6':return parentTag!=='h1'&&parentTag!=='h2'&&parentTag!=='h3'&&parentTag!=='h4'&&parentTag!=='h5'&&parentTag!=='h6';case'rp':case'rt':return impliedEndTags.indexOf(parentTag)===-1;case'body':case'caption':case'col':case'colgroup':case'frameset':case'frame':case'head':case'html':case'tbody':case'td':case'tfoot':case'th':case'thead':case'tr':// These tags are only valid with a few parents that have special child\n\t// parsing rules -- if we're down here, then none of those matched and\n\t// so we allow it only if we don't know what the parent is, as all other\n\t// cases are invalid.\n\treturn parentTag==null;}return true;};/**\n\t   * Returns whether\n\t   */var findInvalidAncestorForTag=function(tag,ancestorInfo){switch(tag){case'address':case'article':case'aside':case'blockquote':case'center':case'details':case'dialog':case'dir':case'div':case'dl':case'fieldset':case'figcaption':case'figure':case'footer':case'header':case'hgroup':case'main':case'menu':case'nav':case'ol':case'p':case'section':case'summary':case'ul':case'pre':case'listing':case'table':case'hr':case'xmp':case'h1':case'h2':case'h3':case'h4':case'h5':case'h6':return ancestorInfo.pTagInButtonScope;case'form':return ancestorInfo.formTag||ancestorInfo.pTagInButtonScope;case'li':return ancestorInfo.listItemTagAutoclosing;case'dd':case'dt':return ancestorInfo.dlItemTagAutoclosing;case'button':return ancestorInfo.buttonTagInScope;case'a':// Spec says something about storing a list of markers, but it sounds\n\t// equivalent to this check.\n\treturn ancestorInfo.aTagInScope;case'nobr':return ancestorInfo.nobrTagInScope;}return null;};var didWarn$1={};validateDOMNesting=function(childTag,childText,ancestorInfo){ancestorInfo=ancestorInfo||emptyAncestorInfo;var parentInfo=ancestorInfo.current;var parentTag=parentInfo&&parentInfo.tag;if(childText!=null){if(childTag!=null){error('validateDOMNesting: when childText is passed, childTag should be null');}childTag='#text';}var invalidParent=isTagValidWithParent(childTag,parentTag)?null:parentInfo;var invalidAncestor=invalidParent?null:findInvalidAncestorForTag(childTag,ancestorInfo);var invalidParentOrAncestor=invalidParent||invalidAncestor;if(!invalidParentOrAncestor){return;}var ancestorTag=invalidParentOrAncestor.tag;var warnKey=!!invalidParent+'|'+childTag+'|'+ancestorTag;if(didWarn$1[warnKey]){return;}didWarn$1[warnKey]=true;var tagDisplayName=childTag;var whitespaceInfo='';if(childTag==='#text'){if(/\\S/.test(childText)){tagDisplayName='Text nodes';}else {tagDisplayName='Whitespace text nodes';whitespaceInfo=\" Make sure you don't have any extra whitespace between tags on \"+'each line of your source code.';}}else {tagDisplayName='<'+childTag+'>';}if(invalidParent){var info='';if(ancestorTag==='table'&&childTag==='tr'){info+=' Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by '+'the browser.';}error('validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s',tagDisplayName,ancestorTag,whitespaceInfo,info);}else {error('validateDOMNesting(...): %s cannot appear as a descendant of '+'<%s>.',tagDisplayName,ancestorTag);}};}var SUPPRESS_HYDRATION_WARNING$1='suppressHydrationWarning';var SUSPENSE_START_DATA='$';var SUSPENSE_END_DATA='/$';var SUSPENSE_PENDING_START_DATA='$?';var SUSPENSE_FALLBACK_START_DATA='$!';var STYLE$1='style';var eventsEnabled=null;var selectionInformation=null;function getRootHostContext(rootContainerInstance){var type;var namespace;var nodeType=rootContainerInstance.nodeType;switch(nodeType){case DOCUMENT_NODE:case DOCUMENT_FRAGMENT_NODE:{type=nodeType===DOCUMENT_NODE?'#document':'#fragment';var root=rootContainerInstance.documentElement;namespace=root?root.namespaceURI:getChildNamespace(null,'');break;}default:{var container=nodeType===COMMENT_NODE?rootContainerInstance.parentNode:rootContainerInstance;var ownNamespace=container.namespaceURI||null;type=container.tagName;namespace=getChildNamespace(ownNamespace,type);break;}}{var validatedTag=type.toLowerCase();var ancestorInfo=updatedAncestorInfo(null,validatedTag);return {namespace:namespace,ancestorInfo:ancestorInfo};}}function getChildHostContext(parentHostContext,type,rootContainerInstance){{var parentHostContextDev=parentHostContext;var namespace=getChildNamespace(parentHostContextDev.namespace,type);var ancestorInfo=updatedAncestorInfo(parentHostContextDev.ancestorInfo,type);return {namespace:namespace,ancestorInfo:ancestorInfo};}}function getPublicInstance(instance){return instance;}function prepareForCommit(containerInfo){eventsEnabled=isEnabled();selectionInformation=getSelectionInformation();var activeInstance=null;setEnabled(false);return activeInstance;}function resetAfterCommit(containerInfo){restoreSelection(selectionInformation);setEnabled(eventsEnabled);eventsEnabled=null;selectionInformation=null;}function createInstance(type,props,rootContainerInstance,hostContext,internalInstanceHandle){var parentNamespace;{// TODO: take namespace into account when validating.\n\tvar hostContextDev=hostContext;validateDOMNesting(type,null,hostContextDev.ancestorInfo);if(typeof props.children==='string'||typeof props.children==='number'){var string=''+props.children;var ownAncestorInfo=updatedAncestorInfo(hostContextDev.ancestorInfo,type);validateDOMNesting(null,string,ownAncestorInfo);}parentNamespace=hostContextDev.namespace;}var domElement=createElement(type,props,rootContainerInstance,parentNamespace);precacheFiberNode(internalInstanceHandle,domElement);updateFiberProps(domElement,props);return domElement;}function appendInitialChild(parentInstance,child){parentInstance.appendChild(child);}function finalizeInitialChildren(domElement,type,props,rootContainerInstance,hostContext){setInitialProperties(domElement,type,props,rootContainerInstance);switch(type){case'button':case'input':case'select':case'textarea':return !!props.autoFocus;case'img':return true;default:return false;}}function prepareUpdate(domElement,type,oldProps,newProps,rootContainerInstance,hostContext){{var hostContextDev=hostContext;if(typeof newProps.children!==typeof oldProps.children&&(typeof newProps.children==='string'||typeof newProps.children==='number')){var string=''+newProps.children;var ownAncestorInfo=updatedAncestorInfo(hostContextDev.ancestorInfo,type);validateDOMNesting(null,string,ownAncestorInfo);}}return diffProperties(domElement,type,oldProps,newProps);}function shouldSetTextContent(type,props){return type==='textarea'||type==='noscript'||typeof props.children==='string'||typeof props.children==='number'||typeof props.dangerouslySetInnerHTML==='object'&&props.dangerouslySetInnerHTML!==null&&props.dangerouslySetInnerHTML.__html!=null;}function createTextInstance(text,rootContainerInstance,hostContext,internalInstanceHandle){{var hostContextDev=hostContext;validateDOMNesting(null,text,hostContextDev.ancestorInfo);}var textNode=createTextNode(text,rootContainerInstance);precacheFiberNode(internalInstanceHandle,textNode);return textNode;}function getCurrentEventPriority(){var currentEvent=window.event;if(currentEvent===undefined){return DefaultEventPriority;}return getEventPriority(currentEvent.type);}// if a component just imports ReactDOM (e.g. for findDOMNode).\n\t// Some environments might not have setTimeout or clearTimeout.\n\tvar scheduleTimeout=typeof setTimeout==='function'?setTimeout:undefined;var cancelTimeout=typeof clearTimeout==='function'?clearTimeout:undefined;var noTimeout=-1;var localPromise=typeof Promise==='function'?Promise:undefined;// -------------------\n\tvar scheduleMicrotask=typeof queueMicrotask==='function'?queueMicrotask:typeof localPromise!=='undefined'?function(callback){return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);}:scheduleTimeout;// TODO: Determine the best fallback here.\n\tfunction handleErrorInNextTick(error){setTimeout(function(){throw error;});}// -------------------\n\tfunction commitMount(domElement,type,newProps,internalInstanceHandle){// Despite the naming that might imply otherwise, this method only\n\t// fires if there is an `Update` effect scheduled during mounting.\n\t// This happens if `finalizeInitialChildren` returns `true` (which it\n\t// does to implement the `autoFocus` attribute on the client). But\n\t// there are also other cases when this might happen (such as patching\n\t// up text content during hydration mismatch). So we'll check this again.\n\tswitch(type){case'button':case'input':case'select':case'textarea':if(newProps.autoFocus){domElement.focus();}return;case'img':{if(newProps.src){domElement.src=newProps.src;}return;}}}function commitUpdate(domElement,updatePayload,type,oldProps,newProps,internalInstanceHandle){// Apply the diff to the DOM node.\n\tupdateProperties(domElement,updatePayload,type,oldProps,newProps);// Update the props handle so that we know which props are the ones with\n\t// with current event handlers.\n\tupdateFiberProps(domElement,newProps);}function resetTextContent(domElement){setTextContent(domElement,'');}function commitTextUpdate(textInstance,oldText,newText){textInstance.nodeValue=newText;}function appendChild(parentInstance,child){parentInstance.appendChild(child);}function appendChildToContainer(container,child){var parentNode;if(container.nodeType===COMMENT_NODE){parentNode=container.parentNode;parentNode.insertBefore(child,container);}else {parentNode=container;parentNode.appendChild(child);}// This container might be used for a portal.\n\t// If something inside a portal is clicked, that click should bubble\n\t// through the React tree. However, on Mobile Safari the click would\n\t// never bubble through the *DOM* tree unless an ancestor with onclick\n\t// event exists. So we wouldn't see it and dispatch it.\n\t// This is why we ensure that non React root containers have inline onclick\n\t// defined.\n\t// https://github.com/facebook/react/issues/11918\n\tvar reactRootContainer=container._reactRootContainer;if((reactRootContainer===null||reactRootContainer===undefined)&&parentNode.onclick===null){// TODO: This cast may not be sound for SVG, MathML or custom elements.\n\ttrapClickOnNonInteractiveElement(parentNode);}}function insertBefore(parentInstance,child,beforeChild){parentInstance.insertBefore(child,beforeChild);}function insertInContainerBefore(container,child,beforeChild){if(container.nodeType===COMMENT_NODE){container.parentNode.insertBefore(child,beforeChild);}else {container.insertBefore(child,beforeChild);}}function removeChild(parentInstance,child){parentInstance.removeChild(child);}function removeChildFromContainer(container,child){if(container.nodeType===COMMENT_NODE){container.parentNode.removeChild(child);}else {container.removeChild(child);}}function clearSuspenseBoundary(parentInstance,suspenseInstance){var node=suspenseInstance;// Delete all nodes within this suspense boundary.\n\t// There might be nested nodes so we need to keep track of how\n\t// deep we are and only break out when we're back on top.\n\tvar depth=0;do{var nextNode=node.nextSibling;parentInstance.removeChild(node);if(nextNode&&nextNode.nodeType===COMMENT_NODE){var data=nextNode.data;if(data===SUSPENSE_END_DATA){if(depth===0){parentInstance.removeChild(nextNode);// Retry if any event replaying was blocked on this.\n\tretryIfBlockedOn(suspenseInstance);return;}else {depth--;}}else if(data===SUSPENSE_START_DATA||data===SUSPENSE_PENDING_START_DATA||data===SUSPENSE_FALLBACK_START_DATA){depth++;}}node=nextNode;}while(node);// TODO: Warn, we didn't find the end comment boundary.\n\t// Retry if any event replaying was blocked on this.\n\tretryIfBlockedOn(suspenseInstance);}function clearSuspenseBoundaryFromContainer(container,suspenseInstance){if(container.nodeType===COMMENT_NODE){clearSuspenseBoundary(container.parentNode,suspenseInstance);}else if(container.nodeType===ELEMENT_NODE){clearSuspenseBoundary(container,suspenseInstance);}// Retry if any event replaying was blocked on this.\n\tretryIfBlockedOn(container);}function hideInstance(instance){// TODO: Does this work for all element types? What about MathML? Should we\n\t// pass host context to this method?\n\tinstance=instance;var style=instance.style;if(typeof style.setProperty==='function'){style.setProperty('display','none','important');}else {style.display='none';}}function hideTextInstance(textInstance){textInstance.nodeValue='';}function unhideInstance(instance,props){instance=instance;var styleProp=props[STYLE$1];var display=styleProp!==undefined&&styleProp!==null&&styleProp.hasOwnProperty('display')?styleProp.display:null;instance.style.display=dangerousStyleValue('display',display);}function unhideTextInstance(textInstance,text){textInstance.nodeValue=text;}function clearContainer(container){if(container.nodeType===ELEMENT_NODE){container.textContent='';}else if(container.nodeType===DOCUMENT_NODE){if(container.documentElement){container.removeChild(container.documentElement);}}}// -------------------\n\tfunction canHydrateInstance(instance,type,props){if(instance.nodeType!==ELEMENT_NODE||type.toLowerCase()!==instance.nodeName.toLowerCase()){return null;}// This has now been refined to an element node.\n\treturn instance;}function canHydrateTextInstance(instance,text){if(text===''||instance.nodeType!==TEXT_NODE){// Empty strings are not parsed by HTML so there won't be a correct match here.\n\treturn null;}// This has now been refined to a text node.\n\treturn instance;}function canHydrateSuspenseInstance(instance){if(instance.nodeType!==COMMENT_NODE){// Empty strings are not parsed by HTML so there won't be a correct match here.\n\treturn null;}// This has now been refined to a suspense node.\n\treturn instance;}function isSuspenseInstancePending(instance){return instance.data===SUSPENSE_PENDING_START_DATA;}function isSuspenseInstanceFallback(instance){return instance.data===SUSPENSE_FALLBACK_START_DATA;}function getSuspenseInstanceFallbackErrorDetails(instance){var dataset=instance.nextSibling&&instance.nextSibling.dataset;var digest,message,stack;if(dataset){digest=dataset.dgst;{message=dataset.msg;stack=dataset.stck;}}{return {message:message,digest:digest,stack:stack};}// let value = {message: undefined, hash: undefined};\n\t// const nextSibling = instance.nextSibling;\n\t// if (nextSibling) {\n\t//   const dataset = ((nextSibling: any): HTMLTemplateElement).dataset;\n\t//   value.message = dataset.msg;\n\t//   value.hash = dataset.hash;\n\t//   if (true) {\n\t//     value.stack = dataset.stack;\n\t//   }\n\t// }\n\t// return value;\n\t}function registerSuspenseInstanceRetry(instance,callback){instance._reactRetry=callback;}function getNextHydratable(node){// Skip non-hydratable nodes.\n\tfor(;node!=null;node=node.nextSibling){var nodeType=node.nodeType;if(nodeType===ELEMENT_NODE||nodeType===TEXT_NODE){break;}if(nodeType===COMMENT_NODE){var nodeData=node.data;if(nodeData===SUSPENSE_START_DATA||nodeData===SUSPENSE_FALLBACK_START_DATA||nodeData===SUSPENSE_PENDING_START_DATA){break;}if(nodeData===SUSPENSE_END_DATA){return null;}}}return node;}function getNextHydratableSibling(instance){return getNextHydratable(instance.nextSibling);}function getFirstHydratableChild(parentInstance){return getNextHydratable(parentInstance.firstChild);}function getFirstHydratableChildWithinContainer(parentContainer){return getNextHydratable(parentContainer.firstChild);}function getFirstHydratableChildWithinSuspenseInstance(parentInstance){return getNextHydratable(parentInstance.nextSibling);}function hydrateInstance(instance,type,props,rootContainerInstance,hostContext,internalInstanceHandle,shouldWarnDev){precacheFiberNode(internalInstanceHandle,instance);// TODO: Possibly defer this until the commit phase where all the events\n\t// get attached.\n\tupdateFiberProps(instance,props);var parentNamespace;{var hostContextDev=hostContext;parentNamespace=hostContextDev.namespace;}// TODO: Temporary hack to check if we're in a concurrent root. We can delete\n\t// when the legacy root API is removed.\n\tvar isConcurrentMode=(internalInstanceHandle.mode&ConcurrentMode)!==NoMode;return diffHydratedProperties(instance,type,props,parentNamespace,rootContainerInstance,isConcurrentMode,shouldWarnDev);}function hydrateTextInstance(textInstance,text,internalInstanceHandle,shouldWarnDev){precacheFiberNode(internalInstanceHandle,textInstance);// TODO: Temporary hack to check if we're in a concurrent root. We can delete\n\t// when the legacy root API is removed.\n\t(internalInstanceHandle.mode&ConcurrentMode)!==NoMode;return diffHydratedText(textInstance,text);}function hydrateSuspenseInstance(suspenseInstance,internalInstanceHandle){precacheFiberNode(internalInstanceHandle,suspenseInstance);}function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance){var node=suspenseInstance.nextSibling;// Skip past all nodes within this suspense boundary.\n\t// There might be nested nodes so we need to keep track of how\n\t// deep we are and only break out when we're back on top.\n\tvar depth=0;while(node){if(node.nodeType===COMMENT_NODE){var data=node.data;if(data===SUSPENSE_END_DATA){if(depth===0){return getNextHydratableSibling(node);}else {depth--;}}else if(data===SUSPENSE_START_DATA||data===SUSPENSE_FALLBACK_START_DATA||data===SUSPENSE_PENDING_START_DATA){depth++;}}node=node.nextSibling;}// TODO: Warn, we didn't find the end comment boundary.\n\treturn null;}// Returns the SuspenseInstance if this node is a direct child of a\n\t// SuspenseInstance. I.e. if its previous sibling is a Comment with\n\t// SUSPENSE_x_START_DATA. Otherwise, null.\n\tfunction getParentSuspenseInstance(targetInstance){var node=targetInstance.previousSibling;// Skip past all nodes within this suspense boundary.\n\t// There might be nested nodes so we need to keep track of how\n\t// deep we are and only break out when we're back on top.\n\tvar depth=0;while(node){if(node.nodeType===COMMENT_NODE){var data=node.data;if(data===SUSPENSE_START_DATA||data===SUSPENSE_FALLBACK_START_DATA||data===SUSPENSE_PENDING_START_DATA){if(depth===0){return node;}else {depth--;}}else if(data===SUSPENSE_END_DATA){depth++;}}node=node.previousSibling;}return null;}function commitHydratedContainer(container){// Retry if any event replaying was blocked on this.\n\tretryIfBlockedOn(container);}function commitHydratedSuspenseInstance(suspenseInstance){// Retry if any event replaying was blocked on this.\n\tretryIfBlockedOn(suspenseInstance);}function shouldDeleteUnhydratedTailInstances(parentType){return parentType!=='head'&&parentType!=='body';}function didNotMatchHydratedContainerTextInstance(parentContainer,textInstance,text,isConcurrentMode){var shouldWarnDev=true;checkForUnmatchedText(textInstance.nodeValue,text,isConcurrentMode,shouldWarnDev);}function didNotMatchHydratedTextInstance(parentType,parentProps,parentInstance,textInstance,text,isConcurrentMode){if(parentProps[SUPPRESS_HYDRATION_WARNING$1]!==true){var shouldWarnDev=true;checkForUnmatchedText(textInstance.nodeValue,text,isConcurrentMode,shouldWarnDev);}}function didNotHydrateInstanceWithinContainer(parentContainer,instance){{if(instance.nodeType===ELEMENT_NODE){warnForDeletedHydratableElement(parentContainer,instance);}else if(instance.nodeType===COMMENT_NODE);else {warnForDeletedHydratableText(parentContainer,instance);}}}function didNotHydrateInstanceWithinSuspenseInstance(parentInstance,instance){{// $FlowFixMe: Only Element or Document can be parent nodes.\n\tvar parentNode=parentInstance.parentNode;if(parentNode!==null){if(instance.nodeType===ELEMENT_NODE){warnForDeletedHydratableElement(parentNode,instance);}else if(instance.nodeType===COMMENT_NODE);else {warnForDeletedHydratableText(parentNode,instance);}}}}function didNotHydrateInstance(parentType,parentProps,parentInstance,instance,isConcurrentMode){{if(isConcurrentMode||parentProps[SUPPRESS_HYDRATION_WARNING$1]!==true){if(instance.nodeType===ELEMENT_NODE){warnForDeletedHydratableElement(parentInstance,instance);}else if(instance.nodeType===COMMENT_NODE);else {warnForDeletedHydratableText(parentInstance,instance);}}}}function didNotFindHydratableInstanceWithinContainer(parentContainer,type,props){{warnForInsertedHydratedElement(parentContainer,type);}}function didNotFindHydratableTextInstanceWithinContainer(parentContainer,text){{warnForInsertedHydratedText(parentContainer,text);}}function didNotFindHydratableInstanceWithinSuspenseInstance(parentInstance,type,props){{// $FlowFixMe: Only Element or Document can be parent nodes.\n\tvar parentNode=parentInstance.parentNode;if(parentNode!==null)warnForInsertedHydratedElement(parentNode,type);}}function didNotFindHydratableTextInstanceWithinSuspenseInstance(parentInstance,text){{// $FlowFixMe: Only Element or Document can be parent nodes.\n\tvar parentNode=parentInstance.parentNode;if(parentNode!==null)warnForInsertedHydratedText(parentNode,text);}}function didNotFindHydratableInstance(parentType,parentProps,parentInstance,type,props,isConcurrentMode){{if(isConcurrentMode||parentProps[SUPPRESS_HYDRATION_WARNING$1]!==true){warnForInsertedHydratedElement(parentInstance,type);}}}function didNotFindHydratableTextInstance(parentType,parentProps,parentInstance,text,isConcurrentMode){{if(isConcurrentMode||parentProps[SUPPRESS_HYDRATION_WARNING$1]!==true){warnForInsertedHydratedText(parentInstance,text);}}}function errorHydratingContainer(parentContainer){{// TODO: This gets logged by onRecoverableError, too, so we should be\n\t// able to remove it.\n\terror('An error occurred during hydration. The server HTML was replaced with client content in <%s>.',parentContainer.nodeName.toLowerCase());}}function preparePortalMount(portalInstance){listenToAllSupportedEvents(portalInstance);}var randomKey=Math.random().toString(36).slice(2);var internalInstanceKey='__reactFiber$'+randomKey;var internalPropsKey='__reactProps$'+randomKey;var internalContainerInstanceKey='__reactContainer$'+randomKey;var internalEventHandlersKey='__reactEvents$'+randomKey;var internalEventHandlerListenersKey='__reactListeners$'+randomKey;var internalEventHandlesSetKey='__reactHandles$'+randomKey;function detachDeletedInstance(node){// TODO: This function is only called on host components. I don't think all of\n\t// these fields are relevant.\n\tdelete node[internalInstanceKey];delete node[internalPropsKey];delete node[internalEventHandlersKey];delete node[internalEventHandlerListenersKey];delete node[internalEventHandlesSetKey];}function precacheFiberNode(hostInst,node){node[internalInstanceKey]=hostInst;}function markContainerAsRoot(hostRoot,node){node[internalContainerInstanceKey]=hostRoot;}function unmarkContainerAsRoot(node){node[internalContainerInstanceKey]=null;}function isContainerMarkedAsRoot(node){return !!node[internalContainerInstanceKey];}// Given a DOM node, return the closest HostComponent or HostText fiber ancestor.\n\t// If the target node is part of a hydrated or not yet rendered subtree, then\n\t// this may also return a SuspenseComponent or HostRoot to indicate that.\n\t// Conceptually the HostRoot fiber is a child of the Container node. So if you\n\t// pass the Container node as the targetNode, you will not actually get the\n\t// HostRoot back. To get to the HostRoot, you need to pass a child of it.\n\t// The same thing applies to Suspense boundaries.\n\tfunction getClosestInstanceFromNode(targetNode){var targetInst=targetNode[internalInstanceKey];if(targetInst){// Don't return HostRoot or SuspenseComponent here.\n\treturn targetInst;}// If the direct event target isn't a React owned DOM node, we need to look\n\t// to see if one of its parents is a React owned DOM node.\n\tvar parentNode=targetNode.parentNode;while(parentNode){// We'll check if this is a container root that could include\n\t// React nodes in the future. We need to check this first because\n\t// if we're a child of a dehydrated container, we need to first\n\t// find that inner container before moving on to finding the parent\n\t// instance. Note that we don't check this field on  the targetNode\n\t// itself because the fibers are conceptually between the container\n\t// node and the first child. It isn't surrounding the container node.\n\t// If it's not a container, we check if it's an instance.\n\ttargetInst=parentNode[internalContainerInstanceKey]||parentNode[internalInstanceKey];if(targetInst){// Since this wasn't the direct target of the event, we might have\n\t// stepped past dehydrated DOM nodes to get here. However they could\n\t// also have been non-React nodes. We need to answer which one.\n\t// If we the instance doesn't have any children, then there can't be\n\t// a nested suspense boundary within it. So we can use this as a fast\n\t// bailout. Most of the time, when people add non-React children to\n\t// the tree, it is using a ref to a child-less DOM node.\n\t// Normally we'd only need to check one of the fibers because if it\n\t// has ever gone from having children to deleting them or vice versa\n\t// it would have deleted the dehydrated boundary nested inside already.\n\t// However, since the HostRoot starts out with an alternate it might\n\t// have one on the alternate so we need to check in case this was a\n\t// root.\n\tvar alternate=targetInst.alternate;if(targetInst.child!==null||alternate!==null&&alternate.child!==null){// Next we need to figure out if the node that skipped past is\n\t// nested within a dehydrated boundary and if so, which one.\n\tvar suspenseInstance=getParentSuspenseInstance(targetNode);while(suspenseInstance!==null){// We found a suspense instance. That means that we haven't\n\t// hydrated it yet. Even though we leave the comments in the\n\t// DOM after hydrating, and there are boundaries in the DOM\n\t// that could already be hydrated, we wouldn't have found them\n\t// through this pass since if the target is hydrated it would\n\t// have had an internalInstanceKey on it.\n\t// Let's get the fiber associated with the SuspenseComponent\n\t// as the deepest instance.\n\tvar targetSuspenseInst=suspenseInstance[internalInstanceKey];if(targetSuspenseInst){return targetSuspenseInst;}// If we don't find a Fiber on the comment, it might be because\n\t// we haven't gotten to hydrate it yet. There might still be a\n\t// parent boundary that hasn't above this one so we need to find\n\t// the outer most that is known.\n\tsuspenseInstance=getParentSuspenseInstance(suspenseInstance);// If we don't find one, then that should mean that the parent\n\t// host component also hasn't hydrated yet. We can return it\n\t// below since it will bail out on the isMounted check later.\n\t}}return targetInst;}targetNode=parentNode;parentNode=targetNode.parentNode;}return null;}/**\n\t * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent\n\t * instance, or null if the node was not rendered by this React.\n\t */function getInstanceFromNode(node){var inst=node[internalInstanceKey]||node[internalContainerInstanceKey];if(inst){if(inst.tag===HostComponent||inst.tag===HostText||inst.tag===SuspenseComponent||inst.tag===HostRoot){return inst;}else {return null;}}return null;}/**\n\t * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding\n\t * DOM node.\n\t */function getNodeFromInstance(inst){if(inst.tag===HostComponent||inst.tag===HostText){// In Fiber this, is just the state node right now. We assume it will be\n\t// a host component or host text.\n\treturn inst.stateNode;}// Without this first invariant, passing a non-DOM-component triggers the next\n\t// invariant for a missing parent, which is super confusing.\n\tthrow new Error('getNodeFromInstance: Invalid argument.');}function getFiberCurrentPropsFromNode(node){return node[internalPropsKey]||null;}function updateFiberProps(node,props){node[internalPropsKey]=props;}function getEventListenerSet(node){var elementListenerSet=node[internalEventHandlersKey];if(elementListenerSet===undefined){elementListenerSet=node[internalEventHandlersKey]=new Set();}return elementListenerSet;}var loggedTypeFailures={};var ReactDebugCurrentFrame$1=ReactSharedInternals.ReactDebugCurrentFrame;function setCurrentlyValidatingElement(element){{if(element){var owner=element._owner;var stack=describeUnknownElementTypeFrameInDEV(element.type,element._source,owner?owner.type:null);ReactDebugCurrentFrame$1.setExtraStackFrame(stack);}else {ReactDebugCurrentFrame$1.setExtraStackFrame(null);}}}function checkPropTypes(typeSpecs,values,location,componentName,element){{// $FlowFixMe This is okay but Flow doesn't know it.\n\tvar has=Function.call.bind(hasOwnProperty);for(var typeSpecName in typeSpecs){if(has(typeSpecs,typeSpecName)){var error$1=void 0;// Prop type validation may throw. In case they do, we don't want to\n\t// fail the render phase where it didn't fail before. So we log it.\n\t// After these have been cleaned up, we'll let them throw.\n\ttry{// This is intentionally an invariant that gets caught. It's the same\n\t// behavior as without this statement except with a better message.\n\tif(typeof typeSpecs[typeSpecName]!=='function'){// eslint-disable-next-line react-internal/prod-error-codes\n\tvar err=Error((componentName||'React class')+': '+location+' type `'+typeSpecName+'` is invalid; '+'it must be a function, usually from the `prop-types` package, but received `'+typeof typeSpecs[typeSpecName]+'`.'+'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');err.name='Invariant Violation';throw err;}error$1=typeSpecs[typeSpecName](values,typeSpecName,componentName,location,null,'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');}catch(ex){error$1=ex;}if(error$1&&!(error$1 instanceof Error)){setCurrentlyValidatingElement(element);error('%s: type specification of %s'+' `%s` is invalid; the type checker '+'function must return `null` or an `Error` but returned a %s. '+'You may have forgotten to pass an argument to the type checker '+'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and '+'shape all require an argument).',componentName||'React class',location,typeSpecName,typeof error$1);setCurrentlyValidatingElement(null);}if(error$1 instanceof Error&&!(error$1.message in loggedTypeFailures)){// Only monitor this failure once because there tends to be a lot of the\n\t// same error.\n\tloggedTypeFailures[error$1.message]=true;setCurrentlyValidatingElement(element);error('Failed %s type: %s',location,error$1.message);setCurrentlyValidatingElement(null);}}}}}var valueStack=[];var fiberStack;{fiberStack=[];}var index=-1;function createCursor(defaultValue){return {current:defaultValue};}function pop(cursor,fiber){if(index<0){{error('Unexpected pop.');}return;}{if(fiber!==fiberStack[index]){error('Unexpected Fiber popped.');}}cursor.current=valueStack[index];valueStack[index]=null;{fiberStack[index]=null;}index--;}function push(cursor,value,fiber){index++;valueStack[index]=cursor.current;{fiberStack[index]=fiber;}cursor.current=value;}var warnedAboutMissingGetChildContext;{warnedAboutMissingGetChildContext={};}var emptyContextObject={};{Object.freeze(emptyContextObject);}// A cursor to the current merged context object on the stack.\n\tvar contextStackCursor=createCursor(emptyContextObject);// A cursor to a boolean indicating whether the context has changed.\n\tvar didPerformWorkStackCursor=createCursor(false);// Keep track of the previous context object that was on the stack.\n\t// We use this to get access to the parent context after we have already\n\t// pushed the next context provider, and now need to merge their contexts.\n\tvar previousContext=emptyContextObject;function getUnmaskedContext(workInProgress,Component,didPushOwnContextIfProvider){{if(didPushOwnContextIfProvider&&isContextProvider(Component)){// If the fiber is a context provider itself, when we read its context\n\t// we may have already pushed its own child context on the stack. A context\n\t// provider should not \"see\" its own child context. Therefore we read the\n\t// previous (parent) context instead for a context provider.\n\treturn previousContext;}return contextStackCursor.current;}}function cacheContext(workInProgress,unmaskedContext,maskedContext){{var instance=workInProgress.stateNode;instance.__reactInternalMemoizedUnmaskedChildContext=unmaskedContext;instance.__reactInternalMemoizedMaskedChildContext=maskedContext;}}function getMaskedContext(workInProgress,unmaskedContext){{var type=workInProgress.type;var contextTypes=type.contextTypes;if(!contextTypes){return emptyContextObject;}// Avoid recreating masked context unless unmasked context has changed.\n\t// Failing to do this will result in unnecessary calls to componentWillReceiveProps.\n\t// This may trigger infinite loops if componentWillReceiveProps calls setState.\n\tvar instance=workInProgress.stateNode;if(instance&&instance.__reactInternalMemoizedUnmaskedChildContext===unmaskedContext){return instance.__reactInternalMemoizedMaskedChildContext;}var context={};for(var key in contextTypes){context[key]=unmaskedContext[key];}{var name=getComponentNameFromFiber(workInProgress)||'Unknown';checkPropTypes(contextTypes,context,'context',name);}// Cache unmasked context so we can avoid recreating masked context unless necessary.\n\t// Context is created before the class component is instantiated so check for instance.\n\tif(instance){cacheContext(workInProgress,unmaskedContext,context);}return context;}}function hasContextChanged(){{return didPerformWorkStackCursor.current;}}function isContextProvider(type){{var childContextTypes=type.childContextTypes;return childContextTypes!==null&&childContextTypes!==undefined;}}function popContext(fiber){{pop(didPerformWorkStackCursor,fiber);pop(contextStackCursor,fiber);}}function popTopLevelContextObject(fiber){{pop(didPerformWorkStackCursor,fiber);pop(contextStackCursor,fiber);}}function pushTopLevelContextObject(fiber,context,didChange){{if(contextStackCursor.current!==emptyContextObject){throw new Error('Unexpected context found on stack. '+'This error is likely caused by a bug in React. Please file an issue.');}push(contextStackCursor,context,fiber);push(didPerformWorkStackCursor,didChange,fiber);}}function processChildContext(fiber,type,parentContext){{var instance=fiber.stateNode;var childContextTypes=type.childContextTypes;// TODO (bvaughn) Replace this behavior with an invariant() in the future.\n\t// It has only been added in Fiber to match the (unintentional) behavior in Stack.\n\tif(typeof instance.getChildContext!=='function'){{var componentName=getComponentNameFromFiber(fiber)||'Unknown';if(!warnedAboutMissingGetChildContext[componentName]){warnedAboutMissingGetChildContext[componentName]=true;error('%s.childContextTypes is specified but there is no getChildContext() method '+'on the instance. You can either define getChildContext() on %s or remove '+'childContextTypes from it.',componentName,componentName);}}return parentContext;}var childContext=instance.getChildContext();for(var contextKey in childContext){if(!(contextKey in childContextTypes)){throw new Error((getComponentNameFromFiber(fiber)||'Unknown')+\".getChildContext(): key \\\"\"+contextKey+\"\\\" is not defined in childContextTypes.\");}}{var name=getComponentNameFromFiber(fiber)||'Unknown';checkPropTypes(childContextTypes,childContext,'child context',name);}return assign({},parentContext,childContext);}}function pushContextProvider(workInProgress){{var instance=workInProgress.stateNode;// We push the context as early as possible to ensure stack integrity.\n\t// If the instance does not exist yet, we will push null at first,\n\t// and replace it on the stack later when invalidating the context.\n\tvar memoizedMergedChildContext=instance&&instance.__reactInternalMemoizedMergedChildContext||emptyContextObject;// Remember the parent context so we can merge with it later.\n\t// Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.\n\tpreviousContext=contextStackCursor.current;push(contextStackCursor,memoizedMergedChildContext,workInProgress);push(didPerformWorkStackCursor,didPerformWorkStackCursor.current,workInProgress);return true;}}function invalidateContextProvider(workInProgress,type,didChange){{var instance=workInProgress.stateNode;if(!instance){throw new Error('Expected to have an instance by this point. '+'This error is likely caused by a bug in React. Please file an issue.');}if(didChange){// Merge parent and own context.\n\t// Skip this if we're not updating due to sCU.\n\t// This avoids unnecessarily recomputing memoized values.\n\tvar mergedContext=processChildContext(workInProgress,type,previousContext);instance.__reactInternalMemoizedMergedChildContext=mergedContext;// Replace the old (or empty) context with the new one.\n\t// It is important to unwind the context in the reverse order.\n\tpop(didPerformWorkStackCursor,workInProgress);pop(contextStackCursor,workInProgress);// Now push the new context and mark that it has changed.\n\tpush(contextStackCursor,mergedContext,workInProgress);push(didPerformWorkStackCursor,didChange,workInProgress);}else {pop(didPerformWorkStackCursor,workInProgress);push(didPerformWorkStackCursor,didChange,workInProgress);}}}function findCurrentUnmaskedContext(fiber){{// Currently this is only used with renderSubtreeIntoContainer; not sure if it\n\t// makes sense elsewhere\n\tif(!isFiberMounted(fiber)||fiber.tag!==ClassComponent){throw new Error('Expected subtree parent to be a mounted class component. '+'This error is likely caused by a bug in React. Please file an issue.');}var node=fiber;do{switch(node.tag){case HostRoot:return node.stateNode.context;case ClassComponent:{var Component=node.type;if(isContextProvider(Component)){return node.stateNode.__reactInternalMemoizedMergedChildContext;}break;}}node=node.return;}while(node!==null);throw new Error('Found unexpected detached subtree parent. '+'This error is likely caused by a bug in React. Please file an issue.');}}var LegacyRoot=0;var ConcurrentRoot=1;var syncQueue=null;var includesLegacySyncCallbacks=false;var isFlushingSyncQueue=false;function scheduleSyncCallback(callback){// Push this callback into an internal queue. We'll flush these either in\n\t// the next tick, or earlier if something calls `flushSyncCallbackQueue`.\n\tif(syncQueue===null){syncQueue=[callback];}else {// Push onto existing queue. Don't need to schedule a callback because\n\t// we already scheduled one when we created the queue.\n\tsyncQueue.push(callback);}}function scheduleLegacySyncCallback(callback){includesLegacySyncCallbacks=true;scheduleSyncCallback(callback);}function flushSyncCallbacksOnlyInLegacyMode(){// Only flushes the queue if there's a legacy sync callback scheduled.\n\t// TODO: There's only a single type of callback: performSyncOnWorkOnRoot. So\n\t// it might make more sense for the queue to be a list of roots instead of a\n\t// list of generic callbacks. Then we can have two: one for legacy roots, one\n\t// for concurrent roots. And this method would only flush the legacy ones.\n\tif(includesLegacySyncCallbacks){flushSyncCallbacks();}}function flushSyncCallbacks(){if(!isFlushingSyncQueue&&syncQueue!==null){// Prevent re-entrance.\n\tisFlushingSyncQueue=true;var i=0;var previousUpdatePriority=getCurrentUpdatePriority();try{var isSync=true;var queue=syncQueue;// TODO: Is this necessary anymore? The only user code that runs in this\n\t// queue is in the render or commit phases.\n\tsetCurrentUpdatePriority(DiscreteEventPriority);for(;i<queue.length;i++){var callback=queue[i];do{callback=callback(isSync);}while(callback!==null);}syncQueue=null;includesLegacySyncCallbacks=false;}catch(error){// If something throws, leave the remaining callbacks on the queue.\n\tif(syncQueue!==null){syncQueue=syncQueue.slice(i+1);}// Resume flushing in the next tick\n\tscheduleCallback(ImmediatePriority,flushSyncCallbacks);throw error;}finally{setCurrentUpdatePriority(previousUpdatePriority);isFlushingSyncQueue=false;}}return null;}// TODO: Use the unified fiber stack module instead of this local one?\n\t// Intentionally not using it yet to derisk the initial implementation, because\n\t// the way we push/pop these values is a bit unusual. If there's a mistake, I'd\n\t// rather the ids be wrong than crash the whole reconciler.\n\tvar forkStack=[];var forkStackIndex=0;var treeForkProvider=null;var treeForkCount=0;var idStack=[];var idStackIndex=0;var treeContextProvider=null;var treeContextId=1;var treeContextOverflow='';function isForkedChild(workInProgress){warnIfNotHydrating();return (workInProgress.flags&Forked)!==NoFlags;}function getForksAtLevel(workInProgress){warnIfNotHydrating();return treeForkCount;}function getTreeId(){var overflow=treeContextOverflow;var idWithLeadingBit=treeContextId;var id=idWithLeadingBit&~getLeadingBit(idWithLeadingBit);return id.toString(32)+overflow;}function pushTreeFork(workInProgress,totalChildren){// This is called right after we reconcile an array (or iterator) of child\n\t// fibers, because that's the only place where we know how many children in\n\t// the whole set without doing extra work later, or storing addtional\n\t// information on the fiber.\n\t//\n\t// That's why this function is separate from pushTreeId — it's called during\n\t// the render phase of the fork parent, not the child, which is where we push\n\t// the other context values.\n\t//\n\t// In the Fizz implementation this is much simpler because the child is\n\t// rendered in the same callstack as the parent.\n\t//\n\t// It might be better to just add a `forks` field to the Fiber type. It would\n\t// make this module simpler.\n\twarnIfNotHydrating();forkStack[forkStackIndex++]=treeForkCount;forkStack[forkStackIndex++]=treeForkProvider;treeForkProvider=workInProgress;treeForkCount=totalChildren;}function pushTreeId(workInProgress,totalChildren,index){warnIfNotHydrating();idStack[idStackIndex++]=treeContextId;idStack[idStackIndex++]=treeContextOverflow;idStack[idStackIndex++]=treeContextProvider;treeContextProvider=workInProgress;var baseIdWithLeadingBit=treeContextId;var baseOverflow=treeContextOverflow;// The leftmost 1 marks the end of the sequence, non-inclusive. It's not part\n\t// of the id; we use it to account for leading 0s.\n\tvar baseLength=getBitLength(baseIdWithLeadingBit)-1;var baseId=baseIdWithLeadingBit&~(1<<baseLength);var slot=index+1;var length=getBitLength(totalChildren)+baseLength;// 30 is the max length we can store without overflowing, taking into\n\t// consideration the leading 1 we use to mark the end of the sequence.\n\tif(length>30){// We overflowed the bitwise-safe range. Fall back to slower algorithm.\n\t// This branch assumes the length of the base id is greater than 5; it won't\n\t// work for smaller ids, because you need 5 bits per character.\n\t//\n\t// We encode the id in multiple steps: first the base id, then the\n\t// remaining digits.\n\t//\n\t// Each 5 bit sequence corresponds to a single base 32 character. So for\n\t// example, if the current id is 23 bits long, we can convert 20 of those\n\t// bits into a string of 4 characters, with 3 bits left over.\n\t//\n\t// First calculate how many bits in the base id represent a complete\n\t// sequence of characters.\n\tvar numberOfOverflowBits=baseLength-baseLength%5;// Then create a bitmask that selects only those bits.\n\tvar newOverflowBits=(1<<numberOfOverflowBits)-1;// Select the bits, and convert them to a base 32 string.\n\tvar newOverflow=(baseId&newOverflowBits).toString(32);// Now we can remove those bits from the base id.\n\tvar restOfBaseId=baseId>>numberOfOverflowBits;var restOfBaseLength=baseLength-numberOfOverflowBits;// Finally, encode the rest of the bits using the normal algorithm. Because\n\t// we made more room, this time it won't overflow.\n\tvar restOfLength=getBitLength(totalChildren)+restOfBaseLength;var restOfNewBits=slot<<restOfBaseLength;var id=restOfNewBits|restOfBaseId;var overflow=newOverflow+baseOverflow;treeContextId=1<<restOfLength|id;treeContextOverflow=overflow;}else {// Normal path\n\tvar newBits=slot<<baseLength;var _id=newBits|baseId;var _overflow=baseOverflow;treeContextId=1<<length|_id;treeContextOverflow=_overflow;}}function pushMaterializedTreeId(workInProgress){warnIfNotHydrating();// This component materialized an id. This will affect any ids that appear\n\t// in its children.\n\tvar returnFiber=workInProgress.return;if(returnFiber!==null){var numberOfForks=1;var slotIndex=0;pushTreeFork(workInProgress,numberOfForks);pushTreeId(workInProgress,numberOfForks,slotIndex);}}function getBitLength(number){return 32-clz32(number);}function getLeadingBit(id){return 1<<getBitLength(id)-1;}function popTreeContext(workInProgress){// Restore the previous values.\n\t// This is a bit more complicated than other context-like modules in Fiber\n\t// because the same Fiber may appear on the stack multiple times and for\n\t// different reasons. We have to keep popping until the work-in-progress is\n\t// no longer at the top of the stack.\n\twhile(workInProgress===treeForkProvider){treeForkProvider=forkStack[--forkStackIndex];forkStack[forkStackIndex]=null;treeForkCount=forkStack[--forkStackIndex];forkStack[forkStackIndex]=null;}while(workInProgress===treeContextProvider){treeContextProvider=idStack[--idStackIndex];idStack[idStackIndex]=null;treeContextOverflow=idStack[--idStackIndex];idStack[idStackIndex]=null;treeContextId=idStack[--idStackIndex];idStack[idStackIndex]=null;}}function getSuspendedTreeContext(){warnIfNotHydrating();if(treeContextProvider!==null){return {id:treeContextId,overflow:treeContextOverflow};}else {return null;}}function restoreSuspendedTreeContext(workInProgress,suspendedContext){warnIfNotHydrating();idStack[idStackIndex++]=treeContextId;idStack[idStackIndex++]=treeContextOverflow;idStack[idStackIndex++]=treeContextProvider;treeContextId=suspendedContext.id;treeContextOverflow=suspendedContext.overflow;treeContextProvider=workInProgress;}function warnIfNotHydrating(){{if(!getIsHydrating()){error('Expected to be hydrating. This is a bug in React. Please file '+'an issue.');}}}// This may have been an insertion or a hydration.\n\tvar hydrationParentFiber=null;var nextHydratableInstance=null;var isHydrating=false;// This flag allows for warning supression when we expect there to be mismatches\n\t// due to earlier mismatches or a suspended fiber.\n\tvar didSuspendOrErrorDEV=false;// Hydration errors that were thrown inside this boundary\n\tvar hydrationErrors=null;function warnIfHydrating(){{if(isHydrating){error('We should not be hydrating here. This is a bug in React. Please file a bug.');}}}function markDidThrowWhileHydratingDEV(){{didSuspendOrErrorDEV=true;}}function didSuspendOrErrorWhileHydratingDEV(){{return didSuspendOrErrorDEV;}}function enterHydrationState(fiber){var parentInstance=fiber.stateNode.containerInfo;nextHydratableInstance=getFirstHydratableChildWithinContainer(parentInstance);hydrationParentFiber=fiber;isHydrating=true;hydrationErrors=null;didSuspendOrErrorDEV=false;return true;}function reenterHydrationStateFromDehydratedSuspenseInstance(fiber,suspenseInstance,treeContext){nextHydratableInstance=getFirstHydratableChildWithinSuspenseInstance(suspenseInstance);hydrationParentFiber=fiber;isHydrating=true;hydrationErrors=null;didSuspendOrErrorDEV=false;if(treeContext!==null){restoreSuspendedTreeContext(fiber,treeContext);}return true;}function warnUnhydratedInstance(returnFiber,instance){{switch(returnFiber.tag){case HostRoot:{didNotHydrateInstanceWithinContainer(returnFiber.stateNode.containerInfo,instance);break;}case HostComponent:{var isConcurrentMode=(returnFiber.mode&ConcurrentMode)!==NoMode;didNotHydrateInstance(returnFiber.type,returnFiber.memoizedProps,returnFiber.stateNode,instance,// TODO: Delete this argument when we remove the legacy root API.\n\tisConcurrentMode);break;}case SuspenseComponent:{var suspenseState=returnFiber.memoizedState;if(suspenseState.dehydrated!==null)didNotHydrateInstanceWithinSuspenseInstance(suspenseState.dehydrated,instance);break;}}}}function deleteHydratableInstance(returnFiber,instance){warnUnhydratedInstance(returnFiber,instance);var childToDelete=createFiberFromHostInstanceForDeletion();childToDelete.stateNode=instance;childToDelete.return=returnFiber;var deletions=returnFiber.deletions;if(deletions===null){returnFiber.deletions=[childToDelete];returnFiber.flags|=ChildDeletion;}else {deletions.push(childToDelete);}}function warnNonhydratedInstance(returnFiber,fiber){{if(didSuspendOrErrorDEV){// Inside a boundary that already suspended. We're currently rendering the\n\t// siblings of a suspended node. The mismatch may be due to the missing\n\t// data, so it's probably a false positive.\n\treturn;}switch(returnFiber.tag){case HostRoot:{var parentContainer=returnFiber.stateNode.containerInfo;switch(fiber.tag){case HostComponent:var type=fiber.type;fiber.pendingProps;didNotFindHydratableInstanceWithinContainer(parentContainer,type);break;case HostText:var text=fiber.pendingProps;didNotFindHydratableTextInstanceWithinContainer(parentContainer,text);break;}break;}case HostComponent:{var parentType=returnFiber.type;var parentProps=returnFiber.memoizedProps;var parentInstance=returnFiber.stateNode;switch(fiber.tag){case HostComponent:{var _type=fiber.type;var _props=fiber.pendingProps;var isConcurrentMode=(returnFiber.mode&ConcurrentMode)!==NoMode;didNotFindHydratableInstance(parentType,parentProps,parentInstance,_type,_props,// TODO: Delete this argument when we remove the legacy root API.\n\tisConcurrentMode);break;}case HostText:{var _text=fiber.pendingProps;var _isConcurrentMode=(returnFiber.mode&ConcurrentMode)!==NoMode;didNotFindHydratableTextInstance(parentType,parentProps,parentInstance,_text,// TODO: Delete this argument when we remove the legacy root API.\n\t_isConcurrentMode);break;}}break;}case SuspenseComponent:{var suspenseState=returnFiber.memoizedState;var _parentInstance=suspenseState.dehydrated;if(_parentInstance!==null)switch(fiber.tag){case HostComponent:var _type2=fiber.type;fiber.pendingProps;didNotFindHydratableInstanceWithinSuspenseInstance(_parentInstance,_type2);break;case HostText:var _text2=fiber.pendingProps;didNotFindHydratableTextInstanceWithinSuspenseInstance(_parentInstance,_text2);break;}break;}default:return;}}}function insertNonHydratedInstance(returnFiber,fiber){fiber.flags=fiber.flags&~Hydrating|Placement;warnNonhydratedInstance(returnFiber,fiber);}function tryHydrate(fiber,nextInstance){switch(fiber.tag){case HostComponent:{var type=fiber.type;fiber.pendingProps;var instance=canHydrateInstance(nextInstance,type);if(instance!==null){fiber.stateNode=instance;hydrationParentFiber=fiber;nextHydratableInstance=getFirstHydratableChild(instance);return true;}return false;}case HostText:{var text=fiber.pendingProps;var textInstance=canHydrateTextInstance(nextInstance,text);if(textInstance!==null){fiber.stateNode=textInstance;hydrationParentFiber=fiber;// Text Instances don't have children so there's nothing to hydrate.\n\tnextHydratableInstance=null;return true;}return false;}case SuspenseComponent:{var suspenseInstance=canHydrateSuspenseInstance(nextInstance);if(suspenseInstance!==null){var suspenseState={dehydrated:suspenseInstance,treeContext:getSuspendedTreeContext(),retryLane:OffscreenLane};fiber.memoizedState=suspenseState;// Store the dehydrated fragment as a child fiber.\n\t// This simplifies the code for getHostSibling and deleting nodes,\n\t// since it doesn't have to consider all Suspense boundaries and\n\t// check if they're dehydrated ones or not.\n\tvar dehydratedFragment=createFiberFromDehydratedFragment(suspenseInstance);dehydratedFragment.return=fiber;fiber.child=dehydratedFragment;hydrationParentFiber=fiber;// While a Suspense Instance does have children, we won't step into\n\t// it during the first pass. Instead, we'll reenter it later.\n\tnextHydratableInstance=null;return true;}return false;}default:return false;}}function shouldClientRenderOnMismatch(fiber){return (fiber.mode&ConcurrentMode)!==NoMode&&(fiber.flags&DidCapture)===NoFlags;}function throwOnHydrationMismatch(fiber){throw new Error('Hydration failed because the initial UI does not match what was '+'rendered on the server.');}function tryToClaimNextHydratableInstance(fiber){if(!isHydrating){return;}var nextInstance=nextHydratableInstance;if(!nextInstance){if(shouldClientRenderOnMismatch(fiber)){warnNonhydratedInstance(hydrationParentFiber,fiber);throwOnHydrationMismatch();}// Nothing to hydrate. Make it an insertion.\n\tinsertNonHydratedInstance(hydrationParentFiber,fiber);isHydrating=false;hydrationParentFiber=fiber;return;}var firstAttemptedInstance=nextInstance;if(!tryHydrate(fiber,nextInstance)){if(shouldClientRenderOnMismatch(fiber)){warnNonhydratedInstance(hydrationParentFiber,fiber);throwOnHydrationMismatch();}// If we can't hydrate this instance let's try the next one.\n\t// We use this as a heuristic. It's based on intuition and not data so it\n\t// might be flawed or unnecessary.\n\tnextInstance=getNextHydratableSibling(firstAttemptedInstance);var prevHydrationParentFiber=hydrationParentFiber;if(!nextInstance||!tryHydrate(fiber,nextInstance)){// Nothing to hydrate. Make it an insertion.\n\tinsertNonHydratedInstance(hydrationParentFiber,fiber);isHydrating=false;hydrationParentFiber=fiber;return;}// We matched the next one, we'll now assume that the first one was\n\t// superfluous and we'll delete it. Since we can't eagerly delete it\n\t// we'll have to schedule a deletion. To do that, this node needs a dummy\n\t// fiber associated with it.\n\tdeleteHydratableInstance(prevHydrationParentFiber,firstAttemptedInstance);}}function prepareToHydrateHostInstance(fiber,rootContainerInstance,hostContext){var instance=fiber.stateNode;var shouldWarnIfMismatchDev=!didSuspendOrErrorDEV;var updatePayload=hydrateInstance(instance,fiber.type,fiber.memoizedProps,rootContainerInstance,hostContext,fiber,shouldWarnIfMismatchDev);// TODO: Type this specific to this type of component.\n\tfiber.updateQueue=updatePayload;// If the update payload indicates that there is a change or if there\n\t// is a new ref we mark this as an update.\n\tif(updatePayload!==null){return true;}return false;}function prepareToHydrateHostTextInstance(fiber){var textInstance=fiber.stateNode;var textContent=fiber.memoizedProps;var shouldUpdate=hydrateTextInstance(textInstance,textContent,fiber);if(shouldUpdate){// We assume that prepareToHydrateHostTextInstance is called in a context where the\n\t// hydration parent is the parent host component of this host text.\n\tvar returnFiber=hydrationParentFiber;if(returnFiber!==null){switch(returnFiber.tag){case HostRoot:{var parentContainer=returnFiber.stateNode.containerInfo;var isConcurrentMode=(returnFiber.mode&ConcurrentMode)!==NoMode;didNotMatchHydratedContainerTextInstance(parentContainer,textInstance,textContent,// TODO: Delete this argument when we remove the legacy root API.\n\tisConcurrentMode);break;}case HostComponent:{var parentType=returnFiber.type;var parentProps=returnFiber.memoizedProps;var parentInstance=returnFiber.stateNode;var _isConcurrentMode2=(returnFiber.mode&ConcurrentMode)!==NoMode;didNotMatchHydratedTextInstance(parentType,parentProps,parentInstance,textInstance,textContent,// TODO: Delete this argument when we remove the legacy root API.\n\t_isConcurrentMode2);break;}}}}return shouldUpdate;}function prepareToHydrateHostSuspenseInstance(fiber){var suspenseState=fiber.memoizedState;var suspenseInstance=suspenseState!==null?suspenseState.dehydrated:null;if(!suspenseInstance){throw new Error('Expected to have a hydrated suspense instance. '+'This error is likely caused by a bug in React. Please file an issue.');}hydrateSuspenseInstance(suspenseInstance,fiber);}function skipPastDehydratedSuspenseInstance(fiber){var suspenseState=fiber.memoizedState;var suspenseInstance=suspenseState!==null?suspenseState.dehydrated:null;if(!suspenseInstance){throw new Error('Expected to have a hydrated suspense instance. '+'This error is likely caused by a bug in React. Please file an issue.');}return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);}function popToNextHostParent(fiber){var parent=fiber.return;while(parent!==null&&parent.tag!==HostComponent&&parent.tag!==HostRoot&&parent.tag!==SuspenseComponent){parent=parent.return;}hydrationParentFiber=parent;}function popHydrationState(fiber){if(fiber!==hydrationParentFiber){// We're deeper than the current hydration context, inside an inserted\n\t// tree.\n\treturn false;}if(!isHydrating){// If we're not currently hydrating but we're in a hydration context, then\n\t// we were an insertion and now need to pop up reenter hydration of our\n\t// siblings.\n\tpopToNextHostParent(fiber);isHydrating=true;return false;}// If we have any remaining hydratable nodes, we need to delete them now.\n\t// We only do this deeper than head and body since they tend to have random\n\t// other nodes in them. We also ignore components with pure text content in\n\t// side of them. We also don't delete anything inside the root container.\n\tif(fiber.tag!==HostRoot&&(fiber.tag!==HostComponent||shouldDeleteUnhydratedTailInstances(fiber.type)&&!shouldSetTextContent(fiber.type,fiber.memoizedProps))){var nextInstance=nextHydratableInstance;if(nextInstance){if(shouldClientRenderOnMismatch(fiber)){warnIfUnhydratedTailNodes(fiber);throwOnHydrationMismatch();}else {while(nextInstance){deleteHydratableInstance(fiber,nextInstance);nextInstance=getNextHydratableSibling(nextInstance);}}}}popToNextHostParent(fiber);if(fiber.tag===SuspenseComponent){nextHydratableInstance=skipPastDehydratedSuspenseInstance(fiber);}else {nextHydratableInstance=hydrationParentFiber?getNextHydratableSibling(fiber.stateNode):null;}return true;}function hasUnhydratedTailNodes(){return isHydrating&&nextHydratableInstance!==null;}function warnIfUnhydratedTailNodes(fiber){var nextInstance=nextHydratableInstance;while(nextInstance){warnUnhydratedInstance(fiber,nextInstance);nextInstance=getNextHydratableSibling(nextInstance);}}function resetHydrationState(){hydrationParentFiber=null;nextHydratableInstance=null;isHydrating=false;didSuspendOrErrorDEV=false;}function upgradeHydrationErrorsToRecoverable(){if(hydrationErrors!==null){// Successfully completed a forced client render. The errors that occurred\n\t// during the hydration attempt are now recovered. We will log them in\n\t// commit phase, once the entire tree has finished.\n\tqueueRecoverableErrors(hydrationErrors);hydrationErrors=null;}}function getIsHydrating(){return isHydrating;}function queueHydrationError(error){if(hydrationErrors===null){hydrationErrors=[error];}else {hydrationErrors.push(error);}}var ReactCurrentBatchConfig$1=ReactSharedInternals.ReactCurrentBatchConfig;var NoTransition=null;function requestCurrentTransition(){return ReactCurrentBatchConfig$1.transition;}var ReactStrictModeWarnings={recordUnsafeLifecycleWarnings:function(fiber,instance){},flushPendingUnsafeLifecycleWarnings:function(){},recordLegacyContextWarning:function(fiber,instance){},flushLegacyContextWarning:function(){},discardPendingWarnings:function(){}};{var findStrictRoot=function(fiber){var maybeStrictRoot=null;var node=fiber;while(node!==null){if(node.mode&StrictLegacyMode){maybeStrictRoot=node;}node=node.return;}return maybeStrictRoot;};var setToSortedString=function(set){var array=[];set.forEach(function(value){array.push(value);});return array.sort().join(', ');};var pendingComponentWillMountWarnings=[];var pendingUNSAFE_ComponentWillMountWarnings=[];var pendingComponentWillReceivePropsWarnings=[];var pendingUNSAFE_ComponentWillReceivePropsWarnings=[];var pendingComponentWillUpdateWarnings=[];var pendingUNSAFE_ComponentWillUpdateWarnings=[];// Tracks components we have already warned about.\n\tvar didWarnAboutUnsafeLifecycles=new Set();ReactStrictModeWarnings.recordUnsafeLifecycleWarnings=function(fiber,instance){// Dedupe strategy: Warn once per component.\n\tif(didWarnAboutUnsafeLifecycles.has(fiber.type)){return;}if(typeof instance.componentWillMount==='function'&&// Don't warn about react-lifecycles-compat polyfilled components.\n\tinstance.componentWillMount.__suppressDeprecationWarning!==true){pendingComponentWillMountWarnings.push(fiber);}if(fiber.mode&StrictLegacyMode&&typeof instance.UNSAFE_componentWillMount==='function'){pendingUNSAFE_ComponentWillMountWarnings.push(fiber);}if(typeof instance.componentWillReceiveProps==='function'&&instance.componentWillReceiveProps.__suppressDeprecationWarning!==true){pendingComponentWillReceivePropsWarnings.push(fiber);}if(fiber.mode&StrictLegacyMode&&typeof instance.UNSAFE_componentWillReceiveProps==='function'){pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber);}if(typeof instance.componentWillUpdate==='function'&&instance.componentWillUpdate.__suppressDeprecationWarning!==true){pendingComponentWillUpdateWarnings.push(fiber);}if(fiber.mode&StrictLegacyMode&&typeof instance.UNSAFE_componentWillUpdate==='function'){pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber);}};ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings=function(){// We do an initial pass to gather component names\n\tvar componentWillMountUniqueNames=new Set();if(pendingComponentWillMountWarnings.length>0){pendingComponentWillMountWarnings.forEach(function(fiber){componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingComponentWillMountWarnings=[];}var UNSAFE_componentWillMountUniqueNames=new Set();if(pendingUNSAFE_ComponentWillMountWarnings.length>0){pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber){UNSAFE_componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingUNSAFE_ComponentWillMountWarnings=[];}var componentWillReceivePropsUniqueNames=new Set();if(pendingComponentWillReceivePropsWarnings.length>0){pendingComponentWillReceivePropsWarnings.forEach(function(fiber){componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingComponentWillReceivePropsWarnings=[];}var UNSAFE_componentWillReceivePropsUniqueNames=new Set();if(pendingUNSAFE_ComponentWillReceivePropsWarnings.length>0){pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber){UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingUNSAFE_ComponentWillReceivePropsWarnings=[];}var componentWillUpdateUniqueNames=new Set();if(pendingComponentWillUpdateWarnings.length>0){pendingComponentWillUpdateWarnings.forEach(function(fiber){componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingComponentWillUpdateWarnings=[];}var UNSAFE_componentWillUpdateUniqueNames=new Set();if(pendingUNSAFE_ComponentWillUpdateWarnings.length>0){pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber){UNSAFE_componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber)||'Component');didWarnAboutUnsafeLifecycles.add(fiber.type);});pendingUNSAFE_ComponentWillUpdateWarnings=[];}// Finally, we flush all the warnings\n\t// UNSAFE_ ones before the deprecated ones, since they'll be 'louder'\n\tif(UNSAFE_componentWillMountUniqueNames.size>0){var sortedNames=setToSortedString(UNSAFE_componentWillMountUniqueNames);error('Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. '+'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n'+'* Move code with side effects to componentDidMount, and set initial state in the constructor.\\n'+'\\nPlease update the following components: %s',sortedNames);}if(UNSAFE_componentWillReceivePropsUniqueNames.size>0){var _sortedNames=setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames);error('Using UNSAFE_componentWillReceiveProps in strict mode is not recommended '+'and may indicate bugs in your code. '+'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n'+'* Move data fetching code or side effects to componentDidUpdate.\\n'+\"* If you're updating state whenever props change, \"+'refactor your code to use memoization techniques or move it to '+'static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\\n'+'\\nPlease update the following components: %s',_sortedNames);}if(UNSAFE_componentWillUpdateUniqueNames.size>0){var _sortedNames2=setToSortedString(UNSAFE_componentWillUpdateUniqueNames);error('Using UNSAFE_componentWillUpdate in strict mode is not recommended '+'and may indicate bugs in your code. '+'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n'+'* Move data fetching code or side effects to componentDidUpdate.\\n'+'\\nPlease update the following components: %s',_sortedNames2);}if(componentWillMountUniqueNames.size>0){var _sortedNames3=setToSortedString(componentWillMountUniqueNames);warn('componentWillMount has been renamed, and is not recommended for use. '+'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n'+'* Move code with side effects to componentDidMount, and set initial state in the constructor.\\n'+'* Rename componentWillMount to UNSAFE_componentWillMount to suppress '+'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. '+'To rename all deprecated lifecycles to their new names, you can run '+'`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n'+'\\nPlease update the following components: %s',_sortedNames3);}if(componentWillReceivePropsUniqueNames.size>0){var _sortedNames4=setToSortedString(componentWillReceivePropsUniqueNames);warn('componentWillReceiveProps has been renamed, and is not recommended for use. '+'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n'+'* Move data fetching code or side effects to componentDidUpdate.\\n'+\"* If you're updating state whenever props change, refactor your \"+'code to use memoization techniques or move it to '+'static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\\n'+'* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress '+'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. '+'To rename all deprecated lifecycles to their new names, you can run '+'`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n'+'\\nPlease update the following components: %s',_sortedNames4);}if(componentWillUpdateUniqueNames.size>0){var _sortedNames5=setToSortedString(componentWillUpdateUniqueNames);warn('componentWillUpdate has been renamed, and is not recommended for use. '+'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n'+'* Move data fetching code or side effects to componentDidUpdate.\\n'+'* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress '+'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. '+'To rename all deprecated lifecycles to their new names, you can run '+'`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n'+'\\nPlease update the following components: %s',_sortedNames5);}};var pendingLegacyContextWarning=new Map();// Tracks components we have already warned about.\n\tvar didWarnAboutLegacyContext=new Set();ReactStrictModeWarnings.recordLegacyContextWarning=function(fiber,instance){var strictRoot=findStrictRoot(fiber);if(strictRoot===null){error('Expected to find a StrictMode component in a strict mode tree. '+'This error is likely caused by a bug in React. Please file an issue.');return;}// Dedup strategy: Warn once per component.\n\tif(didWarnAboutLegacyContext.has(fiber.type)){return;}var warningsForRoot=pendingLegacyContextWarning.get(strictRoot);if(fiber.type.contextTypes!=null||fiber.type.childContextTypes!=null||instance!==null&&typeof instance.getChildContext==='function'){if(warningsForRoot===undefined){warningsForRoot=[];pendingLegacyContextWarning.set(strictRoot,warningsForRoot);}warningsForRoot.push(fiber);}};ReactStrictModeWarnings.flushLegacyContextWarning=function(){pendingLegacyContextWarning.forEach(function(fiberArray,strictRoot){if(fiberArray.length===0){return;}var firstFiber=fiberArray[0];var uniqueNames=new Set();fiberArray.forEach(function(fiber){uniqueNames.add(getComponentNameFromFiber(fiber)||'Component');didWarnAboutLegacyContext.add(fiber.type);});var sortedNames=setToSortedString(uniqueNames);try{setCurrentFiber(firstFiber);error('Legacy context API has been detected within a strict-mode tree.'+'\\n\\nThe old API will be supported in all 16.x releases, but applications '+'using it should migrate to the new version.'+'\\n\\nPlease update the following components: %s'+'\\n\\nLearn more about this warning here: https://reactjs.org/link/legacy-context',sortedNames);}finally{resetCurrentFiber();}});};ReactStrictModeWarnings.discardPendingWarnings=function(){pendingComponentWillMountWarnings=[];pendingUNSAFE_ComponentWillMountWarnings=[];pendingComponentWillReceivePropsWarnings=[];pendingUNSAFE_ComponentWillReceivePropsWarnings=[];pendingComponentWillUpdateWarnings=[];pendingUNSAFE_ComponentWillUpdateWarnings=[];pendingLegacyContextWarning=new Map();};}function resolveDefaultProps(Component,baseProps){if(Component&&Component.defaultProps){// Resolve default props. Taken from ReactElement\n\tvar props=assign({},baseProps);var defaultProps=Component.defaultProps;for(var propName in defaultProps){if(props[propName]===undefined){props[propName]=defaultProps[propName];}}return props;}return baseProps;}var valueCursor=createCursor(null);var rendererSigil;{// Use this to detect multiple renderers using the same context\n\trendererSigil={};}var currentlyRenderingFiber=null;var lastContextDependency=null;var lastFullyObservedContext=null;var isDisallowedContextReadInDEV=false;function resetContextDependencies(){// This is called right before React yields execution, to ensure `readContext`\n\t// cannot be called outside the render phase.\n\tcurrentlyRenderingFiber=null;lastContextDependency=null;lastFullyObservedContext=null;{isDisallowedContextReadInDEV=false;}}function enterDisallowedContextReadInDEV(){{isDisallowedContextReadInDEV=true;}}function exitDisallowedContextReadInDEV(){{isDisallowedContextReadInDEV=false;}}function pushProvider(providerFiber,context,nextValue){{push(valueCursor,context._currentValue,providerFiber);context._currentValue=nextValue;{if(context._currentRenderer!==undefined&&context._currentRenderer!==null&&context._currentRenderer!==rendererSigil){error('Detected multiple renderers concurrently rendering the '+'same context provider. This is currently unsupported.');}context._currentRenderer=rendererSigil;}}}function popProvider(context,providerFiber){var currentValue=valueCursor.current;pop(valueCursor,providerFiber);{{context._currentValue=currentValue;}}}function scheduleContextWorkOnParentPath(parent,renderLanes,propagationRoot){// Update the child lanes of all the ancestors, including the alternates.\n\tvar node=parent;while(node!==null){var alternate=node.alternate;if(!isSubsetOfLanes(node.childLanes,renderLanes)){node.childLanes=mergeLanes(node.childLanes,renderLanes);if(alternate!==null){alternate.childLanes=mergeLanes(alternate.childLanes,renderLanes);}}else if(alternate!==null&&!isSubsetOfLanes(alternate.childLanes,renderLanes)){alternate.childLanes=mergeLanes(alternate.childLanes,renderLanes);}if(node===propagationRoot){break;}node=node.return;}{if(node!==propagationRoot){error('Expected to find the propagation root when scheduling context work. '+'This error is likely caused by a bug in React. Please file an issue.');}}}function propagateContextChange(workInProgress,context,renderLanes){{propagateContextChange_eager(workInProgress,context,renderLanes);}}function propagateContextChange_eager(workInProgress,context,renderLanes){var fiber=workInProgress.child;if(fiber!==null){// Set the return pointer of the child to the work-in-progress fiber.\n\tfiber.return=workInProgress;}while(fiber!==null){var nextFiber=void 0;// Visit this fiber.\n\tvar list=fiber.dependencies;if(list!==null){nextFiber=fiber.child;var dependency=list.firstContext;while(dependency!==null){// Check if the context matches.\n\tif(dependency.context===context){// Match! Schedule an update on this fiber.\n\tif(fiber.tag===ClassComponent){// Schedule a force update on the work-in-progress.\n\tvar lane=pickArbitraryLane(renderLanes);var update=createUpdate(NoTimestamp,lane);update.tag=ForceUpdate;// TODO: Because we don't have a work-in-progress, this will add the\n\t// update to the current fiber, too, which means it will persist even if\n\t// this render is thrown away. Since it's a race condition, not sure it's\n\t// worth fixing.\n\t// Inlined `enqueueUpdate` to remove interleaved update check\n\tvar updateQueue=fiber.updateQueue;if(updateQueue===null);else {var sharedQueue=updateQueue.shared;var pending=sharedQueue.pending;if(pending===null){// This is the first update. Create a circular list.\n\tupdate.next=update;}else {update.next=pending.next;pending.next=update;}sharedQueue.pending=update;}}fiber.lanes=mergeLanes(fiber.lanes,renderLanes);var alternate=fiber.alternate;if(alternate!==null){alternate.lanes=mergeLanes(alternate.lanes,renderLanes);}scheduleContextWorkOnParentPath(fiber.return,renderLanes,workInProgress);// Mark the updated lanes on the list, too.\n\tlist.lanes=mergeLanes(list.lanes,renderLanes);// Since we already found a match, we can stop traversing the\n\t// dependency list.\n\tbreak;}dependency=dependency.next;}}else if(fiber.tag===ContextProvider){// Don't scan deeper if this is a matching provider\n\tnextFiber=fiber.type===workInProgress.type?null:fiber.child;}else if(fiber.tag===DehydratedFragment){// If a dehydrated suspense boundary is in this subtree, we don't know\n\t// if it will have any context consumers in it. The best we can do is\n\t// mark it as having updates.\n\tvar parentSuspense=fiber.return;if(parentSuspense===null){throw new Error('We just came from a parent so we must have had a parent. This is a bug in React.');}parentSuspense.lanes=mergeLanes(parentSuspense.lanes,renderLanes);var _alternate=parentSuspense.alternate;if(_alternate!==null){_alternate.lanes=mergeLanes(_alternate.lanes,renderLanes);}// This is intentionally passing this fiber as the parent\n\t// because we want to schedule this fiber as having work\n\t// on its children. We'll use the childLanes on\n\t// this fiber to indicate that a context has changed.\n\tscheduleContextWorkOnParentPath(parentSuspense,renderLanes,workInProgress);nextFiber=fiber.sibling;}else {// Traverse down.\n\tnextFiber=fiber.child;}if(nextFiber!==null){// Set the return pointer of the child to the work-in-progress fiber.\n\tnextFiber.return=fiber;}else {// No child. Traverse to next sibling.\n\tnextFiber=fiber;while(nextFiber!==null){if(nextFiber===workInProgress){// We're back to the root of this subtree. Exit.\n\tnextFiber=null;break;}var sibling=nextFiber.sibling;if(sibling!==null){// Set the return pointer of the sibling to the work-in-progress fiber.\n\tsibling.return=nextFiber.return;nextFiber=sibling;break;}// No more siblings. Traverse up.\n\tnextFiber=nextFiber.return;}}fiber=nextFiber;}}function prepareToReadContext(workInProgress,renderLanes){currentlyRenderingFiber=workInProgress;lastContextDependency=null;lastFullyObservedContext=null;var dependencies=workInProgress.dependencies;if(dependencies!==null){{var firstContext=dependencies.firstContext;if(firstContext!==null){if(includesSomeLane(dependencies.lanes,renderLanes)){// Context list has a pending update. Mark that this fiber performed work.\n\tmarkWorkInProgressReceivedUpdate();}// Reset the work-in-progress list\n\tdependencies.firstContext=null;}}}}function readContext(context){{// This warning would fire if you read context inside a Hook like useMemo.\n\t// Unlike the class check below, it's not enforced in production for perf.\n\tif(isDisallowedContextReadInDEV){error('Context can only be read while React is rendering. '+'In classes, you can read it in the render method or getDerivedStateFromProps. '+'In function components, you can read it directly in the function body, but not '+'inside Hooks like useReducer() or useMemo().');}}var value=context._currentValue;if(lastFullyObservedContext===context);else {var contextItem={context:context,memoizedValue:value,next:null};if(lastContextDependency===null){if(currentlyRenderingFiber===null){throw new Error('Context can only be read while React is rendering. '+'In classes, you can read it in the render method or getDerivedStateFromProps. '+'In function components, you can read it directly in the function body, but not '+'inside Hooks like useReducer() or useMemo().');}// This is the first dependency for this component. Create a new list.\n\tlastContextDependency=contextItem;currentlyRenderingFiber.dependencies={lanes:NoLanes,firstContext:contextItem};}else {// Append a new context item.\n\tlastContextDependency=lastContextDependency.next=contextItem;}}return value;}// render. When this render exits, either because it finishes or because it is\n\t// interrupted, the interleaved updates will be transferred onto the main part\n\t// of the queue.\n\tvar concurrentQueues=null;function pushConcurrentUpdateQueue(queue){if(concurrentQueues===null){concurrentQueues=[queue];}else {concurrentQueues.push(queue);}}function finishQueueingConcurrentUpdates(){// Transfer the interleaved updates onto the main queue. Each queue has a\n\t// `pending` field and an `interleaved` field. When they are not null, they\n\t// point to the last node in a circular linked list. We need to append the\n\t// interleaved list to the end of the pending list by joining them into a\n\t// single, circular list.\n\tif(concurrentQueues!==null){for(var i=0;i<concurrentQueues.length;i++){var queue=concurrentQueues[i];var lastInterleavedUpdate=queue.interleaved;if(lastInterleavedUpdate!==null){queue.interleaved=null;var firstInterleavedUpdate=lastInterleavedUpdate.next;var lastPendingUpdate=queue.pending;if(lastPendingUpdate!==null){var firstPendingUpdate=lastPendingUpdate.next;lastPendingUpdate.next=firstInterleavedUpdate;lastInterleavedUpdate.next=firstPendingUpdate;}queue.pending=lastInterleavedUpdate;}}concurrentQueues=null;}}function enqueueConcurrentHookUpdate(fiber,queue,update,lane){var interleaved=queue.interleaved;if(interleaved===null){// This is the first update. Create a circular list.\n\tupdate.next=update;// At the end of the current render, this queue's interleaved updates will\n\t// be transferred to the pending queue.\n\tpushConcurrentUpdateQueue(queue);}else {update.next=interleaved.next;interleaved.next=update;}queue.interleaved=update;return markUpdateLaneFromFiberToRoot(fiber,lane);}function enqueueConcurrentHookUpdateAndEagerlyBailout(fiber,queue,update,lane){var interleaved=queue.interleaved;if(interleaved===null){// This is the first update. Create a circular list.\n\tupdate.next=update;// At the end of the current render, this queue's interleaved updates will\n\t// be transferred to the pending queue.\n\tpushConcurrentUpdateQueue(queue);}else {update.next=interleaved.next;interleaved.next=update;}queue.interleaved=update;}function enqueueConcurrentClassUpdate(fiber,queue,update,lane){var interleaved=queue.interleaved;if(interleaved===null){// This is the first update. Create a circular list.\n\tupdate.next=update;// At the end of the current render, this queue's interleaved updates will\n\t// be transferred to the pending queue.\n\tpushConcurrentUpdateQueue(queue);}else {update.next=interleaved.next;interleaved.next=update;}queue.interleaved=update;return markUpdateLaneFromFiberToRoot(fiber,lane);}function enqueueConcurrentRenderForLane(fiber,lane){return markUpdateLaneFromFiberToRoot(fiber,lane);}// Calling this function outside this module should only be done for backwards\n\t// compatibility and should always be accompanied by a warning.\n\tvar unsafe_markUpdateLaneFromFiberToRoot=markUpdateLaneFromFiberToRoot;function markUpdateLaneFromFiberToRoot(sourceFiber,lane){// Update the source fiber's lanes\n\tsourceFiber.lanes=mergeLanes(sourceFiber.lanes,lane);var alternate=sourceFiber.alternate;if(alternate!==null){alternate.lanes=mergeLanes(alternate.lanes,lane);}{if(alternate===null&&(sourceFiber.flags&(Placement|Hydrating))!==NoFlags){warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);}}// Walk the parent path to the root and update the child lanes.\n\tvar node=sourceFiber;var parent=sourceFiber.return;while(parent!==null){parent.childLanes=mergeLanes(parent.childLanes,lane);alternate=parent.alternate;if(alternate!==null){alternate.childLanes=mergeLanes(alternate.childLanes,lane);}else {{if((parent.flags&(Placement|Hydrating))!==NoFlags){warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);}}}node=parent;parent=parent.return;}if(node.tag===HostRoot){var root=node.stateNode;return root;}else {return null;}}var UpdateState=0;var ReplaceState=1;var ForceUpdate=2;var CaptureUpdate=3;// Global state that is reset at the beginning of calling `processUpdateQueue`.\n\t// It should only be read right after calling `processUpdateQueue`, via\n\t// `checkHasForceUpdateAfterProcessing`.\n\tvar hasForceUpdate=false;var didWarnUpdateInsideUpdate;var currentlyProcessingQueue;{didWarnUpdateInsideUpdate=false;currentlyProcessingQueue=null;}function initializeUpdateQueue(fiber){var queue={baseState:fiber.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:NoLanes},effects:null};fiber.updateQueue=queue;}function cloneUpdateQueue(current,workInProgress){// Clone the update queue from current. Unless it's already a clone.\n\tvar queue=workInProgress.updateQueue;var currentQueue=current.updateQueue;if(queue===currentQueue){var clone={baseState:currentQueue.baseState,firstBaseUpdate:currentQueue.firstBaseUpdate,lastBaseUpdate:currentQueue.lastBaseUpdate,shared:currentQueue.shared,effects:currentQueue.effects};workInProgress.updateQueue=clone;}}function createUpdate(eventTime,lane){var update={eventTime:eventTime,lane:lane,tag:UpdateState,payload:null,callback:null,next:null};return update;}function enqueueUpdate(fiber,update,lane){var updateQueue=fiber.updateQueue;if(updateQueue===null){// Only occurs if the fiber has been unmounted.\n\treturn null;}var sharedQueue=updateQueue.shared;{if(currentlyProcessingQueue===sharedQueue&&!didWarnUpdateInsideUpdate){error('An update (setState, replaceState, or forceUpdate) was scheduled '+'from inside an update function. Update functions should be pure, '+'with zero side-effects. Consider using componentDidUpdate or a '+'callback.');didWarnUpdateInsideUpdate=true;}}if(isUnsafeClassRenderPhaseUpdate()){// This is an unsafe render phase update. Add directly to the update\n\t// queue so we can process it immediately during the current render.\n\tvar pending=sharedQueue.pending;if(pending===null){// This is the first update. Create a circular list.\n\tupdate.next=update;}else {update.next=pending.next;pending.next=update;}sharedQueue.pending=update;// Update the childLanes even though we're most likely already rendering\n\t// this fiber. This is for backwards compatibility in the case where you\n\t// update a different component during render phase than the one that is\n\t// currently renderings (a pattern that is accompanied by a warning).\n\treturn unsafe_markUpdateLaneFromFiberToRoot(fiber,lane);}else {return enqueueConcurrentClassUpdate(fiber,sharedQueue,update,lane);}}function entangleTransitions(root,fiber,lane){var updateQueue=fiber.updateQueue;if(updateQueue===null){// Only occurs if the fiber has been unmounted.\n\treturn;}var sharedQueue=updateQueue.shared;if(isTransitionLane(lane)){var queueLanes=sharedQueue.lanes;// If any entangled lanes are no longer pending on the root, then they must\n\t// have finished. We can remove them from the shared queue, which represents\n\t// a superset of the actually pending lanes. In some cases we may entangle\n\t// more than we need to, but that's OK. In fact it's worse if we *don't*\n\t// entangle when we should.\n\tqueueLanes=intersectLanes(queueLanes,root.pendingLanes);// Entangle the new transition lane with the other transition lanes.\n\tvar newQueueLanes=mergeLanes(queueLanes,lane);sharedQueue.lanes=newQueueLanes;// Even if queue.lanes already include lane, we don't know for certain if\n\t// the lane finished since the last time we entangled it. So we need to\n\t// entangle it again, just to be sure.\n\tmarkRootEntangled(root,newQueueLanes);}}function enqueueCapturedUpdate(workInProgress,capturedUpdate){// Captured updates are updates that are thrown by a child during the render\n\t// phase. They should be discarded if the render is aborted. Therefore,\n\t// we should only put them on the work-in-progress queue, not the current one.\n\tvar queue=workInProgress.updateQueue;// Check if the work-in-progress queue is a clone.\n\tvar current=workInProgress.alternate;if(current!==null){var currentQueue=current.updateQueue;if(queue===currentQueue){// The work-in-progress queue is the same as current. This happens when\n\t// we bail out on a parent fiber that then captures an error thrown by\n\t// a child. Since we want to append the update only to the work-in\n\t// -progress queue, we need to clone the updates. We usually clone during\n\t// processUpdateQueue, but that didn't happen in this case because we\n\t// skipped over the parent when we bailed out.\n\tvar newFirst=null;var newLast=null;var firstBaseUpdate=queue.firstBaseUpdate;if(firstBaseUpdate!==null){// Loop through the updates and clone them.\n\tvar update=firstBaseUpdate;do{var clone={eventTime:update.eventTime,lane:update.lane,tag:update.tag,payload:update.payload,callback:update.callback,next:null};if(newLast===null){newFirst=newLast=clone;}else {newLast.next=clone;newLast=clone;}update=update.next;}while(update!==null);// Append the captured update the end of the cloned list.\n\tif(newLast===null){newFirst=newLast=capturedUpdate;}else {newLast.next=capturedUpdate;newLast=capturedUpdate;}}else {// There are no base updates.\n\tnewFirst=newLast=capturedUpdate;}queue={baseState:currentQueue.baseState,firstBaseUpdate:newFirst,lastBaseUpdate:newLast,shared:currentQueue.shared,effects:currentQueue.effects};workInProgress.updateQueue=queue;return;}}// Append the update to the end of the list.\n\tvar lastBaseUpdate=queue.lastBaseUpdate;if(lastBaseUpdate===null){queue.firstBaseUpdate=capturedUpdate;}else {lastBaseUpdate.next=capturedUpdate;}queue.lastBaseUpdate=capturedUpdate;}function getStateFromUpdate(workInProgress,queue,update,prevState,nextProps,instance){switch(update.tag){case ReplaceState:{var payload=update.payload;if(typeof payload==='function'){// Updater function\n\t{enterDisallowedContextReadInDEV();}var nextState=payload.call(instance,prevState,nextProps);{if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{payload.call(instance,prevState,nextProps);}finally{setIsStrictModeForDevtools(false);}}exitDisallowedContextReadInDEV();}return nextState;}// State object\n\treturn payload;}case CaptureUpdate:{workInProgress.flags=workInProgress.flags&~ShouldCapture|DidCapture;}// Intentional fallthrough\n\tcase UpdateState:{var _payload=update.payload;var partialState;if(typeof _payload==='function'){// Updater function\n\t{enterDisallowedContextReadInDEV();}partialState=_payload.call(instance,prevState,nextProps);{if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{_payload.call(instance,prevState,nextProps);}finally{setIsStrictModeForDevtools(false);}}exitDisallowedContextReadInDEV();}}else {// Partial state object\n\tpartialState=_payload;}if(partialState===null||partialState===undefined){// Null and undefined are treated as no-ops.\n\treturn prevState;}// Merge the partial state and the previous state.\n\treturn assign({},prevState,partialState);}case ForceUpdate:{hasForceUpdate=true;return prevState;}}return prevState;}function processUpdateQueue(workInProgress,props,instance,renderLanes){// This is always non-null on a ClassComponent or HostRoot\n\tvar queue=workInProgress.updateQueue;hasForceUpdate=false;{currentlyProcessingQueue=queue.shared;}var firstBaseUpdate=queue.firstBaseUpdate;var lastBaseUpdate=queue.lastBaseUpdate;// Check if there are pending updates. If so, transfer them to the base queue.\n\tvar pendingQueue=queue.shared.pending;if(pendingQueue!==null){queue.shared.pending=null;// The pending queue is circular. Disconnect the pointer between first\n\t// and last so that it's non-circular.\n\tvar lastPendingUpdate=pendingQueue;var firstPendingUpdate=lastPendingUpdate.next;lastPendingUpdate.next=null;// Append pending updates to base queue\n\tif(lastBaseUpdate===null){firstBaseUpdate=firstPendingUpdate;}else {lastBaseUpdate.next=firstPendingUpdate;}lastBaseUpdate=lastPendingUpdate;// If there's a current queue, and it's different from the base queue, then\n\t// we need to transfer the updates to that queue, too. Because the base\n\t// queue is a singly-linked list with no cycles, we can append to both\n\t// lists and take advantage of structural sharing.\n\t// TODO: Pass `current` as argument\n\tvar current=workInProgress.alternate;if(current!==null){// This is always non-null on a ClassComponent or HostRoot\n\tvar currentQueue=current.updateQueue;var currentLastBaseUpdate=currentQueue.lastBaseUpdate;if(currentLastBaseUpdate!==lastBaseUpdate){if(currentLastBaseUpdate===null){currentQueue.firstBaseUpdate=firstPendingUpdate;}else {currentLastBaseUpdate.next=firstPendingUpdate;}currentQueue.lastBaseUpdate=lastPendingUpdate;}}}// These values may change as we process the queue.\n\tif(firstBaseUpdate!==null){// Iterate through the list of updates to compute the result.\n\tvar newState=queue.baseState;// TODO: Don't need to accumulate this. Instead, we can remove renderLanes\n\t// from the original lanes.\n\tvar newLanes=NoLanes;var newBaseState=null;var newFirstBaseUpdate=null;var newLastBaseUpdate=null;var update=firstBaseUpdate;do{var updateLane=update.lane;var updateEventTime=update.eventTime;if(!isSubsetOfLanes(renderLanes,updateLane)){// Priority is insufficient. Skip this update. If this is the first\n\t// skipped update, the previous update/state is the new base\n\t// update/state.\n\tvar clone={eventTime:updateEventTime,lane:updateLane,tag:update.tag,payload:update.payload,callback:update.callback,next:null};if(newLastBaseUpdate===null){newFirstBaseUpdate=newLastBaseUpdate=clone;newBaseState=newState;}else {newLastBaseUpdate=newLastBaseUpdate.next=clone;}// Update the remaining priority in the queue.\n\tnewLanes=mergeLanes(newLanes,updateLane);}else {// This update does have sufficient priority.\n\tif(newLastBaseUpdate!==null){var _clone={eventTime:updateEventTime,// This update is going to be committed so we never want uncommit\n\t// it. Using NoLane works because 0 is a subset of all bitmasks, so\n\t// this will never be skipped by the check above.\n\tlane:NoLane,tag:update.tag,payload:update.payload,callback:update.callback,next:null};newLastBaseUpdate=newLastBaseUpdate.next=_clone;}// Process this update.\n\tnewState=getStateFromUpdate(workInProgress,queue,update,newState,props,instance);var callback=update.callback;if(callback!==null&&// If the update was already committed, we should not queue its\n\t// callback again.\n\tupdate.lane!==NoLane){workInProgress.flags|=Callback;var effects=queue.effects;if(effects===null){queue.effects=[update];}else {effects.push(update);}}}update=update.next;if(update===null){pendingQueue=queue.shared.pending;if(pendingQueue===null){break;}else {// An update was scheduled from inside a reducer. Add the new\n\t// pending updates to the end of the list and keep processing.\n\tvar _lastPendingUpdate=pendingQueue;// Intentionally unsound. Pending updates form a circular list, but we\n\t// unravel them when transferring them to the base queue.\n\tvar _firstPendingUpdate=_lastPendingUpdate.next;_lastPendingUpdate.next=null;update=_firstPendingUpdate;queue.lastBaseUpdate=_lastPendingUpdate;queue.shared.pending=null;}}}while(true);if(newLastBaseUpdate===null){newBaseState=newState;}queue.baseState=newBaseState;queue.firstBaseUpdate=newFirstBaseUpdate;queue.lastBaseUpdate=newLastBaseUpdate;// Interleaved updates are stored on a separate queue. We aren't going to\n\t// process them during this render, but we do need to track which lanes\n\t// are remaining.\n\tvar lastInterleaved=queue.shared.interleaved;if(lastInterleaved!==null){var interleaved=lastInterleaved;do{newLanes=mergeLanes(newLanes,interleaved.lane);interleaved=interleaved.next;}while(interleaved!==lastInterleaved);}else if(firstBaseUpdate===null){// `queue.lanes` is used for entangling transitions. We can set it back to\n\t// zero once the queue is empty.\n\tqueue.shared.lanes=NoLanes;}// Set the remaining expiration time to be whatever is remaining in the queue.\n\t// This should be fine because the only two other things that contribute to\n\t// expiration time are props and context. We're already in the middle of the\n\t// begin phase by the time we start processing the queue, so we've already\n\t// dealt with the props. Context in components that specify\n\t// shouldComponentUpdate is tricky; but we'll have to account for\n\t// that regardless.\n\tmarkSkippedUpdateLanes(newLanes);workInProgress.lanes=newLanes;workInProgress.memoizedState=newState;}{currentlyProcessingQueue=null;}}function callCallback(callback,context){if(typeof callback!=='function'){throw new Error('Invalid argument passed as callback. Expected a function. Instead '+(\"received: \"+callback));}callback.call(context);}function resetHasForceUpdateBeforeProcessing(){hasForceUpdate=false;}function checkHasForceUpdateAfterProcessing(){return hasForceUpdate;}function commitUpdateQueue(finishedWork,finishedQueue,instance){// Commit the effects\n\tvar effects=finishedQueue.effects;finishedQueue.effects=null;if(effects!==null){for(var i=0;i<effects.length;i++){var effect=effects[i];var callback=effect.callback;if(callback!==null){effect.callback=null;callCallback(callback,instance);}}}}var fakeInternalInstance={};// React.Component uses a shared frozen object by default.\n\t// We'll use it to determine whether we need to initialize legacy refs.\n\tvar emptyRefsObject=new React.Component().refs;var didWarnAboutStateAssignmentForComponent;var didWarnAboutUninitializedState;var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;var didWarnAboutLegacyLifecyclesAndDerivedState;var didWarnAboutUndefinedDerivedState;var warnOnUndefinedDerivedState;var warnOnInvalidCallback;var didWarnAboutDirectlyAssigningPropsToState;var didWarnAboutContextTypeAndContextTypes;var didWarnAboutInvalidateContextType;{didWarnAboutStateAssignmentForComponent=new Set();didWarnAboutUninitializedState=new Set();didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate=new Set();didWarnAboutLegacyLifecyclesAndDerivedState=new Set();didWarnAboutDirectlyAssigningPropsToState=new Set();didWarnAboutUndefinedDerivedState=new Set();didWarnAboutContextTypeAndContextTypes=new Set();didWarnAboutInvalidateContextType=new Set();var didWarnOnInvalidCallback=new Set();warnOnInvalidCallback=function(callback,callerName){if(callback===null||typeof callback==='function'){return;}var key=callerName+'_'+callback;if(!didWarnOnInvalidCallback.has(key)){didWarnOnInvalidCallback.add(key);error('%s(...): Expected the last optional `callback` argument to be a '+'function. Instead received: %s.',callerName,callback);}};warnOnUndefinedDerivedState=function(type,partialState){if(partialState===undefined){var componentName=getComponentNameFromType(type)||'Component';if(!didWarnAboutUndefinedDerivedState.has(componentName)){didWarnAboutUndefinedDerivedState.add(componentName);error('%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. '+'You have returned undefined.',componentName);}}};// This is so gross but it's at least non-critical and can be removed if\n\t// it causes problems. This is meant to give a nicer error message for\n\t// ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,\n\t// ...)) which otherwise throws a \"_processChildContext is not a function\"\n\t// exception.\n\tObject.defineProperty(fakeInternalInstance,'_processChildContext',{enumerable:false,value:function(){throw new Error('_processChildContext is not available in React 16+. This likely '+'means you have multiple copies of React and are attempting to nest '+'a React 15 tree inside a React 16 tree using '+\"unstable_renderSubtreeIntoContainer, which isn't supported. Try \"+'to make sure you have only one copy of React (and ideally, switch '+'to ReactDOM.createPortal).');}});Object.freeze(fakeInternalInstance);}function applyDerivedStateFromProps(workInProgress,ctor,getDerivedStateFromProps,nextProps){var prevState=workInProgress.memoizedState;var partialState=getDerivedStateFromProps(nextProps,prevState);{if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{// Invoke the function an extra time to help detect side-effects.\n\tpartialState=getDerivedStateFromProps(nextProps,prevState);}finally{setIsStrictModeForDevtools(false);}}warnOnUndefinedDerivedState(ctor,partialState);}// Merge the partial state and the previous state.\n\tvar memoizedState=partialState===null||partialState===undefined?prevState:assign({},prevState,partialState);workInProgress.memoizedState=memoizedState;// Once the update queue is empty, persist the derived state onto the\n\t// base state.\n\tif(workInProgress.lanes===NoLanes){// Queue is always non-null for classes\n\tvar updateQueue=workInProgress.updateQueue;updateQueue.baseState=memoizedState;}}var classComponentUpdater={isMounted:isMounted,enqueueSetState:function(inst,payload,callback){var fiber=get(inst);var eventTime=requestEventTime();var lane=requestUpdateLane(fiber);var update=createUpdate(eventTime,lane);update.payload=payload;if(callback!==undefined&&callback!==null){{warnOnInvalidCallback(callback,'setState');}update.callback=callback;}var root=enqueueUpdate(fiber,update,lane);if(root!==null){scheduleUpdateOnFiber(root,fiber,lane,eventTime);entangleTransitions(root,fiber,lane);}{markStateUpdateScheduled(fiber,lane);}},enqueueReplaceState:function(inst,payload,callback){var fiber=get(inst);var eventTime=requestEventTime();var lane=requestUpdateLane(fiber);var update=createUpdate(eventTime,lane);update.tag=ReplaceState;update.payload=payload;if(callback!==undefined&&callback!==null){{warnOnInvalidCallback(callback,'replaceState');}update.callback=callback;}var root=enqueueUpdate(fiber,update,lane);if(root!==null){scheduleUpdateOnFiber(root,fiber,lane,eventTime);entangleTransitions(root,fiber,lane);}{markStateUpdateScheduled(fiber,lane);}},enqueueForceUpdate:function(inst,callback){var fiber=get(inst);var eventTime=requestEventTime();var lane=requestUpdateLane(fiber);var update=createUpdate(eventTime,lane);update.tag=ForceUpdate;if(callback!==undefined&&callback!==null){{warnOnInvalidCallback(callback,'forceUpdate');}update.callback=callback;}var root=enqueueUpdate(fiber,update,lane);if(root!==null){scheduleUpdateOnFiber(root,fiber,lane,eventTime);entangleTransitions(root,fiber,lane);}{markForceUpdateScheduled(fiber,lane);}}};function checkShouldComponentUpdate(workInProgress,ctor,oldProps,newProps,oldState,newState,nextContext){var instance=workInProgress.stateNode;if(typeof instance.shouldComponentUpdate==='function'){var shouldUpdate=instance.shouldComponentUpdate(newProps,newState,nextContext);{if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{// Invoke the function an extra time to help detect side-effects.\n\tshouldUpdate=instance.shouldComponentUpdate(newProps,newState,nextContext);}finally{setIsStrictModeForDevtools(false);}}if(shouldUpdate===undefined){error('%s.shouldComponentUpdate(): Returned undefined instead of a '+'boolean value. Make sure to return true or false.',getComponentNameFromType(ctor)||'Component');}}return shouldUpdate;}if(ctor.prototype&&ctor.prototype.isPureReactComponent){return !shallowEqual(oldProps,newProps)||!shallowEqual(oldState,newState);}return true;}function checkClassInstance(workInProgress,ctor,newProps){var instance=workInProgress.stateNode;{var name=getComponentNameFromType(ctor)||'Component';var renderPresent=instance.render;if(!renderPresent){if(ctor.prototype&&typeof ctor.prototype.render==='function'){error('%s(...): No `render` method found on the returned component '+'instance: did you accidentally return an object from the constructor?',name);}else {error('%s(...): No `render` method found on the returned component '+'instance: you may have forgotten to define `render`.',name);}}if(instance.getInitialState&&!instance.getInitialState.isReactClassApproved&&!instance.state){error('getInitialState was defined on %s, a plain JavaScript class. '+'This is only supported for classes created using React.createClass. '+'Did you mean to define a state property instead?',name);}if(instance.getDefaultProps&&!instance.getDefaultProps.isReactClassApproved){error('getDefaultProps was defined on %s, a plain JavaScript class. '+'This is only supported for classes created using React.createClass. '+'Use a static property to define defaultProps instead.',name);}if(instance.propTypes){error('propTypes was defined as an instance property on %s. Use a static '+'property to define propTypes instead.',name);}if(instance.contextType){error('contextType was defined as an instance property on %s. Use a static '+'property to define contextType instead.',name);}{if(instance.contextTypes){error('contextTypes was defined as an instance property on %s. Use a static '+'property to define contextTypes instead.',name);}if(ctor.contextType&&ctor.contextTypes&&!didWarnAboutContextTypeAndContextTypes.has(ctor)){didWarnAboutContextTypeAndContextTypes.add(ctor);error('%s declares both contextTypes and contextType static properties. '+'The legacy contextTypes property will be ignored.',name);}}if(typeof instance.componentShouldUpdate==='function'){error('%s has a method called '+'componentShouldUpdate(). Did you mean shouldComponentUpdate()? '+'The name is phrased as a question because the function is '+'expected to return a value.',name);}if(ctor.prototype&&ctor.prototype.isPureReactComponent&&typeof instance.shouldComponentUpdate!=='undefined'){error('%s has a method called shouldComponentUpdate(). '+'shouldComponentUpdate should not be used when extending React.PureComponent. '+'Please extend React.Component if shouldComponentUpdate is used.',getComponentNameFromType(ctor)||'A pure component');}if(typeof instance.componentDidUnmount==='function'){error('%s has a method called '+'componentDidUnmount(). But there is no such lifecycle method. '+'Did you mean componentWillUnmount()?',name);}if(typeof instance.componentDidReceiveProps==='function'){error('%s has a method called '+'componentDidReceiveProps(). But there is no such lifecycle method. '+'If you meant to update the state in response to changing props, '+'use componentWillReceiveProps(). If you meant to fetch data or '+'run side-effects or mutations after React has updated the UI, use componentDidUpdate().',name);}if(typeof instance.componentWillRecieveProps==='function'){error('%s has a method called '+'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?',name);}if(typeof instance.UNSAFE_componentWillRecieveProps==='function'){error('%s has a method called '+'UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?',name);}var hasMutatedProps=instance.props!==newProps;if(instance.props!==undefined&&hasMutatedProps){error('%s(...): When calling super() in `%s`, make sure to pass '+\"up the same props that your component's constructor was passed.\",name,name);}if(instance.defaultProps){error('Setting defaultProps as an instance property on %s is not supported and will be ignored.'+' Instead, define defaultProps as a static property on %s.',name,name);}if(typeof instance.getSnapshotBeforeUpdate==='function'&&typeof instance.componentDidUpdate!=='function'&&!didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)){didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);error('%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). '+'This component defines getSnapshotBeforeUpdate() only.',getComponentNameFromType(ctor));}if(typeof instance.getDerivedStateFromProps==='function'){error('%s: getDerivedStateFromProps() is defined as an instance method '+'and will be ignored. Instead, declare it as a static method.',name);}if(typeof instance.getDerivedStateFromError==='function'){error('%s: getDerivedStateFromError() is defined as an instance method '+'and will be ignored. Instead, declare it as a static method.',name);}if(typeof ctor.getSnapshotBeforeUpdate==='function'){error('%s: getSnapshotBeforeUpdate() is defined as a static method '+'and will be ignored. Instead, declare it as an instance method.',name);}var _state=instance.state;if(_state&&(typeof _state!=='object'||isArray(_state))){error('%s.state: must be set to an object or null',name);}if(typeof instance.getChildContext==='function'&&typeof ctor.childContextTypes!=='object'){error('%s.getChildContext(): childContextTypes must be defined in order to '+'use getChildContext().',name);}}}function adoptClassInstance(workInProgress,instance){instance.updater=classComponentUpdater;workInProgress.stateNode=instance;// The instance needs access to the fiber so that it can schedule updates\n\tset(instance,workInProgress);{instance._reactInternalInstance=fakeInternalInstance;}}function constructClassInstance(workInProgress,ctor,props){var isLegacyContextConsumer=false;var unmaskedContext=emptyContextObject;var context=emptyContextObject;var contextType=ctor.contextType;{if('contextType'in ctor){var isValid=// Allow null for conditional declaration\n\tcontextType===null||contextType!==undefined&&contextType.$$typeof===REACT_CONTEXT_TYPE&&contextType._context===undefined;// Not a <Context.Consumer>\n\tif(!isValid&&!didWarnAboutInvalidateContextType.has(ctor)){didWarnAboutInvalidateContextType.add(ctor);var addendum='';if(contextType===undefined){addendum=' However, it is set to undefined. '+'This can be caused by a typo or by mixing up named and default imports. '+'This can also happen due to a circular dependency, so '+'try moving the createContext() call to a separate file.';}else if(typeof contextType!=='object'){addendum=' However, it is set to a '+typeof contextType+'.';}else if(contextType.$$typeof===REACT_PROVIDER_TYPE){addendum=' Did you accidentally pass the Context.Provider instead?';}else if(contextType._context!==undefined){// <Context.Consumer>\n\taddendum=' Did you accidentally pass the Context.Consumer instead?';}else {addendum=' However, it is set to an object with keys {'+Object.keys(contextType).join(', ')+'}.';}error('%s defines an invalid contextType. '+'contextType should point to the Context object returned by React.createContext().%s',getComponentNameFromType(ctor)||'Component',addendum);}}}if(typeof contextType==='object'&&contextType!==null){context=readContext(contextType);}else {unmaskedContext=getUnmaskedContext(workInProgress,ctor,true);var contextTypes=ctor.contextTypes;isLegacyContextConsumer=contextTypes!==null&&contextTypes!==undefined;context=isLegacyContextConsumer?getMaskedContext(workInProgress,unmaskedContext):emptyContextObject;}var instance=new ctor(props,context);// Instantiate twice to help detect side-effects.\n\t{if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{instance=new ctor(props,context);// eslint-disable-line no-new\n\t}finally{setIsStrictModeForDevtools(false);}}}var state=workInProgress.memoizedState=instance.state!==null&&instance.state!==undefined?instance.state:null;adoptClassInstance(workInProgress,instance);{if(typeof ctor.getDerivedStateFromProps==='function'&&state===null){var componentName=getComponentNameFromType(ctor)||'Component';if(!didWarnAboutUninitializedState.has(componentName)){didWarnAboutUninitializedState.add(componentName);error('`%s` uses `getDerivedStateFromProps` but its initial state is '+'%s. This is not recommended. Instead, define the initial state by '+'assigning an object to `this.state` in the constructor of `%s`. '+'This ensures that `getDerivedStateFromProps` arguments have a consistent shape.',componentName,instance.state===null?'null':'undefined',componentName);}}// If new component APIs are defined, \"unsafe\" lifecycles won't be called.\n\t// Warn about these lifecycles if they are present.\n\t// Don't warn about react-lifecycles-compat polyfilled methods though.\n\tif(typeof ctor.getDerivedStateFromProps==='function'||typeof instance.getSnapshotBeforeUpdate==='function'){var foundWillMountName=null;var foundWillReceivePropsName=null;var foundWillUpdateName=null;if(typeof instance.componentWillMount==='function'&&instance.componentWillMount.__suppressDeprecationWarning!==true){foundWillMountName='componentWillMount';}else if(typeof instance.UNSAFE_componentWillMount==='function'){foundWillMountName='UNSAFE_componentWillMount';}if(typeof instance.componentWillReceiveProps==='function'&&instance.componentWillReceiveProps.__suppressDeprecationWarning!==true){foundWillReceivePropsName='componentWillReceiveProps';}else if(typeof instance.UNSAFE_componentWillReceiveProps==='function'){foundWillReceivePropsName='UNSAFE_componentWillReceiveProps';}if(typeof instance.componentWillUpdate==='function'&&instance.componentWillUpdate.__suppressDeprecationWarning!==true){foundWillUpdateName='componentWillUpdate';}else if(typeof instance.UNSAFE_componentWillUpdate==='function'){foundWillUpdateName='UNSAFE_componentWillUpdate';}if(foundWillMountName!==null||foundWillReceivePropsName!==null||foundWillUpdateName!==null){var _componentName=getComponentNameFromType(ctor)||'Component';var newApiName=typeof ctor.getDerivedStateFromProps==='function'?'getDerivedStateFromProps()':'getSnapshotBeforeUpdate()';if(!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)){didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);error('Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n'+'%s uses %s but also contains the following legacy lifecycles:%s%s%s\\n\\n'+'The above lifecycles should be removed. Learn more about this warning here:\\n'+'https://reactjs.org/link/unsafe-component-lifecycles',_componentName,newApiName,foundWillMountName!==null?\"\\n  \"+foundWillMountName:'',foundWillReceivePropsName!==null?\"\\n  \"+foundWillReceivePropsName:'',foundWillUpdateName!==null?\"\\n  \"+foundWillUpdateName:'');}}}}// Cache unmasked context so we can avoid recreating masked context unless necessary.\n\t// ReactFiberContext usually updates this cache but can't for newly-created instances.\n\tif(isLegacyContextConsumer){cacheContext(workInProgress,unmaskedContext,context);}return instance;}function callComponentWillMount(workInProgress,instance){var oldState=instance.state;if(typeof instance.componentWillMount==='function'){instance.componentWillMount();}if(typeof instance.UNSAFE_componentWillMount==='function'){instance.UNSAFE_componentWillMount();}if(oldState!==instance.state){{error('%s.componentWillMount(): Assigning directly to this.state is '+\"deprecated (except inside a component's \"+'constructor). Use setState instead.',getComponentNameFromFiber(workInProgress)||'Component');}classComponentUpdater.enqueueReplaceState(instance,instance.state,null);}}function callComponentWillReceiveProps(workInProgress,instance,newProps,nextContext){var oldState=instance.state;if(typeof instance.componentWillReceiveProps==='function'){instance.componentWillReceiveProps(newProps,nextContext);}if(typeof instance.UNSAFE_componentWillReceiveProps==='function'){instance.UNSAFE_componentWillReceiveProps(newProps,nextContext);}if(instance.state!==oldState){{var componentName=getComponentNameFromFiber(workInProgress)||'Component';if(!didWarnAboutStateAssignmentForComponent.has(componentName)){didWarnAboutStateAssignmentForComponent.add(componentName);error('%s.componentWillReceiveProps(): Assigning directly to '+\"this.state is deprecated (except inside a component's \"+'constructor). Use setState instead.',componentName);}}classComponentUpdater.enqueueReplaceState(instance,instance.state,null);}}// Invokes the mount life-cycles on a previously never rendered instance.\n\tfunction mountClassInstance(workInProgress,ctor,newProps,renderLanes){{checkClassInstance(workInProgress,ctor,newProps);}var instance=workInProgress.stateNode;instance.props=newProps;instance.state=workInProgress.memoizedState;instance.refs=emptyRefsObject;initializeUpdateQueue(workInProgress);var contextType=ctor.contextType;if(typeof contextType==='object'&&contextType!==null){instance.context=readContext(contextType);}else {var unmaskedContext=getUnmaskedContext(workInProgress,ctor,true);instance.context=getMaskedContext(workInProgress,unmaskedContext);}{if(instance.state===newProps){var componentName=getComponentNameFromType(ctor)||'Component';if(!didWarnAboutDirectlyAssigningPropsToState.has(componentName)){didWarnAboutDirectlyAssigningPropsToState.add(componentName);error('%s: It is not recommended to assign props directly to state '+\"because updates to props won't be reflected in state. \"+'In most cases, it is better to use props directly.',componentName);}}if(workInProgress.mode&StrictLegacyMode){ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress,instance);}{ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress,instance);}}instance.state=workInProgress.memoizedState;var getDerivedStateFromProps=ctor.getDerivedStateFromProps;if(typeof getDerivedStateFromProps==='function'){applyDerivedStateFromProps(workInProgress,ctor,getDerivedStateFromProps,newProps);instance.state=workInProgress.memoizedState;}// In order to support react-lifecycles-compat polyfilled components,\n\t// Unsafe lifecycles should not be invoked for components using the new APIs.\n\tif(typeof ctor.getDerivedStateFromProps!=='function'&&typeof instance.getSnapshotBeforeUpdate!=='function'&&(typeof instance.UNSAFE_componentWillMount==='function'||typeof instance.componentWillMount==='function')){callComponentWillMount(workInProgress,instance);// If we had additional state updates during this life-cycle, let's\n\t// process them now.\n\tprocessUpdateQueue(workInProgress,newProps,instance,renderLanes);instance.state=workInProgress.memoizedState;}if(typeof instance.componentDidMount==='function'){var fiberFlags=Update;{fiberFlags|=LayoutStatic;}if((workInProgress.mode&StrictEffectsMode)!==NoMode){fiberFlags|=MountLayoutDev;}workInProgress.flags|=fiberFlags;}}function resumeMountClassInstance(workInProgress,ctor,newProps,renderLanes){var instance=workInProgress.stateNode;var oldProps=workInProgress.memoizedProps;instance.props=oldProps;var oldContext=instance.context;var contextType=ctor.contextType;var nextContext=emptyContextObject;if(typeof contextType==='object'&&contextType!==null){nextContext=readContext(contextType);}else {var nextLegacyUnmaskedContext=getUnmaskedContext(workInProgress,ctor,true);nextContext=getMaskedContext(workInProgress,nextLegacyUnmaskedContext);}var getDerivedStateFromProps=ctor.getDerivedStateFromProps;var hasNewLifecycles=typeof getDerivedStateFromProps==='function'||typeof instance.getSnapshotBeforeUpdate==='function';// Note: During these life-cycles, instance.props/instance.state are what\n\t// ever the previously attempted to render - not the \"current\". However,\n\t// during componentDidUpdate we pass the \"current\" props.\n\t// In order to support react-lifecycles-compat polyfilled components,\n\t// Unsafe lifecycles should not be invoked for components using the new APIs.\n\tif(!hasNewLifecycles&&(typeof instance.UNSAFE_componentWillReceiveProps==='function'||typeof instance.componentWillReceiveProps==='function')){if(oldProps!==newProps||oldContext!==nextContext){callComponentWillReceiveProps(workInProgress,instance,newProps,nextContext);}}resetHasForceUpdateBeforeProcessing();var oldState=workInProgress.memoizedState;var newState=instance.state=oldState;processUpdateQueue(workInProgress,newProps,instance,renderLanes);newState=workInProgress.memoizedState;if(oldProps===newProps&&oldState===newState&&!hasContextChanged()&&!checkHasForceUpdateAfterProcessing()){// If an update was already in progress, we should schedule an Update\n\t// effect even though we're bailing out, so that cWU/cDU are called.\n\tif(typeof instance.componentDidMount==='function'){var fiberFlags=Update;{fiberFlags|=LayoutStatic;}if((workInProgress.mode&StrictEffectsMode)!==NoMode){fiberFlags|=MountLayoutDev;}workInProgress.flags|=fiberFlags;}return false;}if(typeof getDerivedStateFromProps==='function'){applyDerivedStateFromProps(workInProgress,ctor,getDerivedStateFromProps,newProps);newState=workInProgress.memoizedState;}var shouldUpdate=checkHasForceUpdateAfterProcessing()||checkShouldComponentUpdate(workInProgress,ctor,oldProps,newProps,oldState,newState,nextContext);if(shouldUpdate){// In order to support react-lifecycles-compat polyfilled components,\n\t// Unsafe lifecycles should not be invoked for components using the new APIs.\n\tif(!hasNewLifecycles&&(typeof instance.UNSAFE_componentWillMount==='function'||typeof instance.componentWillMount==='function')){if(typeof instance.componentWillMount==='function'){instance.componentWillMount();}if(typeof instance.UNSAFE_componentWillMount==='function'){instance.UNSAFE_componentWillMount();}}if(typeof instance.componentDidMount==='function'){var _fiberFlags=Update;{_fiberFlags|=LayoutStatic;}if((workInProgress.mode&StrictEffectsMode)!==NoMode){_fiberFlags|=MountLayoutDev;}workInProgress.flags|=_fiberFlags;}}else {// If an update was already in progress, we should schedule an Update\n\t// effect even though we're bailing out, so that cWU/cDU are called.\n\tif(typeof instance.componentDidMount==='function'){var _fiberFlags2=Update;{_fiberFlags2|=LayoutStatic;}if((workInProgress.mode&StrictEffectsMode)!==NoMode){_fiberFlags2|=MountLayoutDev;}workInProgress.flags|=_fiberFlags2;}// If shouldComponentUpdate returned false, we should still update the\n\t// memoized state to indicate that this work can be reused.\n\tworkInProgress.memoizedProps=newProps;workInProgress.memoizedState=newState;}// Update the existing instance's state, props, and context pointers even\n\t// if shouldComponentUpdate returns false.\n\tinstance.props=newProps;instance.state=newState;instance.context=nextContext;return shouldUpdate;}// Invokes the update life-cycles and returns false if it shouldn't rerender.\n\tfunction updateClassInstance(current,workInProgress,ctor,newProps,renderLanes){var instance=workInProgress.stateNode;cloneUpdateQueue(current,workInProgress);var unresolvedOldProps=workInProgress.memoizedProps;var oldProps=workInProgress.type===workInProgress.elementType?unresolvedOldProps:resolveDefaultProps(workInProgress.type,unresolvedOldProps);instance.props=oldProps;var unresolvedNewProps=workInProgress.pendingProps;var oldContext=instance.context;var contextType=ctor.contextType;var nextContext=emptyContextObject;if(typeof contextType==='object'&&contextType!==null){nextContext=readContext(contextType);}else {var nextUnmaskedContext=getUnmaskedContext(workInProgress,ctor,true);nextContext=getMaskedContext(workInProgress,nextUnmaskedContext);}var getDerivedStateFromProps=ctor.getDerivedStateFromProps;var hasNewLifecycles=typeof getDerivedStateFromProps==='function'||typeof instance.getSnapshotBeforeUpdate==='function';// Note: During these life-cycles, instance.props/instance.state are what\n\t// ever the previously attempted to render - not the \"current\". However,\n\t// during componentDidUpdate we pass the \"current\" props.\n\t// In order to support react-lifecycles-compat polyfilled components,\n\t// Unsafe lifecycles should not be invoked for components using the new APIs.\n\tif(!hasNewLifecycles&&(typeof instance.UNSAFE_componentWillReceiveProps==='function'||typeof instance.componentWillReceiveProps==='function')){if(unresolvedOldProps!==unresolvedNewProps||oldContext!==nextContext){callComponentWillReceiveProps(workInProgress,instance,newProps,nextContext);}}resetHasForceUpdateBeforeProcessing();var oldState=workInProgress.memoizedState;var newState=instance.state=oldState;processUpdateQueue(workInProgress,newProps,instance,renderLanes);newState=workInProgress.memoizedState;if(unresolvedOldProps===unresolvedNewProps&&oldState===newState&&!hasContextChanged()&&!checkHasForceUpdateAfterProcessing()&&!enableLazyContextPropagation){// If an update was already in progress, we should schedule an Update\n\t// effect even though we're bailing out, so that cWU/cDU are called.\n\tif(typeof instance.componentDidUpdate==='function'){if(unresolvedOldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.flags|=Update;}}if(typeof instance.getSnapshotBeforeUpdate==='function'){if(unresolvedOldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.flags|=Snapshot;}}return false;}if(typeof getDerivedStateFromProps==='function'){applyDerivedStateFromProps(workInProgress,ctor,getDerivedStateFromProps,newProps);newState=workInProgress.memoizedState;}var shouldUpdate=checkHasForceUpdateAfterProcessing()||checkShouldComponentUpdate(workInProgress,ctor,oldProps,newProps,oldState,newState,nextContext)||// TODO: In some cases, we'll end up checking if context has changed twice,\n\t// both before and after `shouldComponentUpdate` has been called. Not ideal,\n\t// but I'm loath to refactor this function. This only happens for memoized\n\t// components so it's not that common.\n\tenableLazyContextPropagation;if(shouldUpdate){// In order to support react-lifecycles-compat polyfilled components,\n\t// Unsafe lifecycles should not be invoked for components using the new APIs.\n\tif(!hasNewLifecycles&&(typeof instance.UNSAFE_componentWillUpdate==='function'||typeof instance.componentWillUpdate==='function')){if(typeof instance.componentWillUpdate==='function'){instance.componentWillUpdate(newProps,newState,nextContext);}if(typeof instance.UNSAFE_componentWillUpdate==='function'){instance.UNSAFE_componentWillUpdate(newProps,newState,nextContext);}}if(typeof instance.componentDidUpdate==='function'){workInProgress.flags|=Update;}if(typeof instance.getSnapshotBeforeUpdate==='function'){workInProgress.flags|=Snapshot;}}else {// If an update was already in progress, we should schedule an Update\n\t// effect even though we're bailing out, so that cWU/cDU are called.\n\tif(typeof instance.componentDidUpdate==='function'){if(unresolvedOldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.flags|=Update;}}if(typeof instance.getSnapshotBeforeUpdate==='function'){if(unresolvedOldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.flags|=Snapshot;}}// If shouldComponentUpdate returned false, we should still update the\n\t// memoized props/state to indicate that this work can be reused.\n\tworkInProgress.memoizedProps=newProps;workInProgress.memoizedState=newState;}// Update the existing instance's state, props, and context pointers even\n\t// if shouldComponentUpdate returns false.\n\tinstance.props=newProps;instance.state=newState;instance.context=nextContext;return shouldUpdate;}var didWarnAboutMaps;var didWarnAboutGenerators;var didWarnAboutStringRefs;var ownerHasKeyUseWarning;var ownerHasFunctionTypeWarning;var warnForMissingKey=function(child,returnFiber){};{didWarnAboutMaps=false;didWarnAboutGenerators=false;didWarnAboutStringRefs={};/**\n\t   * Warn if there's no key explicitly set on dynamic arrays of children or\n\t   * object keys are not valid. This allows us to keep track of children between\n\t   * updates.\n\t   */ownerHasKeyUseWarning={};ownerHasFunctionTypeWarning={};warnForMissingKey=function(child,returnFiber){if(child===null||typeof child!=='object'){return;}if(!child._store||child._store.validated||child.key!=null){return;}if(typeof child._store!=='object'){throw new Error('React Component in warnForMissingKey should have a _store. '+'This error is likely caused by a bug in React. Please file an issue.');}child._store.validated=true;var componentName=getComponentNameFromFiber(returnFiber)||'Component';if(ownerHasKeyUseWarning[componentName]){return;}ownerHasKeyUseWarning[componentName]=true;error('Each child in a list should have a unique '+'\"key\" prop. See https://reactjs.org/link/warning-keys for '+'more information.');};}function coerceRef(returnFiber,current,element){var mixedRef=element.ref;if(mixedRef!==null&&typeof mixedRef!=='function'&&typeof mixedRef!=='object'){{// TODO: Clean this up once we turn on the string ref warning for\n\t// everyone, because the strict mode case will no longer be relevant\n\tif((returnFiber.mode&StrictLegacyMode||warnAboutStringRefs)&&// We warn in ReactElement.js if owner and self are equal for string refs\n\t// because these cannot be automatically converted to an arrow function\n\t// using a codemod. Therefore, we don't have to warn about string refs again.\n\t!(element._owner&&element._self&&element._owner.stateNode!==element._self)){var componentName=getComponentNameFromFiber(returnFiber)||'Component';if(!didWarnAboutStringRefs[componentName]){{error('A string ref, \"%s\", has been found within a strict mode tree. '+'String refs are a source of potential bugs and should be avoided. '+'We recommend using useRef() or createRef() instead. '+'Learn more about using refs safely here: '+'https://reactjs.org/link/strict-mode-string-ref',mixedRef);}didWarnAboutStringRefs[componentName]=true;}}}if(element._owner){var owner=element._owner;var inst;if(owner){var ownerFiber=owner;if(ownerFiber.tag!==ClassComponent){throw new Error('Function components cannot have string refs. '+'We recommend using useRef() instead. '+'Learn more about using refs safely here: '+'https://reactjs.org/link/strict-mode-string-ref');}inst=ownerFiber.stateNode;}if(!inst){throw new Error(\"Missing owner for string ref \"+mixedRef+\". This error is likely caused by a \"+'bug in React. Please file an issue.');}// Assigning this to a const so Flow knows it won't change in the closure\n\tvar resolvedInst=inst;{checkPropStringCoercion(mixedRef,'ref');}var stringRef=''+mixedRef;// Check if previous string ref matches new string ref\n\tif(current!==null&&current.ref!==null&&typeof current.ref==='function'&&current.ref._stringRef===stringRef){return current.ref;}var ref=function(value){var refs=resolvedInst.refs;if(refs===emptyRefsObject){// This is a lazy pooled frozen object, so we need to initialize.\n\trefs=resolvedInst.refs={};}if(value===null){delete refs[stringRef];}else {refs[stringRef]=value;}};ref._stringRef=stringRef;return ref;}else {if(typeof mixedRef!=='string'){throw new Error('Expected ref to be a function, a string, an object returned by React.createRef(), or null.');}if(!element._owner){throw new Error(\"Element ref was specified as a string (\"+mixedRef+\") but no owner was set. This could happen for one of\"+' the following reasons:\\n'+'1. You may be adding a ref to a function component\\n'+\"2. You may be adding a ref to a component that was not created inside a component's render method\\n\"+'3. You have multiple copies of React loaded\\n'+'See https://reactjs.org/link/refs-must-have-owner for more information.');}}}return mixedRef;}function throwOnInvalidObjectType(returnFiber,newChild){var childString=Object.prototype.toString.call(newChild);throw new Error(\"Objects are not valid as a React child (found: \"+(childString==='[object Object]'?'object with keys {'+Object.keys(newChild).join(', ')+'}':childString)+\"). \"+'If you meant to render a collection of children, use an array '+'instead.');}function warnOnFunctionType(returnFiber){{var componentName=getComponentNameFromFiber(returnFiber)||'Component';if(ownerHasFunctionTypeWarning[componentName]){return;}ownerHasFunctionTypeWarning[componentName]=true;error('Functions are not valid as a React child. This may happen if '+'you return a Component instead of <Component /> from render. '+'Or maybe you meant to call this function rather than return it.');}}function resolveLazy(lazyType){var payload=lazyType._payload;var init=lazyType._init;return init(payload);}// This wrapper function exists because I expect to clone the code in each path\n\t// to be able to optimize each path individually by branching early. This needs\n\t// a compiler or we can do it manually. Helpers that don't need this branching\n\t// live outside of this function.\n\tfunction ChildReconciler(shouldTrackSideEffects){function deleteChild(returnFiber,childToDelete){if(!shouldTrackSideEffects){// Noop.\n\treturn;}var deletions=returnFiber.deletions;if(deletions===null){returnFiber.deletions=[childToDelete];returnFiber.flags|=ChildDeletion;}else {deletions.push(childToDelete);}}function deleteRemainingChildren(returnFiber,currentFirstChild){if(!shouldTrackSideEffects){// Noop.\n\treturn null;}// TODO: For the shouldClone case, this could be micro-optimized a bit by\n\t// assuming that after the first child we've already added everything.\n\tvar childToDelete=currentFirstChild;while(childToDelete!==null){deleteChild(returnFiber,childToDelete);childToDelete=childToDelete.sibling;}return null;}function mapRemainingChildren(returnFiber,currentFirstChild){// Add the remaining children to a temporary map so that we can find them by\n\t// keys quickly. Implicit (null) keys get added to this set with their index\n\t// instead.\n\tvar existingChildren=new Map();var existingChild=currentFirstChild;while(existingChild!==null){if(existingChild.key!==null){existingChildren.set(existingChild.key,existingChild);}else {existingChildren.set(existingChild.index,existingChild);}existingChild=existingChild.sibling;}return existingChildren;}function useFiber(fiber,pendingProps){// We currently set sibling to null and index to 0 here because it is easy\n\t// to forget to do before returning it. E.g. for the single child case.\n\tvar clone=createWorkInProgress(fiber,pendingProps);clone.index=0;clone.sibling=null;return clone;}function placeChild(newFiber,lastPlacedIndex,newIndex){newFiber.index=newIndex;if(!shouldTrackSideEffects){// During hydration, the useId algorithm needs to know which fibers are\n\t// part of a list of children (arrays, iterators).\n\tnewFiber.flags|=Forked;return lastPlacedIndex;}var current=newFiber.alternate;if(current!==null){var oldIndex=current.index;if(oldIndex<lastPlacedIndex){// This is a move.\n\tnewFiber.flags|=Placement;return lastPlacedIndex;}else {// This item can stay in place.\n\treturn oldIndex;}}else {// This is an insertion.\n\tnewFiber.flags|=Placement;return lastPlacedIndex;}}function placeSingleChild(newFiber){// This is simpler for the single child case. We only need to do a\n\t// placement for inserting new children.\n\tif(shouldTrackSideEffects&&newFiber.alternate===null){newFiber.flags|=Placement;}return newFiber;}function updateTextNode(returnFiber,current,textContent,lanes){if(current===null||current.tag!==HostText){// Insert\n\tvar created=createFiberFromText(textContent,returnFiber.mode,lanes);created.return=returnFiber;return created;}else {// Update\n\tvar existing=useFiber(current,textContent);existing.return=returnFiber;return existing;}}function updateElement(returnFiber,current,element,lanes){var elementType=element.type;if(elementType===REACT_FRAGMENT_TYPE){return updateFragment(returnFiber,current,element.props.children,lanes,element.key);}if(current!==null){if(current.elementType===elementType||// Keep this check inline so it only runs on the false path:\n\tisCompatibleFamilyForHotReloading(current,element)||// Lazy types should reconcile their resolved type.\n\t// We need to do this after the Hot Reloading check above,\n\t// because hot reloading has different semantics than prod because\n\t// it doesn't resuspend. So we can't let the call below suspend.\n\ttypeof elementType==='object'&&elementType!==null&&elementType.$$typeof===REACT_LAZY_TYPE&&resolveLazy(elementType)===current.type){// Move based on index\n\tvar existing=useFiber(current,element.props);existing.ref=coerceRef(returnFiber,current,element);existing.return=returnFiber;{existing._debugSource=element._source;existing._debugOwner=element._owner;}return existing;}}// Insert\n\tvar created=createFiberFromElement(element,returnFiber.mode,lanes);created.ref=coerceRef(returnFiber,current,element);created.return=returnFiber;return created;}function updatePortal(returnFiber,current,portal,lanes){if(current===null||current.tag!==HostPortal||current.stateNode.containerInfo!==portal.containerInfo||current.stateNode.implementation!==portal.implementation){// Insert\n\tvar created=createFiberFromPortal(portal,returnFiber.mode,lanes);created.return=returnFiber;return created;}else {// Update\n\tvar existing=useFiber(current,portal.children||[]);existing.return=returnFiber;return existing;}}function updateFragment(returnFiber,current,fragment,lanes,key){if(current===null||current.tag!==Fragment){// Insert\n\tvar created=createFiberFromFragment(fragment,returnFiber.mode,lanes,key);created.return=returnFiber;return created;}else {// Update\n\tvar existing=useFiber(current,fragment);existing.return=returnFiber;return existing;}}function createChild(returnFiber,newChild,lanes){if(typeof newChild==='string'&&newChild!==''||typeof newChild==='number'){// Text nodes don't have keys. If the previous node is implicitly keyed\n\t// we can continue to replace it without aborting even if it is not a text\n\t// node.\n\tvar created=createFiberFromText(''+newChild,returnFiber.mode,lanes);created.return=returnFiber;return created;}if(typeof newChild==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:{var _created=createFiberFromElement(newChild,returnFiber.mode,lanes);_created.ref=coerceRef(returnFiber,null,newChild);_created.return=returnFiber;return _created;}case REACT_PORTAL_TYPE:{var _created2=createFiberFromPortal(newChild,returnFiber.mode,lanes);_created2.return=returnFiber;return _created2;}case REACT_LAZY_TYPE:{var payload=newChild._payload;var init=newChild._init;return createChild(returnFiber,init(payload),lanes);}}if(isArray(newChild)||getIteratorFn(newChild)){var _created3=createFiberFromFragment(newChild,returnFiber.mode,lanes,null);_created3.return=returnFiber;return _created3;}throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType(returnFiber);}}return null;}function updateSlot(returnFiber,oldFiber,newChild,lanes){// Update the fiber if the keys match, otherwise return null.\n\tvar key=oldFiber!==null?oldFiber.key:null;if(typeof newChild==='string'&&newChild!==''||typeof newChild==='number'){// Text nodes don't have keys. If the previous node is implicitly keyed\n\t// we can continue to replace it without aborting even if it is not a text\n\t// node.\n\tif(key!==null){return null;}return updateTextNode(returnFiber,oldFiber,''+newChild,lanes);}if(typeof newChild==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:{if(newChild.key===key){return updateElement(returnFiber,oldFiber,newChild,lanes);}else {return null;}}case REACT_PORTAL_TYPE:{if(newChild.key===key){return updatePortal(returnFiber,oldFiber,newChild,lanes);}else {return null;}}case REACT_LAZY_TYPE:{var payload=newChild._payload;var init=newChild._init;return updateSlot(returnFiber,oldFiber,init(payload),lanes);}}if(isArray(newChild)||getIteratorFn(newChild)){if(key!==null){return null;}return updateFragment(returnFiber,oldFiber,newChild,lanes,null);}throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType(returnFiber);}}return null;}function updateFromMap(existingChildren,returnFiber,newIdx,newChild,lanes){if(typeof newChild==='string'&&newChild!==''||typeof newChild==='number'){// Text nodes don't have keys, so we neither have to check the old nor\n\t// new node for the key. If both are text nodes, they match.\n\tvar matchedFiber=existingChildren.get(newIdx)||null;return updateTextNode(returnFiber,matchedFiber,''+newChild,lanes);}if(typeof newChild==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:{var _matchedFiber=existingChildren.get(newChild.key===null?newIdx:newChild.key)||null;return updateElement(returnFiber,_matchedFiber,newChild,lanes);}case REACT_PORTAL_TYPE:{var _matchedFiber2=existingChildren.get(newChild.key===null?newIdx:newChild.key)||null;return updatePortal(returnFiber,_matchedFiber2,newChild,lanes);}case REACT_LAZY_TYPE:var payload=newChild._payload;var init=newChild._init;return updateFromMap(existingChildren,returnFiber,newIdx,init(payload),lanes);}if(isArray(newChild)||getIteratorFn(newChild)){var _matchedFiber3=existingChildren.get(newIdx)||null;return updateFragment(returnFiber,_matchedFiber3,newChild,lanes,null);}throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType(returnFiber);}}return null;}/**\n\t   * Warns if there is a duplicate or missing key\n\t   */function warnOnInvalidKey(child,knownKeys,returnFiber){{if(typeof child!=='object'||child===null){return knownKeys;}switch(child.$$typeof){case REACT_ELEMENT_TYPE:case REACT_PORTAL_TYPE:warnForMissingKey(child,returnFiber);var key=child.key;if(typeof key!=='string'){break;}if(knownKeys===null){knownKeys=new Set();knownKeys.add(key);break;}if(!knownKeys.has(key)){knownKeys.add(key);break;}error('Encountered two children with the same key, `%s`. '+'Keys should be unique so that components maintain their identity '+'across updates. Non-unique keys may cause children to be '+'duplicated and/or omitted — the behavior is unsupported and '+'could change in a future version.',key);break;case REACT_LAZY_TYPE:var payload=child._payload;var init=child._init;warnOnInvalidKey(init(payload),knownKeys,returnFiber);break;}}return knownKeys;}function reconcileChildrenArray(returnFiber,currentFirstChild,newChildren,lanes){// This algorithm can't optimize by searching from both ends since we\n\t// don't have backpointers on fibers. I'm trying to see how far we can get\n\t// with that model. If it ends up not being worth the tradeoffs, we can\n\t// add it later.\n\t// Even with a two ended optimization, we'd want to optimize for the case\n\t// where there are few changes and brute force the comparison instead of\n\t// going for the Map. It'd like to explore hitting that path first in\n\t// forward-only mode and only go for the Map once we notice that we need\n\t// lots of look ahead. This doesn't handle reversal as well as two ended\n\t// search but that's unusual. Besides, for the two ended optimization to\n\t// work on Iterables, we'd need to copy the whole set.\n\t// In this first iteration, we'll just live with hitting the bad case\n\t// (adding everything to a Map) in for every insert/move.\n\t// If you change this code, also update reconcileChildrenIterator() which\n\t// uses the same algorithm.\n\t{// First, validate keys.\n\tvar knownKeys=null;for(var i=0;i<newChildren.length;i++){var child=newChildren[i];knownKeys=warnOnInvalidKey(child,knownKeys,returnFiber);}}var resultingFirstChild=null;var previousNewFiber=null;var oldFiber=currentFirstChild;var lastPlacedIndex=0;var newIdx=0;var nextOldFiber=null;for(;oldFiber!==null&&newIdx<newChildren.length;newIdx++){if(oldFiber.index>newIdx){nextOldFiber=oldFiber;oldFiber=null;}else {nextOldFiber=oldFiber.sibling;}var newFiber=updateSlot(returnFiber,oldFiber,newChildren[newIdx],lanes);if(newFiber===null){// TODO: This breaks on empty slots like null children. That's\n\t// unfortunate because it triggers the slow path all the time. We need\n\t// a better way to communicate whether this was a miss or null,\n\t// boolean, undefined, etc.\n\tif(oldFiber===null){oldFiber=nextOldFiber;}break;}if(shouldTrackSideEffects){if(oldFiber&&newFiber.alternate===null){// We matched the slot, but we didn't reuse the existing fiber, so we\n\t// need to delete the existing child.\n\tdeleteChild(returnFiber,oldFiber);}}lastPlacedIndex=placeChild(newFiber,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.\n\tresultingFirstChild=newFiber;}else {// TODO: Defer siblings if we're not at the right index for this slot.\n\t// I.e. if we had null values before, then we want to defer this\n\t// for each null value. However, we also don't want to call updateSlot\n\t// with the previous one.\n\tpreviousNewFiber.sibling=newFiber;}previousNewFiber=newFiber;oldFiber=nextOldFiber;}if(newIdx===newChildren.length){// We've reached the end of the new children. We can delete the rest.\n\tdeleteRemainingChildren(returnFiber,oldFiber);if(getIsHydrating()){var numberOfForks=newIdx;pushTreeFork(returnFiber,numberOfForks);}return resultingFirstChild;}if(oldFiber===null){// If we don't have any more existing children we can choose a fast path\n\t// since the rest will all be insertions.\n\tfor(;newIdx<newChildren.length;newIdx++){var _newFiber=createChild(returnFiber,newChildren[newIdx],lanes);if(_newFiber===null){continue;}lastPlacedIndex=placeChild(_newFiber,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.\n\tresultingFirstChild=_newFiber;}else {previousNewFiber.sibling=_newFiber;}previousNewFiber=_newFiber;}if(getIsHydrating()){var _numberOfForks=newIdx;pushTreeFork(returnFiber,_numberOfForks);}return resultingFirstChild;}// Add all children to a key map for quick lookups.\n\tvar existingChildren=mapRemainingChildren(returnFiber,oldFiber);// Keep scanning and use the map to restore deleted items as moves.\n\tfor(;newIdx<newChildren.length;newIdx++){var _newFiber2=updateFromMap(existingChildren,returnFiber,newIdx,newChildren[newIdx],lanes);if(_newFiber2!==null){if(shouldTrackSideEffects){if(_newFiber2.alternate!==null){// The new fiber is a work in progress, but if there exists a\n\t// current, that means that we reused the fiber. We need to delete\n\t// it from the child list so that we don't add it to the deletion\n\t// list.\n\texistingChildren.delete(_newFiber2.key===null?newIdx:_newFiber2.key);}}lastPlacedIndex=placeChild(_newFiber2,lastPlacedIndex,newIdx);if(previousNewFiber===null){resultingFirstChild=_newFiber2;}else {previousNewFiber.sibling=_newFiber2;}previousNewFiber=_newFiber2;}}if(shouldTrackSideEffects){// Any existing children that weren't consumed above were deleted. We need\n\t// to add them to the deletion list.\n\texistingChildren.forEach(function(child){return deleteChild(returnFiber,child);});}if(getIsHydrating()){var _numberOfForks2=newIdx;pushTreeFork(returnFiber,_numberOfForks2);}return resultingFirstChild;}function reconcileChildrenIterator(returnFiber,currentFirstChild,newChildrenIterable,lanes){// This is the same implementation as reconcileChildrenArray(),\n\t// but using the iterator instead.\n\tvar iteratorFn=getIteratorFn(newChildrenIterable);if(typeof iteratorFn!=='function'){throw new Error('An object is not an iterable. This error is likely caused by a bug in '+'React. Please file an issue.');}{// We don't support rendering Generators because it's a mutation.\n\t// See https://github.com/facebook/react/issues/12995\n\tif(typeof Symbol==='function'&&// $FlowFixMe Flow doesn't know about toStringTag\n\tnewChildrenIterable[Symbol.toStringTag]==='Generator'){if(!didWarnAboutGenerators){error('Using Generators as children is unsupported and will likely yield '+'unexpected results because enumerating a generator mutates it. '+'You may convert it to an array with `Array.from()` or the '+'`[...spread]` operator before rendering. Keep in mind '+'you might need to polyfill these features for older browsers.');}didWarnAboutGenerators=true;}// Warn about using Maps as children\n\tif(newChildrenIterable.entries===iteratorFn){if(!didWarnAboutMaps){error('Using Maps as children is not supported. '+'Use an array of keyed ReactElements instead.');}didWarnAboutMaps=true;}// First, validate keys.\n\t// We'll get a different iterator later for the main pass.\n\tvar _newChildren=iteratorFn.call(newChildrenIterable);if(_newChildren){var knownKeys=null;var _step=_newChildren.next();for(;!_step.done;_step=_newChildren.next()){var child=_step.value;knownKeys=warnOnInvalidKey(child,knownKeys,returnFiber);}}}var newChildren=iteratorFn.call(newChildrenIterable);if(newChildren==null){throw new Error('An iterable object provided no iterator.');}var resultingFirstChild=null;var previousNewFiber=null;var oldFiber=currentFirstChild;var lastPlacedIndex=0;var newIdx=0;var nextOldFiber=null;var step=newChildren.next();for(;oldFiber!==null&&!step.done;newIdx++,step=newChildren.next()){if(oldFiber.index>newIdx){nextOldFiber=oldFiber;oldFiber=null;}else {nextOldFiber=oldFiber.sibling;}var newFiber=updateSlot(returnFiber,oldFiber,step.value,lanes);if(newFiber===null){// TODO: This breaks on empty slots like null children. That's\n\t// unfortunate because it triggers the slow path all the time. We need\n\t// a better way to communicate whether this was a miss or null,\n\t// boolean, undefined, etc.\n\tif(oldFiber===null){oldFiber=nextOldFiber;}break;}if(shouldTrackSideEffects){if(oldFiber&&newFiber.alternate===null){// We matched the slot, but we didn't reuse the existing fiber, so we\n\t// need to delete the existing child.\n\tdeleteChild(returnFiber,oldFiber);}}lastPlacedIndex=placeChild(newFiber,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.\n\tresultingFirstChild=newFiber;}else {// TODO: Defer siblings if we're not at the right index for this slot.\n\t// I.e. if we had null values before, then we want to defer this\n\t// for each null value. However, we also don't want to call updateSlot\n\t// with the previous one.\n\tpreviousNewFiber.sibling=newFiber;}previousNewFiber=newFiber;oldFiber=nextOldFiber;}if(step.done){// We've reached the end of the new children. We can delete the rest.\n\tdeleteRemainingChildren(returnFiber,oldFiber);if(getIsHydrating()){var numberOfForks=newIdx;pushTreeFork(returnFiber,numberOfForks);}return resultingFirstChild;}if(oldFiber===null){// If we don't have any more existing children we can choose a fast path\n\t// since the rest will all be insertions.\n\tfor(;!step.done;newIdx++,step=newChildren.next()){var _newFiber3=createChild(returnFiber,step.value,lanes);if(_newFiber3===null){continue;}lastPlacedIndex=placeChild(_newFiber3,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.\n\tresultingFirstChild=_newFiber3;}else {previousNewFiber.sibling=_newFiber3;}previousNewFiber=_newFiber3;}if(getIsHydrating()){var _numberOfForks3=newIdx;pushTreeFork(returnFiber,_numberOfForks3);}return resultingFirstChild;}// Add all children to a key map for quick lookups.\n\tvar existingChildren=mapRemainingChildren(returnFiber,oldFiber);// Keep scanning and use the map to restore deleted items as moves.\n\tfor(;!step.done;newIdx++,step=newChildren.next()){var _newFiber4=updateFromMap(existingChildren,returnFiber,newIdx,step.value,lanes);if(_newFiber4!==null){if(shouldTrackSideEffects){if(_newFiber4.alternate!==null){// The new fiber is a work in progress, but if there exists a\n\t// current, that means that we reused the fiber. We need to delete\n\t// it from the child list so that we don't add it to the deletion\n\t// list.\n\texistingChildren.delete(_newFiber4.key===null?newIdx:_newFiber4.key);}}lastPlacedIndex=placeChild(_newFiber4,lastPlacedIndex,newIdx);if(previousNewFiber===null){resultingFirstChild=_newFiber4;}else {previousNewFiber.sibling=_newFiber4;}previousNewFiber=_newFiber4;}}if(shouldTrackSideEffects){// Any existing children that weren't consumed above were deleted. We need\n\t// to add them to the deletion list.\n\texistingChildren.forEach(function(child){return deleteChild(returnFiber,child);});}if(getIsHydrating()){var _numberOfForks4=newIdx;pushTreeFork(returnFiber,_numberOfForks4);}return resultingFirstChild;}function reconcileSingleTextNode(returnFiber,currentFirstChild,textContent,lanes){// There's no need to check for keys on text nodes since we don't have a\n\t// way to define them.\n\tif(currentFirstChild!==null&&currentFirstChild.tag===HostText){// We already have an existing node so let's just update it and delete\n\t// the rest.\n\tdeleteRemainingChildren(returnFiber,currentFirstChild.sibling);var existing=useFiber(currentFirstChild,textContent);existing.return=returnFiber;return existing;}// The existing first child is not a text node so we need to create one\n\t// and delete the existing ones.\n\tdeleteRemainingChildren(returnFiber,currentFirstChild);var created=createFiberFromText(textContent,returnFiber.mode,lanes);created.return=returnFiber;return created;}function reconcileSingleElement(returnFiber,currentFirstChild,element,lanes){var key=element.key;var child=currentFirstChild;while(child!==null){// TODO: If key === null and child.key === null, then this only applies to\n\t// the first item in the list.\n\tif(child.key===key){var elementType=element.type;if(elementType===REACT_FRAGMENT_TYPE){if(child.tag===Fragment){deleteRemainingChildren(returnFiber,child.sibling);var existing=useFiber(child,element.props.children);existing.return=returnFiber;{existing._debugSource=element._source;existing._debugOwner=element._owner;}return existing;}}else {if(child.elementType===elementType||// Keep this check inline so it only runs on the false path:\n\tisCompatibleFamilyForHotReloading(child,element)||// Lazy types should reconcile their resolved type.\n\t// We need to do this after the Hot Reloading check above,\n\t// because hot reloading has different semantics than prod because\n\t// it doesn't resuspend. So we can't let the call below suspend.\n\ttypeof elementType==='object'&&elementType!==null&&elementType.$$typeof===REACT_LAZY_TYPE&&resolveLazy(elementType)===child.type){deleteRemainingChildren(returnFiber,child.sibling);var _existing=useFiber(child,element.props);_existing.ref=coerceRef(returnFiber,child,element);_existing.return=returnFiber;{_existing._debugSource=element._source;_existing._debugOwner=element._owner;}return _existing;}}// Didn't match.\n\tdeleteRemainingChildren(returnFiber,child);break;}else {deleteChild(returnFiber,child);}child=child.sibling;}if(element.type===REACT_FRAGMENT_TYPE){var created=createFiberFromFragment(element.props.children,returnFiber.mode,lanes,element.key);created.return=returnFiber;return created;}else {var _created4=createFiberFromElement(element,returnFiber.mode,lanes);_created4.ref=coerceRef(returnFiber,currentFirstChild,element);_created4.return=returnFiber;return _created4;}}function reconcileSinglePortal(returnFiber,currentFirstChild,portal,lanes){var key=portal.key;var child=currentFirstChild;while(child!==null){// TODO: If key === null and child.key === null, then this only applies to\n\t// the first item in the list.\n\tif(child.key===key){if(child.tag===HostPortal&&child.stateNode.containerInfo===portal.containerInfo&&child.stateNode.implementation===portal.implementation){deleteRemainingChildren(returnFiber,child.sibling);var existing=useFiber(child,portal.children||[]);existing.return=returnFiber;return existing;}else {deleteRemainingChildren(returnFiber,child);break;}}else {deleteChild(returnFiber,child);}child=child.sibling;}var created=createFiberFromPortal(portal,returnFiber.mode,lanes);created.return=returnFiber;return created;}// This API will tag the children with the side-effect of the reconciliation\n\t// itself. They will be added to the side-effect list as we pass through the\n\t// children and the parent.\n\tfunction reconcileChildFibers(returnFiber,currentFirstChild,newChild,lanes){// This function is not recursive.\n\t// If the top level item is an array, we treat it as a set of children,\n\t// not as a fragment. Nested arrays on the other hand will be treated as\n\t// fragment nodes. Recursion happens at the normal flow.\n\t// Handle top level unkeyed fragments as if they were arrays.\n\t// This leads to an ambiguity between <>{[...]}</> and <>...</>.\n\t// We treat the ambiguous cases above the same.\n\tvar isUnkeyedTopLevelFragment=typeof newChild==='object'&&newChild!==null&&newChild.type===REACT_FRAGMENT_TYPE&&newChild.key===null;if(isUnkeyedTopLevelFragment){newChild=newChild.props.children;}// Handle object types\n\tif(typeof newChild==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:return placeSingleChild(reconcileSingleElement(returnFiber,currentFirstChild,newChild,lanes));case REACT_PORTAL_TYPE:return placeSingleChild(reconcileSinglePortal(returnFiber,currentFirstChild,newChild,lanes));case REACT_LAZY_TYPE:var payload=newChild._payload;var init=newChild._init;// TODO: This function is supposed to be non-recursive.\n\treturn reconcileChildFibers(returnFiber,currentFirstChild,init(payload),lanes);}if(isArray(newChild)){return reconcileChildrenArray(returnFiber,currentFirstChild,newChild,lanes);}if(getIteratorFn(newChild)){return reconcileChildrenIterator(returnFiber,currentFirstChild,newChild,lanes);}throwOnInvalidObjectType(returnFiber,newChild);}if(typeof newChild==='string'&&newChild!==''||typeof newChild==='number'){return placeSingleChild(reconcileSingleTextNode(returnFiber,currentFirstChild,''+newChild,lanes));}{if(typeof newChild==='function'){warnOnFunctionType(returnFiber);}}// Remaining cases are all treated as empty.\n\treturn deleteRemainingChildren(returnFiber,currentFirstChild);}return reconcileChildFibers;}var reconcileChildFibers=ChildReconciler(true);var mountChildFibers=ChildReconciler(false);function cloneChildFibers(current,workInProgress){if(current!==null&&workInProgress.child!==current.child){throw new Error('Resuming work not yet implemented.');}if(workInProgress.child===null){return;}var currentChild=workInProgress.child;var newChild=createWorkInProgress(currentChild,currentChild.pendingProps);workInProgress.child=newChild;newChild.return=workInProgress;while(currentChild.sibling!==null){currentChild=currentChild.sibling;newChild=newChild.sibling=createWorkInProgress(currentChild,currentChild.pendingProps);newChild.return=workInProgress;}newChild.sibling=null;}// Reset a workInProgress child set to prepare it for a second pass.\n\tfunction resetChildFibers(workInProgress,lanes){var child=workInProgress.child;while(child!==null){resetWorkInProgress(child,lanes);child=child.sibling;}}var NO_CONTEXT={};var contextStackCursor$1=createCursor(NO_CONTEXT);var contextFiberStackCursor=createCursor(NO_CONTEXT);var rootInstanceStackCursor=createCursor(NO_CONTEXT);function requiredContext(c){if(c===NO_CONTEXT){throw new Error('Expected host context to exist. This error is likely caused by a bug '+'in React. Please file an issue.');}return c;}function getRootHostContainer(){var rootInstance=requiredContext(rootInstanceStackCursor.current);return rootInstance;}function pushHostContainer(fiber,nextRootInstance){// Push current root instance onto the stack;\n\t// This allows us to reset root when portals are popped.\n\tpush(rootInstanceStackCursor,nextRootInstance,fiber);// Track the context and the Fiber that provided it.\n\t// This enables us to pop only Fibers that provide unique contexts.\n\tpush(contextFiberStackCursor,fiber,fiber);// Finally, we need to push the host context to the stack.\n\t// However, we can't just call getRootHostContext() and push it because\n\t// we'd have a different number of entries on the stack depending on\n\t// whether getRootHostContext() throws somewhere in renderer code or not.\n\t// So we push an empty value first. This lets us safely unwind on errors.\n\tpush(contextStackCursor$1,NO_CONTEXT,fiber);var nextRootContext=getRootHostContext(nextRootInstance);// Now that we know this function doesn't throw, replace it.\n\tpop(contextStackCursor$1,fiber);push(contextStackCursor$1,nextRootContext,fiber);}function popHostContainer(fiber){pop(contextStackCursor$1,fiber);pop(contextFiberStackCursor,fiber);pop(rootInstanceStackCursor,fiber);}function getHostContext(){var context=requiredContext(contextStackCursor$1.current);return context;}function pushHostContext(fiber){requiredContext(rootInstanceStackCursor.current);var context=requiredContext(contextStackCursor$1.current);var nextContext=getChildHostContext(context,fiber.type);// Don't push this Fiber's context unless it's unique.\n\tif(context===nextContext){return;}// Track the context and the Fiber that provided it.\n\t// This enables us to pop only Fibers that provide unique contexts.\n\tpush(contextFiberStackCursor,fiber,fiber);push(contextStackCursor$1,nextContext,fiber);}function popHostContext(fiber){// Do not pop unless this Fiber provided the current context.\n\t// pushHostContext() only pushes Fibers that provide unique contexts.\n\tif(contextFiberStackCursor.current!==fiber){return;}pop(contextStackCursor$1,fiber);pop(contextFiberStackCursor,fiber);}var DefaultSuspenseContext=0;// The Suspense Context is split into two parts. The lower bits is\n\t// inherited deeply down the subtree. The upper bits only affect\n\t// this immediate suspense boundary and gets reset each new\n\t// boundary or suspense list.\n\tvar SubtreeSuspenseContextMask=1;// Subtree Flags:\n\t// InvisibleParentSuspenseContext indicates that one of our parent Suspense\n\t// boundaries is not currently showing visible main content.\n\t// Either because it is already showing a fallback or is not mounted at all.\n\t// We can use this to determine if it is desirable to trigger a fallback at\n\t// the parent. If not, then we might need to trigger undesirable boundaries\n\t// and/or suspend the commit to avoid hiding the parent content.\n\tvar InvisibleParentSuspenseContext=1;// Shallow Flags:\n\t// ForceSuspenseFallback can be used by SuspenseList to force newly added\n\t// items into their fallback state during one of the render passes.\n\tvar ForceSuspenseFallback=2;var suspenseStackCursor=createCursor(DefaultSuspenseContext);function hasSuspenseContext(parentContext,flag){return (parentContext&flag)!==0;}function setDefaultShallowSuspenseContext(parentContext){return parentContext&SubtreeSuspenseContextMask;}function setShallowSuspenseContext(parentContext,shallowContext){return parentContext&SubtreeSuspenseContextMask|shallowContext;}function addSubtreeSuspenseContext(parentContext,subtreeContext){return parentContext|subtreeContext;}function pushSuspenseContext(fiber,newContext){push(suspenseStackCursor,newContext,fiber);}function popSuspenseContext(fiber){pop(suspenseStackCursor,fiber);}function shouldCaptureSuspense(workInProgress,hasInvisibleParent){// If it was the primary children that just suspended, capture and render the\n\t// fallback. Otherwise, don't capture and bubble to the next boundary.\n\tvar nextState=workInProgress.memoizedState;if(nextState!==null){if(nextState.dehydrated!==null){// A dehydrated boundary always captures.\n\treturn true;}return false;}workInProgress.memoizedProps;// Regular boundaries always capture.\n\t{return true;}// If it's a boundary we should avoid, then we prefer to bubble up to the\n\t}function findFirstSuspended(row){var node=row;while(node!==null){if(node.tag===SuspenseComponent){var state=node.memoizedState;if(state!==null){var dehydrated=state.dehydrated;if(dehydrated===null||isSuspenseInstancePending(dehydrated)||isSuspenseInstanceFallback(dehydrated)){return node;}}}else if(node.tag===SuspenseListComponent&&// revealOrder undefined can't be trusted because it don't\n\t// keep track of whether it suspended or not.\n\tnode.memoizedProps.revealOrder!==undefined){var didSuspend=(node.flags&DidCapture)!==NoFlags;if(didSuspend){return node;}}else if(node.child!==null){node.child.return=node;node=node.child;continue;}if(node===row){return null;}while(node.sibling===null){if(node.return===null||node.return===row){return null;}node=node.return;}node.sibling.return=node.return;node=node.sibling;}return null;}var NoFlags$1=/*   */0;// Represents whether effect should fire.\n\tvar HasEffect=/* */1;// Represents the phase in which the effect (not the clean-up) fires.\n\tvar Insertion=/*  */2;var Layout=/*    */4;var Passive$1=/*   */8;// and should be reset before starting a new render.\n\t// This tracks which mutable sources need to be reset after a render.\n\tvar workInProgressSources=[];function resetWorkInProgressVersions(){for(var i=0;i<workInProgressSources.length;i++){var mutableSource=workInProgressSources[i];{mutableSource._workInProgressVersionPrimary=null;}}workInProgressSources.length=0;}// This ensures that the version used for server rendering matches the one\n\t// that is eventually read during hydration.\n\t// If they don't match there's a potential tear and a full deopt render is required.\n\tfunction registerMutableSourceForHydration(root,mutableSource){var getVersion=mutableSource._getVersion;var version=getVersion(mutableSource._source);// TODO Clear this data once all pending hydration work is finished.\n\t// Retaining it forever may interfere with GC.\n\tif(root.mutableSourceEagerHydrationData==null){root.mutableSourceEagerHydrationData=[mutableSource,version];}else {root.mutableSourceEagerHydrationData.push(mutableSource,version);}}var ReactCurrentDispatcher$1=ReactSharedInternals.ReactCurrentDispatcher,ReactCurrentBatchConfig$2=ReactSharedInternals.ReactCurrentBatchConfig;var didWarnAboutMismatchedHooksForComponent;var didWarnUncachedGetSnapshot;{didWarnAboutMismatchedHooksForComponent=new Set();}// These are set right before calling the component.\n\tvar renderLanes=NoLanes;// The work-in-progress fiber. I've named it differently to distinguish it from\n\t// the work-in-progress hook.\n\tvar currentlyRenderingFiber$1=null;// Hooks are stored as a linked list on the fiber's memoizedState field. The\n\t// current hook list is the list that belongs to the current fiber. The\n\t// work-in-progress hook list is a new list that will be added to the\n\t// work-in-progress fiber.\n\tvar currentHook=null;var workInProgressHook=null;// Whether an update was scheduled at any point during the render phase. This\n\t// does not get reset if we do another render pass; only when we're completely\n\t// finished evaluating this component. This is an optimization so we know\n\t// whether we need to clear render phase updates after a throw.\n\tvar didScheduleRenderPhaseUpdate=false;// Where an update was scheduled only during the current render pass. This\n\t// gets reset after each attempt.\n\t// TODO: Maybe there's some way to consolidate this with\n\t// `didScheduleRenderPhaseUpdate`. Or with `numberOfReRenders`.\n\tvar didScheduleRenderPhaseUpdateDuringThisPass=false;// Counts the number of useId hooks in this component.\n\tvar localIdCounter=0;// Used for ids that are generated completely client-side (i.e. not during\n\t// hydration). This counter is global, so client ids are not stable across\n\t// render attempts.\n\tvar globalClientIdCounter=0;var RE_RENDER_LIMIT=25;// In DEV, this is the name of the currently executing primitive hook\n\tvar currentHookNameInDev=null;// In DEV, this list ensures that hooks are called in the same order between renders.\n\t// The list stores the order of hooks used during the initial render (mount).\n\t// Subsequent renders (updates) reference this list.\n\tvar hookTypesDev=null;var hookTypesUpdateIndexDev=-1;// In DEV, this tracks whether currently rendering component needs to ignore\n\t// the dependencies for Hooks that need them (e.g. useEffect or useMemo).\n\t// When true, such Hooks will always be \"remounted\". Only used during hot reload.\n\tvar ignorePreviousDependencies=false;function mountHookTypesDev(){{var hookName=currentHookNameInDev;if(hookTypesDev===null){hookTypesDev=[hookName];}else {hookTypesDev.push(hookName);}}}function updateHookTypesDev(){{var hookName=currentHookNameInDev;if(hookTypesDev!==null){hookTypesUpdateIndexDev++;if(hookTypesDev[hookTypesUpdateIndexDev]!==hookName){warnOnHookMismatchInDev(hookName);}}}}function checkDepsAreArrayDev(deps){{if(deps!==undefined&&deps!==null&&!isArray(deps)){// Verify deps, but only on mount to avoid extra checks.\n\t// It's unlikely their type would change as usually you define them inline.\n\terror('%s received a final argument that is not an array (instead, received `%s`). When '+'specified, the final argument must be an array.',currentHookNameInDev,typeof deps);}}}function warnOnHookMismatchInDev(currentHookName){{var componentName=getComponentNameFromFiber(currentlyRenderingFiber$1);if(!didWarnAboutMismatchedHooksForComponent.has(componentName)){didWarnAboutMismatchedHooksForComponent.add(componentName);if(hookTypesDev!==null){var table='';var secondColumnStart=30;for(var i=0;i<=hookTypesUpdateIndexDev;i++){var oldHookName=hookTypesDev[i];var newHookName=i===hookTypesUpdateIndexDev?currentHookName:oldHookName;var row=i+1+\". \"+oldHookName;// Extra space so second column lines up\n\t// lol @ IE not supporting String#repeat\n\twhile(row.length<secondColumnStart){row+=' ';}row+=newHookName+'\\n';table+=row;}error('React has detected a change in the order of Hooks called by %s. '+'This will lead to bugs and errors if not fixed. '+'For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\\n\\n'+'   Previous render            Next render\\n'+'   ------------------------------------------------------\\n'+'%s'+'   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n',componentName,table);}}}}function throwInvalidHookError(){throw new Error('Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for'+' one of the following reasons:\\n'+'1. You might have mismatching versions of React and the renderer (such as React DOM)\\n'+'2. You might be breaking the Rules of Hooks\\n'+'3. You might have more than one copy of React in the same app\\n'+'See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.');}function areHookInputsEqual(nextDeps,prevDeps){{if(ignorePreviousDependencies){// Only true when this component is being hot reloaded.\n\treturn false;}}if(prevDeps===null){{error('%s received a final argument during this render, but not during '+'the previous render. Even though the final argument is optional, '+'its type cannot change between renders.',currentHookNameInDev);}return false;}{// Don't bother comparing lengths in prod because these arrays should be\n\t// passed inline.\n\tif(nextDeps.length!==prevDeps.length){error('The final argument passed to %s changed size between renders. The '+'order and size of this array must remain constant.\\n\\n'+'Previous: %s\\n'+'Incoming: %s',currentHookNameInDev,\"[\"+prevDeps.join(', ')+\"]\",\"[\"+nextDeps.join(', ')+\"]\");}}for(var i=0;i<prevDeps.length&&i<nextDeps.length;i++){if(objectIs(nextDeps[i],prevDeps[i])){continue;}return false;}return true;}function renderWithHooks(current,workInProgress,Component,props,secondArg,nextRenderLanes){renderLanes=nextRenderLanes;currentlyRenderingFiber$1=workInProgress;{hookTypesDev=current!==null?current._debugHookTypes:null;hookTypesUpdateIndexDev=-1;// Used for hot reloading:\n\tignorePreviousDependencies=current!==null&&current.type!==workInProgress.type;}workInProgress.memoizedState=null;workInProgress.updateQueue=null;workInProgress.lanes=NoLanes;// The following should have already been reset\n\t// currentHook = null;\n\t// workInProgressHook = null;\n\t// didScheduleRenderPhaseUpdate = false;\n\t// localIdCounter = 0;\n\t// TODO Warn if no hooks are used at all during mount, then some are used during update.\n\t// Currently we will identify the update render as a mount because memoizedState === null.\n\t// This is tricky because it's valid for certain types of components (e.g. React.lazy)\n\t// Using memoizedState to differentiate between mount/update only works if at least one stateful hook is used.\n\t// Non-stateful hooks (e.g. context) don't get added to memoizedState,\n\t// so memoizedState would be null during updates and mounts.\n\t{if(current!==null&&current.memoizedState!==null){ReactCurrentDispatcher$1.current=HooksDispatcherOnUpdateInDEV;}else if(hookTypesDev!==null){// This dispatcher handles an edge case where a component is updating,\n\t// but no stateful hooks have been used.\n\t// We want to match the production code behavior (which will use HooksDispatcherOnMount),\n\t// but with the extra DEV validation to ensure hooks ordering hasn't changed.\n\t// This dispatcher does that.\n\tReactCurrentDispatcher$1.current=HooksDispatcherOnMountWithHookTypesInDEV;}else {ReactCurrentDispatcher$1.current=HooksDispatcherOnMountInDEV;}}var children=Component(props,secondArg);// Check if there was a render phase update\n\tif(didScheduleRenderPhaseUpdateDuringThisPass){// Keep rendering in a loop for as long as render phase updates continue to\n\t// be scheduled. Use a counter to prevent infinite loops.\n\tvar numberOfReRenders=0;do{didScheduleRenderPhaseUpdateDuringThisPass=false;localIdCounter=0;if(numberOfReRenders>=RE_RENDER_LIMIT){throw new Error('Too many re-renders. React limits the number of renders to prevent '+'an infinite loop.');}numberOfReRenders+=1;{// Even when hot reloading, allow dependencies to stabilize\n\t// after first render to prevent infinite render phase updates.\n\tignorePreviousDependencies=false;}// Start over from the beginning of the list\n\tcurrentHook=null;workInProgressHook=null;workInProgress.updateQueue=null;{// Also validate hook order for cascading updates.\n\thookTypesUpdateIndexDev=-1;}ReactCurrentDispatcher$1.current=HooksDispatcherOnRerenderInDEV;children=Component(props,secondArg);}while(didScheduleRenderPhaseUpdateDuringThisPass);}// We can assume the previous dispatcher is always this one, since we set it\n\t// at the beginning of the render phase and there's no re-entrance.\n\tReactCurrentDispatcher$1.current=ContextOnlyDispatcher;{workInProgress._debugHookTypes=hookTypesDev;}// This check uses currentHook so that it works the same in DEV and prod bundles.\n\t// hookTypesDev could catch more cases (e.g. context) but only in DEV bundles.\n\tvar didRenderTooFewHooks=currentHook!==null&&currentHook.next!==null;renderLanes=NoLanes;currentlyRenderingFiber$1=null;currentHook=null;workInProgressHook=null;{currentHookNameInDev=null;hookTypesDev=null;hookTypesUpdateIndexDev=-1;// Confirm that a static flag was not added or removed since the last\n\t// render. If this fires, it suggests that we incorrectly reset the static\n\t// flags in some other part of the codebase. This has happened before, for\n\t// example, in the SuspenseList implementation.\n\tif(current!==null&&(current.flags&StaticMask)!==(workInProgress.flags&StaticMask)&&// Disable this warning in legacy mode, because legacy Suspense is weird\n\t// and creates false positives. To make this work in legacy mode, we'd\n\t// need to mark fibers that commit in an incomplete state, somehow. For\n\t// now I'll disable the warning that most of the bugs that would trigger\n\t// it are either exclusive to concurrent mode or exist in both.\n\t(current.mode&ConcurrentMode)!==NoMode){error('Internal React error: Expected static flag was missing. Please '+'notify the React team.');}}didScheduleRenderPhaseUpdate=false;// This is reset by checkDidRenderIdHook\n\t// localIdCounter = 0;\n\tif(didRenderTooFewHooks){throw new Error('Rendered fewer hooks than expected. This may be caused by an accidental '+'early return statement.');}return children;}function checkDidRenderIdHook(){// This should be called immediately after every renderWithHooks call.\n\t// Conceptually, it's part of the return value of renderWithHooks; it's only a\n\t// separate function to avoid using an array tuple.\n\tvar didRenderIdHook=localIdCounter!==0;localIdCounter=0;return didRenderIdHook;}function bailoutHooks(current,workInProgress,lanes){workInProgress.updateQueue=current.updateQueue;// TODO: Don't need to reset the flags here, because they're reset in the\n\t// complete phase (bubbleProperties).\n\tif((workInProgress.mode&StrictEffectsMode)!==NoMode){workInProgress.flags&=~(MountPassiveDev|MountLayoutDev|Passive|Update);}else {workInProgress.flags&=~(Passive|Update);}current.lanes=removeLanes(current.lanes,lanes);}function resetHooksAfterThrow(){// We can assume the previous dispatcher is always this one, since we set it\n\t// at the beginning of the render phase and there's no re-entrance.\n\tReactCurrentDispatcher$1.current=ContextOnlyDispatcher;if(didScheduleRenderPhaseUpdate){// There were render phase updates. These are only valid for this render\n\t// phase, which we are now aborting. Remove the updates from the queues so\n\t// they do not persist to the next render. Do not remove updates from hooks\n\t// that weren't processed.\n\t//\n\t// Only reset the updates from the queue if it has a clone. If it does\n\t// not have a clone, that means it wasn't processed, and the updates were\n\t// scheduled before we entered the render phase.\n\tvar hook=currentlyRenderingFiber$1.memoizedState;while(hook!==null){var queue=hook.queue;if(queue!==null){queue.pending=null;}hook=hook.next;}didScheduleRenderPhaseUpdate=false;}renderLanes=NoLanes;currentlyRenderingFiber$1=null;currentHook=null;workInProgressHook=null;{hookTypesDev=null;hookTypesUpdateIndexDev=-1;currentHookNameInDev=null;isUpdatingOpaqueValueInRenderPhase=false;}didScheduleRenderPhaseUpdateDuringThisPass=false;localIdCounter=0;}function mountWorkInProgressHook(){var hook={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};if(workInProgressHook===null){// This is the first hook in the list\n\tcurrentlyRenderingFiber$1.memoizedState=workInProgressHook=hook;}else {// Append to the end of the list\n\tworkInProgressHook=workInProgressHook.next=hook;}return workInProgressHook;}function updateWorkInProgressHook(){// This function is used both for updates and for re-renders triggered by a\n\t// render phase update. It assumes there is either a current hook we can\n\t// clone, or a work-in-progress hook from a previous render pass that we can\n\t// use as a base. When we reach the end of the base list, we must switch to\n\t// the dispatcher used for mounts.\n\tvar nextCurrentHook;if(currentHook===null){var current=currentlyRenderingFiber$1.alternate;if(current!==null){nextCurrentHook=current.memoizedState;}else {nextCurrentHook=null;}}else {nextCurrentHook=currentHook.next;}var nextWorkInProgressHook;if(workInProgressHook===null){nextWorkInProgressHook=currentlyRenderingFiber$1.memoizedState;}else {nextWorkInProgressHook=workInProgressHook.next;}if(nextWorkInProgressHook!==null){// There's already a work-in-progress. Reuse it.\n\tworkInProgressHook=nextWorkInProgressHook;nextWorkInProgressHook=workInProgressHook.next;currentHook=nextCurrentHook;}else {// Clone from the current hook.\n\tif(nextCurrentHook===null){throw new Error('Rendered more hooks than during the previous render.');}currentHook=nextCurrentHook;var newHook={memoizedState:currentHook.memoizedState,baseState:currentHook.baseState,baseQueue:currentHook.baseQueue,queue:currentHook.queue,next:null};if(workInProgressHook===null){// This is the first hook in the list.\n\tcurrentlyRenderingFiber$1.memoizedState=workInProgressHook=newHook;}else {// Append to the end of the list.\n\tworkInProgressHook=workInProgressHook.next=newHook;}}return workInProgressHook;}function createFunctionComponentUpdateQueue(){return {lastEffect:null,stores:null};}function basicStateReducer(state,action){// $FlowFixMe: Flow doesn't like mixed types\n\treturn typeof action==='function'?action(state):action;}function mountReducer(reducer,initialArg,init){var hook=mountWorkInProgressHook();var initialState;if(init!==undefined){initialState=init(initialArg);}else {initialState=initialArg;}hook.memoizedState=hook.baseState=initialState;var queue={pending:null,interleaved:null,lanes:NoLanes,dispatch:null,lastRenderedReducer:reducer,lastRenderedState:initialState};hook.queue=queue;var dispatch=queue.dispatch=dispatchReducerAction.bind(null,currentlyRenderingFiber$1,queue);return [hook.memoizedState,dispatch];}function updateReducer(reducer,initialArg,init){var hook=updateWorkInProgressHook();var queue=hook.queue;if(queue===null){throw new Error('Should have a queue. This is likely a bug in React. Please file an issue.');}queue.lastRenderedReducer=reducer;var current=currentHook;// The last rebase update that is NOT part of the base state.\n\tvar baseQueue=current.baseQueue;// The last pending update that hasn't been processed yet.\n\tvar pendingQueue=queue.pending;if(pendingQueue!==null){// We have new updates that haven't been processed yet.\n\t// We'll add them to the base queue.\n\tif(baseQueue!==null){// Merge the pending queue and the base queue.\n\tvar baseFirst=baseQueue.next;var pendingFirst=pendingQueue.next;baseQueue.next=pendingFirst;pendingQueue.next=baseFirst;}{if(current.baseQueue!==baseQueue){// Internal invariant that should never happen, but feasibly could in\n\t// the future if we implement resuming, or some form of that.\n\terror('Internal error: Expected work-in-progress queue to be a clone. '+'This is a bug in React.');}}current.baseQueue=baseQueue=pendingQueue;queue.pending=null;}if(baseQueue!==null){// We have a queue to process.\n\tvar first=baseQueue.next;var newState=current.baseState;var newBaseState=null;var newBaseQueueFirst=null;var newBaseQueueLast=null;var update=first;do{var updateLane=update.lane;if(!isSubsetOfLanes(renderLanes,updateLane)){// Priority is insufficient. Skip this update. If this is the first\n\t// skipped update, the previous update/state is the new base\n\t// update/state.\n\tvar clone={lane:updateLane,action:update.action,hasEagerState:update.hasEagerState,eagerState:update.eagerState,next:null};if(newBaseQueueLast===null){newBaseQueueFirst=newBaseQueueLast=clone;newBaseState=newState;}else {newBaseQueueLast=newBaseQueueLast.next=clone;}// Update the remaining priority in the queue.\n\t// TODO: Don't need to accumulate this. Instead, we can remove\n\t// renderLanes from the original lanes.\n\tcurrentlyRenderingFiber$1.lanes=mergeLanes(currentlyRenderingFiber$1.lanes,updateLane);markSkippedUpdateLanes(updateLane);}else {// This update does have sufficient priority.\n\tif(newBaseQueueLast!==null){var _clone={// This update is going to be committed so we never want uncommit\n\t// it. Using NoLane works because 0 is a subset of all bitmasks, so\n\t// this will never be skipped by the check above.\n\tlane:NoLane,action:update.action,hasEagerState:update.hasEagerState,eagerState:update.eagerState,next:null};newBaseQueueLast=newBaseQueueLast.next=_clone;}// Process this update.\n\tif(update.hasEagerState){// If this update is a state update (not a reducer) and was processed eagerly,\n\t// we can use the eagerly computed state\n\tnewState=update.eagerState;}else {var action=update.action;newState=reducer(newState,action);}}update=update.next;}while(update!==null&&update!==first);if(newBaseQueueLast===null){newBaseState=newState;}else {newBaseQueueLast.next=newBaseQueueFirst;}// Mark that the fiber performed work, but only if the new state is\n\t// different from the current state.\n\tif(!objectIs(newState,hook.memoizedState)){markWorkInProgressReceivedUpdate();}hook.memoizedState=newState;hook.baseState=newBaseState;hook.baseQueue=newBaseQueueLast;queue.lastRenderedState=newState;}// Interleaved updates are stored on a separate queue. We aren't going to\n\t// process them during this render, but we do need to track which lanes\n\t// are remaining.\n\tvar lastInterleaved=queue.interleaved;if(lastInterleaved!==null){var interleaved=lastInterleaved;do{var interleavedLane=interleaved.lane;currentlyRenderingFiber$1.lanes=mergeLanes(currentlyRenderingFiber$1.lanes,interleavedLane);markSkippedUpdateLanes(interleavedLane);interleaved=interleaved.next;}while(interleaved!==lastInterleaved);}else if(baseQueue===null){// `queue.lanes` is used for entangling transitions. We can set it back to\n\t// zero once the queue is empty.\n\tqueue.lanes=NoLanes;}var dispatch=queue.dispatch;return [hook.memoizedState,dispatch];}function rerenderReducer(reducer,initialArg,init){var hook=updateWorkInProgressHook();var queue=hook.queue;if(queue===null){throw new Error('Should have a queue. This is likely a bug in React. Please file an issue.');}queue.lastRenderedReducer=reducer;// This is a re-render. Apply the new render phase updates to the previous\n\t// work-in-progress hook.\n\tvar dispatch=queue.dispatch;var lastRenderPhaseUpdate=queue.pending;var newState=hook.memoizedState;if(lastRenderPhaseUpdate!==null){// The queue doesn't persist past this render pass.\n\tqueue.pending=null;var firstRenderPhaseUpdate=lastRenderPhaseUpdate.next;var update=firstRenderPhaseUpdate;do{// Process this render phase update. We don't have to check the\n\t// priority because it will always be the same as the current\n\t// render's.\n\tvar action=update.action;newState=reducer(newState,action);update=update.next;}while(update!==firstRenderPhaseUpdate);// Mark that the fiber performed work, but only if the new state is\n\t// different from the current state.\n\tif(!objectIs(newState,hook.memoizedState)){markWorkInProgressReceivedUpdate();}hook.memoizedState=newState;// Don't persist the state accumulated from the render phase updates to\n\t// the base state unless the queue is empty.\n\t// TODO: Not sure if this is the desired semantics, but it's what we\n\t// do for gDSFP. I can't remember why.\n\tif(hook.baseQueue===null){hook.baseState=newState;}queue.lastRenderedState=newState;}return [newState,dispatch];}function mountMutableSource(source,getSnapshot,subscribe){{return undefined;}}function updateMutableSource(source,getSnapshot,subscribe){{return undefined;}}function mountSyncExternalStore(subscribe,getSnapshot,getServerSnapshot){var fiber=currentlyRenderingFiber$1;var hook=mountWorkInProgressHook();var nextSnapshot;var isHydrating=getIsHydrating();if(isHydrating){if(getServerSnapshot===undefined){throw new Error('Missing getServerSnapshot, which is required for '+'server-rendered content. Will revert to client rendering.');}nextSnapshot=getServerSnapshot();{if(!didWarnUncachedGetSnapshot){if(nextSnapshot!==getServerSnapshot()){error('The result of getServerSnapshot should be cached to avoid an infinite loop');didWarnUncachedGetSnapshot=true;}}}}else {nextSnapshot=getSnapshot();{if(!didWarnUncachedGetSnapshot){var cachedSnapshot=getSnapshot();if(!objectIs(nextSnapshot,cachedSnapshot)){error('The result of getSnapshot should be cached to avoid an infinite loop');didWarnUncachedGetSnapshot=true;}}}// Unless we're rendering a blocking lane, schedule a consistency check.\n\t// Right before committing, we will walk the tree and check if any of the\n\t// stores were mutated.\n\t//\n\t// We won't do this if we're hydrating server-rendered content, because if\n\t// the content is stale, it's already visible anyway. Instead we'll patch\n\t// it up in a passive effect.\n\tvar root=getWorkInProgressRoot();if(root===null){throw new Error('Expected a work-in-progress root. This is a bug in React. Please file an issue.');}if(!includesBlockingLane(root,renderLanes)){pushStoreConsistencyCheck(fiber,getSnapshot,nextSnapshot);}}// Read the current snapshot from the store on every render. This breaks the\n\t// normal rules of React, and only works because store updates are\n\t// always synchronous.\n\thook.memoizedState=nextSnapshot;var inst={value:nextSnapshot,getSnapshot:getSnapshot};hook.queue=inst;// Schedule an effect to subscribe to the store.\n\tmountEffect(subscribeToStore.bind(null,fiber,inst,subscribe),[subscribe]);// Schedule an effect to update the mutable instance fields. We will update\n\t// this whenever subscribe, getSnapshot, or value changes. Because there's no\n\t// clean-up function, and we track the deps correctly, we can call pushEffect\n\t// directly, without storing any additional state. For the same reason, we\n\t// don't need to set a static flag, either.\n\t// TODO: We can move this to the passive phase once we add a pre-commit\n\t// consistency check. See the next comment.\n\tfiber.flags|=Passive;pushEffect(HasEffect|Passive$1,updateStoreInstance.bind(null,fiber,inst,nextSnapshot,getSnapshot),undefined,null);return nextSnapshot;}function updateSyncExternalStore(subscribe,getSnapshot,getServerSnapshot){var fiber=currentlyRenderingFiber$1;var hook=updateWorkInProgressHook();// Read the current snapshot from the store on every render. This breaks the\n\t// normal rules of React, and only works because store updates are\n\t// always synchronous.\n\tvar nextSnapshot=getSnapshot();{if(!didWarnUncachedGetSnapshot){var cachedSnapshot=getSnapshot();if(!objectIs(nextSnapshot,cachedSnapshot)){error('The result of getSnapshot should be cached to avoid an infinite loop');didWarnUncachedGetSnapshot=true;}}}var prevSnapshot=hook.memoizedState;var snapshotChanged=!objectIs(prevSnapshot,nextSnapshot);if(snapshotChanged){hook.memoizedState=nextSnapshot;markWorkInProgressReceivedUpdate();}var inst=hook.queue;updateEffect(subscribeToStore.bind(null,fiber,inst,subscribe),[subscribe]);// Whenever getSnapshot or subscribe changes, we need to check in the\n\t// commit phase if there was an interleaved mutation. In concurrent mode\n\t// this can happen all the time, but even in synchronous mode, an earlier\n\t// effect may have mutated the store.\n\tif(inst.getSnapshot!==getSnapshot||snapshotChanged||// Check if the susbcribe function changed. We can save some memory by\n\t// checking whether we scheduled a subscription effect above.\n\tworkInProgressHook!==null&&workInProgressHook.memoizedState.tag&HasEffect){fiber.flags|=Passive;pushEffect(HasEffect|Passive$1,updateStoreInstance.bind(null,fiber,inst,nextSnapshot,getSnapshot),undefined,null);// Unless we're rendering a blocking lane, schedule a consistency check.\n\t// Right before committing, we will walk the tree and check if any of the\n\t// stores were mutated.\n\tvar root=getWorkInProgressRoot();if(root===null){throw new Error('Expected a work-in-progress root. This is a bug in React. Please file an issue.');}if(!includesBlockingLane(root,renderLanes)){pushStoreConsistencyCheck(fiber,getSnapshot,nextSnapshot);}}return nextSnapshot;}function pushStoreConsistencyCheck(fiber,getSnapshot,renderedSnapshot){fiber.flags|=StoreConsistency;var check={getSnapshot:getSnapshot,value:renderedSnapshot};var componentUpdateQueue=currentlyRenderingFiber$1.updateQueue;if(componentUpdateQueue===null){componentUpdateQueue=createFunctionComponentUpdateQueue();currentlyRenderingFiber$1.updateQueue=componentUpdateQueue;componentUpdateQueue.stores=[check];}else {var stores=componentUpdateQueue.stores;if(stores===null){componentUpdateQueue.stores=[check];}else {stores.push(check);}}}function updateStoreInstance(fiber,inst,nextSnapshot,getSnapshot){// These are updated in the passive phase\n\tinst.value=nextSnapshot;inst.getSnapshot=getSnapshot;// Something may have been mutated in between render and commit. This could\n\t// have been in an event that fired before the passive effects, or it could\n\t// have been in a layout effect. In that case, we would have used the old\n\t// snapsho and getSnapshot values to bail out. We need to check one more time.\n\tif(checkIfSnapshotChanged(inst)){// Force a re-render.\n\tforceStoreRerender(fiber);}}function subscribeToStore(fiber,inst,subscribe){var handleStoreChange=function(){// The store changed. Check if the snapshot changed since the last time we\n\t// read from the store.\n\tif(checkIfSnapshotChanged(inst)){// Force a re-render.\n\tforceStoreRerender(fiber);}};// Subscribe to the store and return a clean-up function.\n\treturn subscribe(handleStoreChange);}function checkIfSnapshotChanged(inst){var latestGetSnapshot=inst.getSnapshot;var prevValue=inst.value;try{var nextValue=latestGetSnapshot();return !objectIs(prevValue,nextValue);}catch(error){return true;}}function forceStoreRerender(fiber){var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){scheduleUpdateOnFiber(root,fiber,SyncLane,NoTimestamp);}}function mountState(initialState){var hook=mountWorkInProgressHook();if(typeof initialState==='function'){// $FlowFixMe: Flow doesn't like mixed types\n\tinitialState=initialState();}hook.memoizedState=hook.baseState=initialState;var queue={pending:null,interleaved:null,lanes:NoLanes,dispatch:null,lastRenderedReducer:basicStateReducer,lastRenderedState:initialState};hook.queue=queue;var dispatch=queue.dispatch=dispatchSetState.bind(null,currentlyRenderingFiber$1,queue);return [hook.memoizedState,dispatch];}function updateState(initialState){return updateReducer(basicStateReducer);}function rerenderState(initialState){return rerenderReducer(basicStateReducer);}function pushEffect(tag,create,destroy,deps){var effect={tag:tag,create:create,destroy:destroy,deps:deps,// Circular\n\tnext:null};var componentUpdateQueue=currentlyRenderingFiber$1.updateQueue;if(componentUpdateQueue===null){componentUpdateQueue=createFunctionComponentUpdateQueue();currentlyRenderingFiber$1.updateQueue=componentUpdateQueue;componentUpdateQueue.lastEffect=effect.next=effect;}else {var lastEffect=componentUpdateQueue.lastEffect;if(lastEffect===null){componentUpdateQueue.lastEffect=effect.next=effect;}else {var firstEffect=lastEffect.next;lastEffect.next=effect;effect.next=firstEffect;componentUpdateQueue.lastEffect=effect;}}return effect;}function mountRef(initialValue){var hook=mountWorkInProgressHook();{var _ref2={current:initialValue};hook.memoizedState=_ref2;return _ref2;}}function updateRef(initialValue){var hook=updateWorkInProgressHook();return hook.memoizedState;}function mountEffectImpl(fiberFlags,hookFlags,create,deps){var hook=mountWorkInProgressHook();var nextDeps=deps===undefined?null:deps;currentlyRenderingFiber$1.flags|=fiberFlags;hook.memoizedState=pushEffect(HasEffect|hookFlags,create,undefined,nextDeps);}function updateEffectImpl(fiberFlags,hookFlags,create,deps){var hook=updateWorkInProgressHook();var nextDeps=deps===undefined?null:deps;var destroy=undefined;if(currentHook!==null){var prevEffect=currentHook.memoizedState;destroy=prevEffect.destroy;if(nextDeps!==null){var prevDeps=prevEffect.deps;if(areHookInputsEqual(nextDeps,prevDeps)){hook.memoizedState=pushEffect(hookFlags,create,destroy,nextDeps);return;}}}currentlyRenderingFiber$1.flags|=fiberFlags;hook.memoizedState=pushEffect(HasEffect|hookFlags,create,destroy,nextDeps);}function mountEffect(create,deps){if((currentlyRenderingFiber$1.mode&StrictEffectsMode)!==NoMode){return mountEffectImpl(MountPassiveDev|Passive|PassiveStatic,Passive$1,create,deps);}else {return mountEffectImpl(Passive|PassiveStatic,Passive$1,create,deps);}}function updateEffect(create,deps){return updateEffectImpl(Passive,Passive$1,create,deps);}function mountInsertionEffect(create,deps){return mountEffectImpl(Update,Insertion,create,deps);}function updateInsertionEffect(create,deps){return updateEffectImpl(Update,Insertion,create,deps);}function mountLayoutEffect(create,deps){var fiberFlags=Update;{fiberFlags|=LayoutStatic;}if((currentlyRenderingFiber$1.mode&StrictEffectsMode)!==NoMode){fiberFlags|=MountLayoutDev;}return mountEffectImpl(fiberFlags,Layout,create,deps);}function updateLayoutEffect(create,deps){return updateEffectImpl(Update,Layout,create,deps);}function imperativeHandleEffect(create,ref){if(typeof ref==='function'){var refCallback=ref;var _inst=create();refCallback(_inst);return function(){refCallback(null);};}else if(ref!==null&&ref!==undefined){var refObject=ref;{if(!refObject.hasOwnProperty('current')){error('Expected useImperativeHandle() first argument to either be a '+'ref callback or React.createRef() object. Instead received: %s.','an object with keys {'+Object.keys(refObject).join(', ')+'}');}}var _inst2=create();refObject.current=_inst2;return function(){refObject.current=null;};}}function mountImperativeHandle(ref,create,deps){{if(typeof create!=='function'){error('Expected useImperativeHandle() second argument to be a function '+'that creates a handle. Instead received: %s.',create!==null?typeof create:'null');}}// TODO: If deps are provided, should we skip comparing the ref itself?\n\tvar effectDeps=deps!==null&&deps!==undefined?deps.concat([ref]):null;var fiberFlags=Update;{fiberFlags|=LayoutStatic;}if((currentlyRenderingFiber$1.mode&StrictEffectsMode)!==NoMode){fiberFlags|=MountLayoutDev;}return mountEffectImpl(fiberFlags,Layout,imperativeHandleEffect.bind(null,create,ref),effectDeps);}function updateImperativeHandle(ref,create,deps){{if(typeof create!=='function'){error('Expected useImperativeHandle() second argument to be a function '+'that creates a handle. Instead received: %s.',create!==null?typeof create:'null');}}// TODO: If deps are provided, should we skip comparing the ref itself?\n\tvar effectDeps=deps!==null&&deps!==undefined?deps.concat([ref]):null;return updateEffectImpl(Update,Layout,imperativeHandleEffect.bind(null,create,ref),effectDeps);}function mountDebugValue(value,formatterFn){// This hook is normally a no-op.\n\t// The react-debug-hooks package injects its own implementation\n\t// so that e.g. DevTools can display custom hook values.\n\t}var updateDebugValue=mountDebugValue;function mountCallback(callback,deps){var hook=mountWorkInProgressHook();var nextDeps=deps===undefined?null:deps;hook.memoizedState=[callback,nextDeps];return callback;}function updateCallback(callback,deps){var hook=updateWorkInProgressHook();var nextDeps=deps===undefined?null:deps;var prevState=hook.memoizedState;if(prevState!==null){if(nextDeps!==null){var prevDeps=prevState[1];if(areHookInputsEqual(nextDeps,prevDeps)){return prevState[0];}}}hook.memoizedState=[callback,nextDeps];return callback;}function mountMemo(nextCreate,deps){var hook=mountWorkInProgressHook();var nextDeps=deps===undefined?null:deps;var nextValue=nextCreate();hook.memoizedState=[nextValue,nextDeps];return nextValue;}function updateMemo(nextCreate,deps){var hook=updateWorkInProgressHook();var nextDeps=deps===undefined?null:deps;var prevState=hook.memoizedState;if(prevState!==null){// Assume these are defined. If they're not, areHookInputsEqual will warn.\n\tif(nextDeps!==null){var prevDeps=prevState[1];if(areHookInputsEqual(nextDeps,prevDeps)){return prevState[0];}}}var nextValue=nextCreate();hook.memoizedState=[nextValue,nextDeps];return nextValue;}function mountDeferredValue(value){var hook=mountWorkInProgressHook();hook.memoizedState=value;return value;}function updateDeferredValue(value){var hook=updateWorkInProgressHook();var resolvedCurrentHook=currentHook;var prevValue=resolvedCurrentHook.memoizedState;return updateDeferredValueImpl(hook,prevValue,value);}function rerenderDeferredValue(value){var hook=updateWorkInProgressHook();if(currentHook===null){// This is a rerender during a mount.\n\thook.memoizedState=value;return value;}else {// This is a rerender during an update.\n\tvar prevValue=currentHook.memoizedState;return updateDeferredValueImpl(hook,prevValue,value);}}function updateDeferredValueImpl(hook,prevValue,value){var shouldDeferValue=!includesOnlyNonUrgentLanes(renderLanes);if(shouldDeferValue){// This is an urgent update. If the value has changed, keep using the\n\t// previous value and spawn a deferred render to update it later.\n\tif(!objectIs(value,prevValue)){// Schedule a deferred render\n\tvar deferredLane=claimNextTransitionLane();currentlyRenderingFiber$1.lanes=mergeLanes(currentlyRenderingFiber$1.lanes,deferredLane);markSkippedUpdateLanes(deferredLane);// Set this to true to indicate that the rendered value is inconsistent\n\t// from the latest value. The name \"baseState\" doesn't really match how we\n\t// use it because we're reusing a state hook field instead of creating a\n\t// new one.\n\thook.baseState=true;}// Reuse the previous value\n\treturn prevValue;}else {// This is not an urgent update, so we can use the latest value regardless\n\t// of what it is. No need to defer it.\n\t// However, if we're currently inside a spawned render, then we need to mark\n\t// this as an update to prevent the fiber from bailing out.\n\t//\n\t// `baseState` is true when the current value is different from the rendered\n\t// value. The name doesn't really match how we use it because we're reusing\n\t// a state hook field instead of creating a new one.\n\tif(hook.baseState){// Flip this back to false.\n\thook.baseState=false;markWorkInProgressReceivedUpdate();}hook.memoizedState=value;return value;}}function startTransition(setPending,callback,options){var previousPriority=getCurrentUpdatePriority();setCurrentUpdatePriority(higherEventPriority(previousPriority,ContinuousEventPriority));setPending(true);var prevTransition=ReactCurrentBatchConfig$2.transition;ReactCurrentBatchConfig$2.transition={};var currentTransition=ReactCurrentBatchConfig$2.transition;{ReactCurrentBatchConfig$2.transition._updatedFibers=new Set();}try{setPending(false);callback();}finally{setCurrentUpdatePriority(previousPriority);ReactCurrentBatchConfig$2.transition=prevTransition;{if(prevTransition===null&&currentTransition._updatedFibers){var updatedFibersCount=currentTransition._updatedFibers.size;if(updatedFibersCount>10){warn('Detected a large number of updates inside startTransition. '+'If this is due to a subscription please re-write it to use React provided hooks. '+'Otherwise concurrent mode guarantees are off the table.');}currentTransition._updatedFibers.clear();}}}}function mountTransition(){var _mountState=mountState(false),isPending=_mountState[0],setPending=_mountState[1];// The `start` method never changes.\n\tvar start=startTransition.bind(null,setPending);var hook=mountWorkInProgressHook();hook.memoizedState=start;return [isPending,start];}function updateTransition(){var _updateState=updateState(),isPending=_updateState[0];var hook=updateWorkInProgressHook();var start=hook.memoizedState;return [isPending,start];}function rerenderTransition(){var _rerenderState=rerenderState(),isPending=_rerenderState[0];var hook=updateWorkInProgressHook();var start=hook.memoizedState;return [isPending,start];}var isUpdatingOpaqueValueInRenderPhase=false;function getIsUpdatingOpaqueValueInRenderPhaseInDEV(){{return isUpdatingOpaqueValueInRenderPhase;}}function mountId(){var hook=mountWorkInProgressHook();var root=getWorkInProgressRoot();// TODO: In Fizz, id generation is specific to each server config. Maybe we\n\t// should do this in Fiber, too? Deferring this decision for now because\n\t// there's no other place to store the prefix except for an internal field on\n\t// the public createRoot object, which the fiber tree does not currently have\n\t// a reference to.\n\tvar identifierPrefix=root.identifierPrefix;var id;if(getIsHydrating()){var treeId=getTreeId();// Use a captial R prefix for server-generated ids.\n\tid=':'+identifierPrefix+'R'+treeId;// Unless this is the first id at this level, append a number at the end\n\t// that represents the position of this useId hook among all the useId\n\t// hooks for this fiber.\n\tvar localId=localIdCounter++;if(localId>0){id+='H'+localId.toString(32);}id+=':';}else {// Use a lowercase r prefix for client-generated ids.\n\tvar globalClientId=globalClientIdCounter++;id=':'+identifierPrefix+'r'+globalClientId.toString(32)+':';}hook.memoizedState=id;return id;}function updateId(){var hook=updateWorkInProgressHook();var id=hook.memoizedState;return id;}function dispatchReducerAction(fiber,queue,action){{if(typeof arguments[3]==='function'){error(\"State updates from the useState() and useReducer() Hooks don't support the \"+'second callback argument. To execute a side effect after '+'rendering, declare it in the component body with useEffect().');}}var lane=requestUpdateLane(fiber);var update={lane:lane,action:action,hasEagerState:false,eagerState:null,next:null};if(isRenderPhaseUpdate(fiber)){enqueueRenderPhaseUpdate(queue,update);}else {var root=enqueueConcurrentHookUpdate(fiber,queue,update,lane);if(root!==null){var eventTime=requestEventTime();scheduleUpdateOnFiber(root,fiber,lane,eventTime);entangleTransitionUpdate(root,queue,lane);}}markUpdateInDevTools(fiber,lane);}function dispatchSetState(fiber,queue,action){{if(typeof arguments[3]==='function'){error(\"State updates from the useState() and useReducer() Hooks don't support the \"+'second callback argument. To execute a side effect after '+'rendering, declare it in the component body with useEffect().');}}var lane=requestUpdateLane(fiber);var update={lane:lane,action:action,hasEagerState:false,eagerState:null,next:null};if(isRenderPhaseUpdate(fiber)){enqueueRenderPhaseUpdate(queue,update);}else {var alternate=fiber.alternate;if(fiber.lanes===NoLanes&&(alternate===null||alternate.lanes===NoLanes)){// The queue is currently empty, which means we can eagerly compute the\n\t// next state before entering the render phase. If the new state is the\n\t// same as the current state, we may be able to bail out entirely.\n\tvar lastRenderedReducer=queue.lastRenderedReducer;if(lastRenderedReducer!==null){var prevDispatcher;{prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;}try{var currentState=queue.lastRenderedState;var eagerState=lastRenderedReducer(currentState,action);// Stash the eagerly computed state, and the reducer used to compute\n\t// it, on the update object. If the reducer hasn't changed by the\n\t// time we enter the render phase, then the eager state can be used\n\t// without calling the reducer again.\n\tupdate.hasEagerState=true;update.eagerState=eagerState;if(objectIs(eagerState,currentState)){// Fast path. We can bail out without scheduling React to re-render.\n\t// It's still possible that we'll need to rebase this update later,\n\t// if the component re-renders for a different reason and by that\n\t// time the reducer has changed.\n\t// TODO: Do we still need to entangle transitions in this case?\n\tenqueueConcurrentHookUpdateAndEagerlyBailout(fiber,queue,update,lane);return;}}catch(error){// Suppress the error. It will throw again in the render phase.\n\t}finally{{ReactCurrentDispatcher$1.current=prevDispatcher;}}}}var root=enqueueConcurrentHookUpdate(fiber,queue,update,lane);if(root!==null){var eventTime=requestEventTime();scheduleUpdateOnFiber(root,fiber,lane,eventTime);entangleTransitionUpdate(root,queue,lane);}}markUpdateInDevTools(fiber,lane);}function isRenderPhaseUpdate(fiber){var alternate=fiber.alternate;return fiber===currentlyRenderingFiber$1||alternate!==null&&alternate===currentlyRenderingFiber$1;}function enqueueRenderPhaseUpdate(queue,update){// This is a render phase update. Stash it in a lazily-created map of\n\t// queue -> linked list of updates. After this render pass, we'll restart\n\t// and apply the stashed updates on top of the work-in-progress hook.\n\tdidScheduleRenderPhaseUpdateDuringThisPass=didScheduleRenderPhaseUpdate=true;var pending=queue.pending;if(pending===null){// This is the first update. Create a circular list.\n\tupdate.next=update;}else {update.next=pending.next;pending.next=update;}queue.pending=update;}// TODO: Move to ReactFiberConcurrentUpdates?\n\tfunction entangleTransitionUpdate(root,queue,lane){if(isTransitionLane(lane)){var queueLanes=queue.lanes;// If any entangled lanes are no longer pending on the root, then they\n\t// must have finished. We can remove them from the shared queue, which\n\t// represents a superset of the actually pending lanes. In some cases we\n\t// may entangle more than we need to, but that's OK. In fact it's worse if\n\t// we *don't* entangle when we should.\n\tqueueLanes=intersectLanes(queueLanes,root.pendingLanes);// Entangle the new transition lane with the other transition lanes.\n\tvar newQueueLanes=mergeLanes(queueLanes,lane);queue.lanes=newQueueLanes;// Even if queue.lanes already include lane, we don't know for certain if\n\t// the lane finished since the last time we entangled it. So we need to\n\t// entangle it again, just to be sure.\n\tmarkRootEntangled(root,newQueueLanes);}}function markUpdateInDevTools(fiber,lane,action){{markStateUpdateScheduled(fiber,lane);}}var ContextOnlyDispatcher={readContext:readContext,useCallback:throwInvalidHookError,useContext:throwInvalidHookError,useEffect:throwInvalidHookError,useImperativeHandle:throwInvalidHookError,useInsertionEffect:throwInvalidHookError,useLayoutEffect:throwInvalidHookError,useMemo:throwInvalidHookError,useReducer:throwInvalidHookError,useRef:throwInvalidHookError,useState:throwInvalidHookError,useDebugValue:throwInvalidHookError,useDeferredValue:throwInvalidHookError,useTransition:throwInvalidHookError,useMutableSource:throwInvalidHookError,useSyncExternalStore:throwInvalidHookError,useId:throwInvalidHookError,unstable_isNewReconciler:enableNewReconciler};var HooksDispatcherOnMountInDEV=null;var HooksDispatcherOnMountWithHookTypesInDEV=null;var HooksDispatcherOnUpdateInDEV=null;var HooksDispatcherOnRerenderInDEV=null;var InvalidNestedHooksDispatcherOnMountInDEV=null;var InvalidNestedHooksDispatcherOnUpdateInDEV=null;var InvalidNestedHooksDispatcherOnRerenderInDEV=null;{var warnInvalidContextAccess=function(){error('Context can only be read while React is rendering. '+'In classes, you can read it in the render method or getDerivedStateFromProps. '+'In function components, you can read it directly in the function body, but not '+'inside Hooks like useReducer() or useMemo().');};var warnInvalidHookAccess=function(){error('Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. '+'You can only call Hooks at the top level of your React function. '+'For more information, see '+'https://reactjs.org/link/rules-of-hooks');};HooksDispatcherOnMountInDEV={readContext:function(context){return readContext(context);},useCallback:function(callback,deps){currentHookNameInDev='useCallback';mountHookTypesDev();checkDepsAreArrayDev(deps);return mountCallback(callback,deps);},useContext:function(context){currentHookNameInDev='useContext';mountHookTypesDev();return readContext(context);},useEffect:function(create,deps){currentHookNameInDev='useEffect';mountHookTypesDev();checkDepsAreArrayDev(deps);return mountEffect(create,deps);},useImperativeHandle:function(ref,create,deps){currentHookNameInDev='useImperativeHandle';mountHookTypesDev();checkDepsAreArrayDev(deps);return mountImperativeHandle(ref,create,deps);},useInsertionEffect:function(create,deps){currentHookNameInDev='useInsertionEffect';mountHookTypesDev();checkDepsAreArrayDev(deps);return mountInsertionEffect(create,deps);},useLayoutEffect:function(create,deps){currentHookNameInDev='useLayoutEffect';mountHookTypesDev();checkDepsAreArrayDev(deps);return mountLayoutEffect(create,deps);},useMemo:function(create,deps){currentHookNameInDev='useMemo';mountHookTypesDev();checkDepsAreArrayDev(deps);var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function(reducer,initialArg,init){currentHookNameInDev='useReducer';mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function(initialValue){currentHookNameInDev='useRef';mountHookTypesDev();return mountRef(initialValue);},useState:function(initialState){currentHookNameInDev='useState';mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function(value,formatterFn){currentHookNameInDev='useDebugValue';mountHookTypesDev();return mountDebugValue();},useDeferredValue:function(value){currentHookNameInDev='useDeferredValue';mountHookTypesDev();return mountDeferredValue(value);},useTransition:function(){currentHookNameInDev='useTransition';mountHookTypesDev();return mountTransition();},useMutableSource:function(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';mountHookTypesDev();return mountMutableSource();},useSyncExternalStore:function(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev='useSyncExternalStore';mountHookTypesDev();return mountSyncExternalStore(subscribe,getSnapshot,getServerSnapshot);},useId:function(){currentHookNameInDev='useId';mountHookTypesDev();return mountId();},unstable_isNewReconciler:enableNewReconciler};HooksDispatcherOnMountWithHookTypesInDEV={readContext:function(context){return readContext(context);},useCallback:function(callback,deps){currentHookNameInDev='useCallback';updateHookTypesDev();return mountCallback(callback,deps);},useContext:function(context){currentHookNameInDev='useContext';updateHookTypesDev();return readContext(context);},useEffect:function(create,deps){currentHookNameInDev='useEffect';updateHookTypesDev();return mountEffect(create,deps);},useImperativeHandle:function(ref,create,deps){currentHookNameInDev='useImperativeHandle';updateHookTypesDev();return mountImperativeHandle(ref,create,deps);},useInsertionEffect:function(create,deps){currentHookNameInDev='useInsertionEffect';updateHookTypesDev();return mountInsertionEffect(create,deps);},useLayoutEffect:function(create,deps){currentHookNameInDev='useLayoutEffect';updateHookTypesDev();return mountLayoutEffect(create,deps);},useMemo:function(create,deps){currentHookNameInDev='useMemo';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function(reducer,initialArg,init){currentHookNameInDev='useReducer';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function(initialValue){currentHookNameInDev='useRef';updateHookTypesDev();return mountRef(initialValue);},useState:function(initialState){currentHookNameInDev='useState';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function(value,formatterFn){currentHookNameInDev='useDebugValue';updateHookTypesDev();return mountDebugValue();},useDeferredValue:function(value){currentHookNameInDev='useDeferredValue';updateHookTypesDev();return mountDeferredValue(value);},useTransition:function(){currentHookNameInDev='useTransition';updateHookTypesDev();return mountTransition();},useMutableSource:function(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';updateHookTypesDev();return mountMutableSource();},useSyncExternalStore:function(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev='useSyncExternalStore';updateHookTypesDev();return mountSyncExternalStore(subscribe,getSnapshot,getServerSnapshot);},useId:function(){currentHookNameInDev='useId';updateHookTypesDev();return mountId();},unstable_isNewReconciler:enableNewReconciler};HooksDispatcherOnUpdateInDEV={readContext:function(context){return readContext(context);},useCallback:function(callback,deps){currentHookNameInDev='useCallback';updateHookTypesDev();return updateCallback(callback,deps);},useContext:function(context){currentHookNameInDev='useContext';updateHookTypesDev();return readContext(context);},useEffect:function(create,deps){currentHookNameInDev='useEffect';updateHookTypesDev();return updateEffect(create,deps);},useImperativeHandle:function(ref,create,deps){currentHookNameInDev='useImperativeHandle';updateHookTypesDev();return updateImperativeHandle(ref,create,deps);},useInsertionEffect:function(create,deps){currentHookNameInDev='useInsertionEffect';updateHookTypesDev();return updateInsertionEffect(create,deps);},useLayoutEffect:function(create,deps){currentHookNameInDev='useLayoutEffect';updateHookTypesDev();return updateLayoutEffect(create,deps);},useMemo:function(create,deps){currentHookNameInDev='useMemo';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function(reducer,initialArg,init){currentHookNameInDev='useReducer';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function(initialValue){currentHookNameInDev='useRef';updateHookTypesDev();return updateRef();},useState:function(initialState){currentHookNameInDev='useState';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function(value,formatterFn){currentHookNameInDev='useDebugValue';updateHookTypesDev();return updateDebugValue();},useDeferredValue:function(value){currentHookNameInDev='useDeferredValue';updateHookTypesDev();return updateDeferredValue(value);},useTransition:function(){currentHookNameInDev='useTransition';updateHookTypesDev();return updateTransition();},useMutableSource:function(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';updateHookTypesDev();return updateMutableSource();},useSyncExternalStore:function(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev='useSyncExternalStore';updateHookTypesDev();return updateSyncExternalStore(subscribe,getSnapshot);},useId:function(){currentHookNameInDev='useId';updateHookTypesDev();return updateId();},unstable_isNewReconciler:enableNewReconciler};HooksDispatcherOnRerenderInDEV={readContext:function(context){return readContext(context);},useCallback:function(callback,deps){currentHookNameInDev='useCallback';updateHookTypesDev();return updateCallback(callback,deps);},useContext:function(context){currentHookNameInDev='useContext';updateHookTypesDev();return readContext(context);},useEffect:function(create,deps){currentHookNameInDev='useEffect';updateHookTypesDev();return updateEffect(create,deps);},useImperativeHandle:function(ref,create,deps){currentHookNameInDev='useImperativeHandle';updateHookTypesDev();return updateImperativeHandle(ref,create,deps);},useInsertionEffect:function(create,deps){currentHookNameInDev='useInsertionEffect';updateHookTypesDev();return updateInsertionEffect(create,deps);},useLayoutEffect:function(create,deps){currentHookNameInDev='useLayoutEffect';updateHookTypesDev();return updateLayoutEffect(create,deps);},useMemo:function(create,deps){currentHookNameInDev='useMemo';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnRerenderInDEV;try{return updateMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function(reducer,initialArg,init){currentHookNameInDev='useReducer';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnRerenderInDEV;try{return rerenderReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function(initialValue){currentHookNameInDev='useRef';updateHookTypesDev();return updateRef();},useState:function(initialState){currentHookNameInDev='useState';updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnRerenderInDEV;try{return rerenderState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function(value,formatterFn){currentHookNameInDev='useDebugValue';updateHookTypesDev();return updateDebugValue();},useDeferredValue:function(value){currentHookNameInDev='useDeferredValue';updateHookTypesDev();return rerenderDeferredValue(value);},useTransition:function(){currentHookNameInDev='useTransition';updateHookTypesDev();return rerenderTransition();},useMutableSource:function(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';updateHookTypesDev();return updateMutableSource();},useSyncExternalStore:function(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev='useSyncExternalStore';updateHookTypesDev();return updateSyncExternalStore(subscribe,getSnapshot);},useId:function(){currentHookNameInDev='useId';updateHookTypesDev();return updateId();},unstable_isNewReconciler:enableNewReconciler};InvalidNestedHooksDispatcherOnMountInDEV={readContext:function(context){warnInvalidContextAccess();return readContext(context);},useCallback:function(callback,deps){currentHookNameInDev='useCallback';warnInvalidHookAccess();mountHookTypesDev();return mountCallback(callback,deps);},useContext:function(context){currentHookNameInDev='useContext';warnInvalidHookAccess();mountHookTypesDev();return readContext(context);},useEffect:function(create,deps){currentHookNameInDev='useEffect';warnInvalidHookAccess();mountHookTypesDev();return mountEffect(create,deps);},useImperativeHandle:function(ref,create,deps){currentHookNameInDev='useImperativeHandle';warnInvalidHookAccess();mountHookTypesDev();return mountImperativeHandle(ref,create,deps);},useInsertionEffect:function(create,deps){currentHookNameInDev='useInsertionEffect';warnInvalidHookAccess();mountHookTypesDev();return mountInsertionEffect(create,deps);},useLayoutEffect:function(create,deps){currentHookNameInDev='useLayoutEffect';warnInvalidHookAccess();mountHookTypesDev();return mountLayoutEffect(create,deps);},useMemo:function(create,deps){currentHookNameInDev='useMemo';warnInvalidHookAccess();mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function(reducer,initialArg,init){currentHookNameInDev='useReducer';warnInvalidHookAccess();mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function(initialValue){currentHookNameInDev='useRef';warnInvalidHookAccess();mountHookTypesDev();return mountRef(initialValue);},useState:function(initialState){currentHookNameInDev='useState';warnInvalidHookAccess();mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function(value,formatterFn){currentHookNameInDev='useDebugValue';warnInvalidHookAccess();mountHookTypesDev();return mountDebugValue();},useDeferredValue:function(value){currentHookNameInDev='useDeferredValue';warnInvalidHookAccess();mountHookTypesDev();return mountDeferredValue(value);},useTransition:function(){currentHookNameInDev='useTransition';warnInvalidHookAccess();mountHookTypesDev();return mountTransition();},useMutableSource:function(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';warnInvalidHookAccess();mountHookTypesDev();return mountMutableSource();},useSyncExternalStore:function(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev='useSyncExternalStore';warnInvalidHookAccess();mountHookTypesDev();return mountSyncExternalStore(subscribe,getSnapshot,getServerSnapshot);},useId:function(){currentHookNameInDev='useId';warnInvalidHookAccess();mountHookTypesDev();return mountId();},unstable_isNewReconciler:enableNewReconciler};InvalidNestedHooksDispatcherOnUpdateInDEV={readContext:function(context){warnInvalidContextAccess();return readContext(context);},useCallback:function(callback,deps){currentHookNameInDev='useCallback';warnInvalidHookAccess();updateHookTypesDev();return updateCallback(callback,deps);},useContext:function(context){currentHookNameInDev='useContext';warnInvalidHookAccess();updateHookTypesDev();return readContext(context);},useEffect:function(create,deps){currentHookNameInDev='useEffect';warnInvalidHookAccess();updateHookTypesDev();return updateEffect(create,deps);},useImperativeHandle:function(ref,create,deps){currentHookNameInDev='useImperativeHandle';warnInvalidHookAccess();updateHookTypesDev();return updateImperativeHandle(ref,create,deps);},useInsertionEffect:function(create,deps){currentHookNameInDev='useInsertionEffect';warnInvalidHookAccess();updateHookTypesDev();return updateInsertionEffect(create,deps);},useLayoutEffect:function(create,deps){currentHookNameInDev='useLayoutEffect';warnInvalidHookAccess();updateHookTypesDev();return updateLayoutEffect(create,deps);},useMemo:function(create,deps){currentHookNameInDev='useMemo';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function(reducer,initialArg,init){currentHookNameInDev='useReducer';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function(initialValue){currentHookNameInDev='useRef';warnInvalidHookAccess();updateHookTypesDev();return updateRef();},useState:function(initialState){currentHookNameInDev='useState';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function(value,formatterFn){currentHookNameInDev='useDebugValue';warnInvalidHookAccess();updateHookTypesDev();return updateDebugValue();},useDeferredValue:function(value){currentHookNameInDev='useDeferredValue';warnInvalidHookAccess();updateHookTypesDev();return updateDeferredValue(value);},useTransition:function(){currentHookNameInDev='useTransition';warnInvalidHookAccess();updateHookTypesDev();return updateTransition();},useMutableSource:function(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';warnInvalidHookAccess();updateHookTypesDev();return updateMutableSource();},useSyncExternalStore:function(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev='useSyncExternalStore';warnInvalidHookAccess();updateHookTypesDev();return updateSyncExternalStore(subscribe,getSnapshot);},useId:function(){currentHookNameInDev='useId';warnInvalidHookAccess();updateHookTypesDev();return updateId();},unstable_isNewReconciler:enableNewReconciler};InvalidNestedHooksDispatcherOnRerenderInDEV={readContext:function(context){warnInvalidContextAccess();return readContext(context);},useCallback:function(callback,deps){currentHookNameInDev='useCallback';warnInvalidHookAccess();updateHookTypesDev();return updateCallback(callback,deps);},useContext:function(context){currentHookNameInDev='useContext';warnInvalidHookAccess();updateHookTypesDev();return readContext(context);},useEffect:function(create,deps){currentHookNameInDev='useEffect';warnInvalidHookAccess();updateHookTypesDev();return updateEffect(create,deps);},useImperativeHandle:function(ref,create,deps){currentHookNameInDev='useImperativeHandle';warnInvalidHookAccess();updateHookTypesDev();return updateImperativeHandle(ref,create,deps);},useInsertionEffect:function(create,deps){currentHookNameInDev='useInsertionEffect';warnInvalidHookAccess();updateHookTypesDev();return updateInsertionEffect(create,deps);},useLayoutEffect:function(create,deps){currentHookNameInDev='useLayoutEffect';warnInvalidHookAccess();updateHookTypesDev();return updateLayoutEffect(create,deps);},useMemo:function(create,deps){currentHookNameInDev='useMemo';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateMemo(create,deps);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useReducer:function(reducer,initialArg,init){currentHookNameInDev='useReducer';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return rerenderReducer(reducer,initialArg,init);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useRef:function(initialValue){currentHookNameInDev='useRef';warnInvalidHookAccess();updateHookTypesDev();return updateRef();},useState:function(initialState){currentHookNameInDev='useState';warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return rerenderState(initialState);}finally{ReactCurrentDispatcher$1.current=prevDispatcher;}},useDebugValue:function(value,formatterFn){currentHookNameInDev='useDebugValue';warnInvalidHookAccess();updateHookTypesDev();return updateDebugValue();},useDeferredValue:function(value){currentHookNameInDev='useDeferredValue';warnInvalidHookAccess();updateHookTypesDev();return rerenderDeferredValue(value);},useTransition:function(){currentHookNameInDev='useTransition';warnInvalidHookAccess();updateHookTypesDev();return rerenderTransition();},useMutableSource:function(source,getSnapshot,subscribe){currentHookNameInDev='useMutableSource';warnInvalidHookAccess();updateHookTypesDev();return updateMutableSource();},useSyncExternalStore:function(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev='useSyncExternalStore';warnInvalidHookAccess();updateHookTypesDev();return updateSyncExternalStore(subscribe,getSnapshot);},useId:function(){currentHookNameInDev='useId';warnInvalidHookAccess();updateHookTypesDev();return updateId();},unstable_isNewReconciler:enableNewReconciler};}var now$1=Scheduler.unstable_now;var commitTime=0;var layoutEffectStartTime=-1;var profilerStartTime=-1;var passiveEffectStartTime=-1;/**\n\t * Tracks whether the current update was a nested/cascading update (scheduled from a layout effect).\n\t *\n\t * The overall sequence is:\n\t *   1. render\n\t *   2. commit (and call `onRender`, `onCommit`)\n\t *   3. check for nested updates\n\t *   4. flush passive effects (and call `onPostCommit`)\n\t *\n\t * Nested updates are identified in step 3 above,\n\t * but step 4 still applies to the work that was just committed.\n\t * We use two flags to track nested updates then:\n\t * one tracks whether the upcoming update is a nested update,\n\t * and the other tracks whether the current update was a nested update.\n\t * The first value gets synced to the second at the start of the render phase.\n\t */var currentUpdateIsNested=false;var nestedUpdateScheduled=false;function isCurrentUpdateNested(){return currentUpdateIsNested;}function markNestedUpdateScheduled(){{nestedUpdateScheduled=true;}}function resetNestedUpdateFlag(){{currentUpdateIsNested=false;nestedUpdateScheduled=false;}}function syncNestedUpdateFlag(){{currentUpdateIsNested=nestedUpdateScheduled;nestedUpdateScheduled=false;}}function getCommitTime(){return commitTime;}function recordCommitTime(){commitTime=now$1();}function startProfilerTimer(fiber){profilerStartTime=now$1();if(fiber.actualStartTime<0){fiber.actualStartTime=now$1();}}function stopProfilerTimerIfRunning(fiber){profilerStartTime=-1;}function stopProfilerTimerIfRunningAndRecordDelta(fiber,overrideBaseTime){if(profilerStartTime>=0){var elapsedTime=now$1()-profilerStartTime;fiber.actualDuration+=elapsedTime;if(overrideBaseTime){fiber.selfBaseDuration=elapsedTime;}profilerStartTime=-1;}}function recordLayoutEffectDuration(fiber){if(layoutEffectStartTime>=0){var elapsedTime=now$1()-layoutEffectStartTime;layoutEffectStartTime=-1;// Store duration on the next nearest Profiler ancestor\n\t// Or the root (for the DevTools Profiler to read)\n\tvar parentFiber=fiber.return;while(parentFiber!==null){switch(parentFiber.tag){case HostRoot:var root=parentFiber.stateNode;root.effectDuration+=elapsedTime;return;case Profiler:var parentStateNode=parentFiber.stateNode;parentStateNode.effectDuration+=elapsedTime;return;}parentFiber=parentFiber.return;}}}function recordPassiveEffectDuration(fiber){if(passiveEffectStartTime>=0){var elapsedTime=now$1()-passiveEffectStartTime;passiveEffectStartTime=-1;// Store duration on the next nearest Profiler ancestor\n\t// Or the root (for the DevTools Profiler to read)\n\tvar parentFiber=fiber.return;while(parentFiber!==null){switch(parentFiber.tag){case HostRoot:var root=parentFiber.stateNode;if(root!==null){root.passiveEffectDuration+=elapsedTime;}return;case Profiler:var parentStateNode=parentFiber.stateNode;if(parentStateNode!==null){// Detached fibers have their state node cleared out.\n\t// In this case, the return pointer is also cleared out,\n\t// so we won't be able to report the time spent in this Profiler's subtree.\n\tparentStateNode.passiveEffectDuration+=elapsedTime;}return;}parentFiber=parentFiber.return;}}}function startLayoutEffectTimer(){layoutEffectStartTime=now$1();}function startPassiveEffectTimer(){passiveEffectStartTime=now$1();}function transferActualDuration(fiber){// Transfer time spent rendering these children so we don't lose it\n\t// after we rerender. This is used as a helper in special cases\n\t// where we should count the work of multiple passes.\n\tvar child=fiber.child;while(child){fiber.actualDuration+=child.actualDuration;child=child.sibling;}}function createCapturedValueAtFiber(value,source){// If the value is an error, call this function immediately after it is thrown\n\t// so the stack is accurate.\n\treturn {value:value,source:source,stack:getStackByFiberInDevAndProd(source),digest:null};}function createCapturedValue(value,digest,stack){return {value:value,source:null,stack:stack!=null?stack:null,digest:digest!=null?digest:null};}// This module is forked in different environments.\n\t// By default, return `true` to log errors to the console.\n\t// Forks can return `false` if this isn't desirable.\n\tfunction showErrorDialog(boundary,errorInfo){return true;}function logCapturedError(boundary,errorInfo){try{var logError=showErrorDialog(boundary,errorInfo);// Allow injected showErrorDialog() to prevent default console.error logging.\n\t// This enables renderers like ReactNative to better manage redbox behavior.\n\tif(logError===false){return;}var error=errorInfo.value;if(true){var source=errorInfo.source;var stack=errorInfo.stack;var componentStack=stack!==null?stack:'';// Browsers support silencing uncaught errors by calling\n\t// `preventDefault()` in window `error` handler.\n\t// We record this information as an expando on the error.\n\tif(error!=null&&error._suppressLogging){if(boundary.tag===ClassComponent){// The error is recoverable and was silenced.\n\t// Ignore it and don't print the stack addendum.\n\t// This is handy for testing error boundaries without noise.\n\treturn;}// The error is fatal. Since the silencing might have\n\t// been accidental, we'll surface it anyway.\n\t// However, the browser would have silenced the original error\n\t// so we'll print it first, and then print the stack addendum.\n\tconsole['error'](error);// Don't transform to our wrapper\n\t// For a more detailed description of this block, see:\n\t// https://github.com/facebook/react/pull/13384\n\t}var componentName=source?getComponentNameFromFiber(source):null;var componentNameMessage=componentName?\"The above error occurred in the <\"+componentName+\"> component:\":'The above error occurred in one of your React components:';var errorBoundaryMessage;if(boundary.tag===HostRoot){errorBoundaryMessage='Consider adding an error boundary to your tree to customize error handling behavior.\\n'+'Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.';}else {var errorBoundaryName=getComponentNameFromFiber(boundary)||'Anonymous';errorBoundaryMessage=\"React will try to recreate this component tree from scratch \"+(\"using the error boundary you provided, \"+errorBoundaryName+\".\");}var combinedMessage=componentNameMessage+\"\\n\"+componentStack+\"\\n\\n\"+(\"\"+errorBoundaryMessage);// In development, we provide our own message with just the component stack.\n\t// We don't include the original error message and JS stack because the browser\n\t// has already printed it. Even if the application swallows the error, it is still\n\t// displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.\n\tconsole['error'](combinedMessage);// Don't transform to our wrapper\n\t}}catch(e){// This method must not throw, or React internal state will get messed up.\n\t// If console.error is overridden, or logCapturedError() shows a dialog that throws,\n\t// we want to report this error outside of the normal stack as a last resort.\n\t// https://github.com/facebook/react/issues/13188\n\tsetTimeout(function(){throw e;});}}var PossiblyWeakMap$1=typeof WeakMap==='function'?WeakMap:Map;function createRootErrorUpdate(fiber,errorInfo,lane){var update=createUpdate(NoTimestamp,lane);// Unmount the root by rendering null.\n\tupdate.tag=CaptureUpdate;// Caution: React DevTools currently depends on this property\n\t// being called \"element\".\n\tupdate.payload={element:null};var error=errorInfo.value;update.callback=function(){onUncaughtError(error);logCapturedError(fiber,errorInfo);};return update;}function createClassErrorUpdate(fiber,errorInfo,lane){var update=createUpdate(NoTimestamp,lane);update.tag=CaptureUpdate;var getDerivedStateFromError=fiber.type.getDerivedStateFromError;if(typeof getDerivedStateFromError==='function'){var error$1=errorInfo.value;update.payload=function(){return getDerivedStateFromError(error$1);};update.callback=function(){{markFailedErrorBoundaryForHotReloading(fiber);}logCapturedError(fiber,errorInfo);};}var inst=fiber.stateNode;if(inst!==null&&typeof inst.componentDidCatch==='function'){update.callback=function callback(){{markFailedErrorBoundaryForHotReloading(fiber);}logCapturedError(fiber,errorInfo);if(typeof getDerivedStateFromError!=='function'){// To preserve the preexisting retry behavior of error boundaries,\n\t// we keep track of which ones already failed during this batch.\n\t// This gets reset before we yield back to the browser.\n\t// TODO: Warn in strict mode if getDerivedStateFromError is\n\t// not defined.\n\tmarkLegacyErrorBoundaryAsFailed(this);}var error$1=errorInfo.value;var stack=errorInfo.stack;this.componentDidCatch(error$1,{componentStack:stack!==null?stack:''});{if(typeof getDerivedStateFromError!=='function'){// If componentDidCatch is the only error boundary method defined,\n\t// then it needs to call setState to recover from errors.\n\t// If no state update is scheduled then the boundary will swallow the error.\n\tif(!includesSomeLane(fiber.lanes,SyncLane)){error('%s: Error boundaries should implement getDerivedStateFromError(). '+'In that method, return a state update to display an error message or fallback UI.',getComponentNameFromFiber(fiber)||'Unknown');}}}};}return update;}function attachPingListener(root,wakeable,lanes){// Attach a ping listener\n\t//\n\t// The data might resolve before we have a chance to commit the fallback. Or,\n\t// in the case of a refresh, we'll never commit a fallback. So we need to\n\t// attach a listener now. When it resolves (\"pings\"), we can decide whether to\n\t// try rendering the tree again.\n\t//\n\t// Only attach a listener if one does not already exist for the lanes\n\t// we're currently rendering (which acts like a \"thread ID\" here).\n\t//\n\t// We only need to do this in concurrent mode. Legacy Suspense always\n\t// commits fallbacks synchronously, so there are no pings.\n\tvar pingCache=root.pingCache;var threadIDs;if(pingCache===null){pingCache=root.pingCache=new PossiblyWeakMap$1();threadIDs=new Set();pingCache.set(wakeable,threadIDs);}else {threadIDs=pingCache.get(wakeable);if(threadIDs===undefined){threadIDs=new Set();pingCache.set(wakeable,threadIDs);}}if(!threadIDs.has(lanes)){// Memoize using the thread ID to prevent redundant listeners.\n\tthreadIDs.add(lanes);var ping=pingSuspendedRoot.bind(null,root,wakeable,lanes);{if(isDevToolsPresent){// If we have pending work still, restore the original updaters\n\trestorePendingUpdaters(root,lanes);}}wakeable.then(ping,ping);}}function attachRetryListener(suspenseBoundary,root,wakeable,lanes){// Retry listener\n\t//\n\t// If the fallback does commit, we need to attach a different type of\n\t// listener. This one schedules an update on the Suspense boundary to turn\n\t// the fallback state off.\n\t//\n\t// Stash the wakeable on the boundary fiber so we can access it in the\n\t// commit phase.\n\t//\n\t// When the wakeable resolves, we'll attempt to render the boundary\n\t// again (\"retry\").\n\tvar wakeables=suspenseBoundary.updateQueue;if(wakeables===null){var updateQueue=new Set();updateQueue.add(wakeable);suspenseBoundary.updateQueue=updateQueue;}else {wakeables.add(wakeable);}}function resetSuspendedComponent(sourceFiber,rootRenderLanes){// A legacy mode Suspense quirk, only relevant to hook components.\n\tvar tag=sourceFiber.tag;if((sourceFiber.mode&ConcurrentMode)===NoMode&&(tag===FunctionComponent||tag===ForwardRef||tag===SimpleMemoComponent)){var currentSource=sourceFiber.alternate;if(currentSource){sourceFiber.updateQueue=currentSource.updateQueue;sourceFiber.memoizedState=currentSource.memoizedState;sourceFiber.lanes=currentSource.lanes;}else {sourceFiber.updateQueue=null;sourceFiber.memoizedState=null;}}}function getNearestSuspenseBoundaryToCapture(returnFiber){var node=returnFiber;do{if(node.tag===SuspenseComponent&&shouldCaptureSuspense(node)){return node;}// This boundary already captured during this render. Continue to the next\n\t// boundary.\n\tnode=node.return;}while(node!==null);return null;}function markSuspenseBoundaryShouldCapture(suspenseBoundary,returnFiber,sourceFiber,root,rootRenderLanes){// This marks a Suspense boundary so that when we're unwinding the stack,\n\t// it captures the suspended \"exception\" and does a second (fallback) pass.\n\tif((suspenseBoundary.mode&ConcurrentMode)===NoMode){// Legacy Mode Suspense\n\t//\n\t// If the boundary is in legacy mode, we should *not*\n\t// suspend the commit. Pretend as if the suspended component rendered\n\t// null and keep rendering. When the Suspense boundary completes,\n\t// we'll do a second pass to render the fallback.\n\tif(suspenseBoundary===returnFiber){// Special case where we suspended while reconciling the children of\n\t// a Suspense boundary's inner Offscreen wrapper fiber. This happens\n\t// when a React.lazy component is a direct child of a\n\t// Suspense boundary.\n\t//\n\t// Suspense boundaries are implemented as multiple fibers, but they\n\t// are a single conceptual unit. The legacy mode behavior where we\n\t// pretend the suspended fiber committed as `null` won't work,\n\t// because in this case the \"suspended\" fiber is the inner\n\t// Offscreen wrapper.\n\t//\n\t// Because the contents of the boundary haven't started rendering\n\t// yet (i.e. nothing in the tree has partially rendered) we can\n\t// switch to the regular, concurrent mode behavior: mark the\n\t// boundary with ShouldCapture and enter the unwind phase.\n\tsuspenseBoundary.flags|=ShouldCapture;}else {suspenseBoundary.flags|=DidCapture;sourceFiber.flags|=ForceUpdateForLegacySuspense;// We're going to commit this fiber even though it didn't complete.\n\t// But we shouldn't call any lifecycle methods or callbacks. Remove\n\t// all lifecycle effect tags.\n\tsourceFiber.flags&=~(LifecycleEffectMask|Incomplete);if(sourceFiber.tag===ClassComponent){var currentSourceFiber=sourceFiber.alternate;if(currentSourceFiber===null){// This is a new mount. Change the tag so it's not mistaken for a\n\t// completed class component. For example, we should not call\n\t// componentWillUnmount if it is deleted.\n\tsourceFiber.tag=IncompleteClassComponent;}else {// When we try rendering again, we should not reuse the current fiber,\n\t// since it's known to be in an inconsistent state. Use a force update to\n\t// prevent a bail out.\n\tvar update=createUpdate(NoTimestamp,SyncLane);update.tag=ForceUpdate;enqueueUpdate(sourceFiber,update,SyncLane);}}// The source fiber did not complete. Mark it with Sync priority to\n\t// indicate that it still has pending work.\n\tsourceFiber.lanes=mergeLanes(sourceFiber.lanes,SyncLane);}return suspenseBoundary;}// Confirmed that the boundary is in a concurrent mode tree. Continue\n\t// with the normal suspend path.\n\t//\n\t// After this we'll use a set of heuristics to determine whether this\n\t// render pass will run to completion or restart or \"suspend\" the commit.\n\t// The actual logic for this is spread out in different places.\n\t//\n\t// This first principle is that if we're going to suspend when we complete\n\t// a root, then we should also restart if we get an update or ping that\n\t// might unsuspend it, and vice versa. The only reason to suspend is\n\t// because you think you might want to restart before committing. However,\n\t// it doesn't make sense to restart only while in the period we're suspended.\n\t//\n\t// Restarting too aggressively is also not good because it starves out any\n\t// intermediate loading state. So we use heuristics to determine when.\n\t// Suspense Heuristics\n\t//\n\t// If nothing threw a Promise or all the same fallbacks are already showing,\n\t// then don't suspend/restart.\n\t//\n\t// If this is an initial render of a new tree of Suspense boundaries and\n\t// those trigger a fallback, then don't suspend/restart. We want to ensure\n\t// that we can show the initial loading state as quickly as possible.\n\t//\n\t// If we hit a \"Delayed\" case, such as when we'd switch from content back into\n\t// a fallback, then we should always suspend/restart. Transitions apply\n\t// to this case. If none is defined, JND is used instead.\n\t//\n\t// If we're already showing a fallback and it gets \"retried\", allowing us to show\n\t// another level, but there's still an inner boundary that would show a fallback,\n\t// then we suspend/restart for 500ms since the last time we showed a fallback\n\t// anywhere in the tree. This effectively throttles progressive loading into a\n\t// consistent train of commits. This also gives us an opportunity to restart to\n\t// get to the completed state slightly earlier.\n\t//\n\t// If there's ambiguity due to batching it's resolved in preference of:\n\t// 1) \"delayed\", 2) \"initial render\", 3) \"retry\".\n\t//\n\t// We want to ensure that a \"busy\" state doesn't get force committed. We want to\n\t// ensure that new initial loading states can commit as soon as possible.\n\tsuspenseBoundary.flags|=ShouldCapture;// TODO: I think we can remove this, since we now use `DidCapture` in\n\t// the begin phase to prevent an early bailout.\n\tsuspenseBoundary.lanes=rootRenderLanes;return suspenseBoundary;}function throwException(root,returnFiber,sourceFiber,value,rootRenderLanes){// The source fiber did not complete.\n\tsourceFiber.flags|=Incomplete;{if(isDevToolsPresent){// If we have pending work still, restore the original updaters\n\trestorePendingUpdaters(root,rootRenderLanes);}}if(value!==null&&typeof value==='object'&&typeof value.then==='function'){// This is a wakeable. The component suspended.\n\tvar wakeable=value;resetSuspendedComponent(sourceFiber);{if(getIsHydrating()&&sourceFiber.mode&ConcurrentMode){markDidThrowWhileHydratingDEV();}}var suspenseBoundary=getNearestSuspenseBoundaryToCapture(returnFiber);if(suspenseBoundary!==null){suspenseBoundary.flags&=~ForceClientRender;markSuspenseBoundaryShouldCapture(suspenseBoundary,returnFiber,sourceFiber,root,rootRenderLanes);// We only attach ping listeners in concurrent mode. Legacy Suspense always\n\t// commits fallbacks synchronously, so there are no pings.\n\tif(suspenseBoundary.mode&ConcurrentMode){attachPingListener(root,wakeable,rootRenderLanes);}attachRetryListener(suspenseBoundary,root,wakeable);return;}else {// No boundary was found. Unless this is a sync update, this is OK.\n\t// We can suspend and wait for more data to arrive.\n\tif(!includesSyncLane(rootRenderLanes)){// This is not a sync update. Suspend. Since we're not activating a\n\t// Suspense boundary, this will unwind all the way to the root without\n\t// performing a second pass to render a fallback. (This is arguably how\n\t// refresh transitions should work, too, since we're not going to commit\n\t// the fallbacks anyway.)\n\t//\n\t// This case also applies to initial hydration.\n\tattachPingListener(root,wakeable,rootRenderLanes);renderDidSuspendDelayIfPossible();return;}// This is a sync/discrete update. We treat this case like an error\n\t// because discrete renders are expected to produce a complete tree\n\t// synchronously to maintain consistency with external state.\n\tvar uncaughtSuspenseError=new Error('A component suspended while responding to synchronous input. This '+'will cause the UI to be replaced with a loading indicator. To '+'fix, updates that suspend should be wrapped '+'with startTransition.');// If we're outside a transition, fall through to the regular error path.\n\t// The error will be caught by the nearest suspense boundary.\n\tvalue=uncaughtSuspenseError;}}else {// This is a regular error, not a Suspense wakeable.\n\tif(getIsHydrating()&&sourceFiber.mode&ConcurrentMode){markDidThrowWhileHydratingDEV();var _suspenseBoundary=getNearestSuspenseBoundaryToCapture(returnFiber);// If the error was thrown during hydration, we may be able to recover by\n\t// discarding the dehydrated content and switching to a client render.\n\t// Instead of surfacing the error, find the nearest Suspense boundary\n\t// and render it again without hydration.\n\tif(_suspenseBoundary!==null){if((_suspenseBoundary.flags&ShouldCapture)===NoFlags){// Set a flag to indicate that we should try rendering the normal\n\t// children again, not the fallback.\n\t_suspenseBoundary.flags|=ForceClientRender;}markSuspenseBoundaryShouldCapture(_suspenseBoundary,returnFiber,sourceFiber,root,rootRenderLanes);// Even though the user may not be affected by this error, we should\n\t// still log it so it can be fixed.\n\tqueueHydrationError(createCapturedValueAtFiber(value,sourceFiber));return;}}}value=createCapturedValueAtFiber(value,sourceFiber);renderDidError(value);// We didn't find a boundary that could handle this type of exception. Start\n\t// over and traverse parent path again, this time treating the exception\n\t// as an error.\n\tvar workInProgress=returnFiber;do{switch(workInProgress.tag){case HostRoot:{var _errorInfo=value;workInProgress.flags|=ShouldCapture;var lane=pickArbitraryLane(rootRenderLanes);workInProgress.lanes=mergeLanes(workInProgress.lanes,lane);var update=createRootErrorUpdate(workInProgress,_errorInfo,lane);enqueueCapturedUpdate(workInProgress,update);return;}case ClassComponent:// Capture and retry\n\tvar errorInfo=value;var ctor=workInProgress.type;var instance=workInProgress.stateNode;if((workInProgress.flags&DidCapture)===NoFlags&&(typeof ctor.getDerivedStateFromError==='function'||instance!==null&&typeof instance.componentDidCatch==='function'&&!isAlreadyFailedLegacyErrorBoundary(instance))){workInProgress.flags|=ShouldCapture;var _lane=pickArbitraryLane(rootRenderLanes);workInProgress.lanes=mergeLanes(workInProgress.lanes,_lane);// Schedule the error boundary to re-render using updated state\n\tvar _update=createClassErrorUpdate(workInProgress,errorInfo,_lane);enqueueCapturedUpdate(workInProgress,_update);return;}break;}workInProgress=workInProgress.return;}while(workInProgress!==null);}function getSuspendedCache(){{return null;}// This function is called when a Suspense boundary suspends. It returns the\n\t}var ReactCurrentOwner$1=ReactSharedInternals.ReactCurrentOwner;var didReceiveUpdate=false;var didWarnAboutBadClass;var didWarnAboutModulePatternComponent;var didWarnAboutContextTypeOnFunctionComponent;var didWarnAboutGetDerivedStateOnFunctionComponent;var didWarnAboutFunctionRefs;var didWarnAboutReassigningProps;var didWarnAboutRevealOrder;var didWarnAboutTailOptions;{didWarnAboutBadClass={};didWarnAboutModulePatternComponent={};didWarnAboutContextTypeOnFunctionComponent={};didWarnAboutGetDerivedStateOnFunctionComponent={};didWarnAboutFunctionRefs={};didWarnAboutReassigningProps=false;didWarnAboutRevealOrder={};didWarnAboutTailOptions={};}function reconcileChildren(current,workInProgress,nextChildren,renderLanes){if(current===null){// If this is a fresh new component that hasn't been rendered yet, we\n\t// won't update its child set by applying minimal side-effects. Instead,\n\t// we will add them all to the child before it gets rendered. That means\n\t// we can optimize this reconciliation pass by not tracking side-effects.\n\tworkInProgress.child=mountChildFibers(workInProgress,null,nextChildren,renderLanes);}else {// If the current child is the same as the work in progress, it means that\n\t// we haven't yet started any work on these children. Therefore, we use\n\t// the clone algorithm to create a copy of all the current children.\n\t// If we had any progressed work already, that is invalid at this point so\n\t// let's throw it out.\n\tworkInProgress.child=reconcileChildFibers(workInProgress,current.child,nextChildren,renderLanes);}}function forceUnmountCurrentAndReconcile(current,workInProgress,nextChildren,renderLanes){// This function is fork of reconcileChildren. It's used in cases where we\n\t// want to reconcile without matching against the existing set. This has the\n\t// effect of all current children being unmounted; even if the type and key\n\t// are the same, the old child is unmounted and a new child is created.\n\t//\n\t// To do this, we're going to go through the reconcile algorithm twice. In\n\t// the first pass, we schedule a deletion for all the current children by\n\t// passing null.\n\tworkInProgress.child=reconcileChildFibers(workInProgress,current.child,null,renderLanes);// In the second pass, we mount the new children. The trick here is that we\n\t// pass null in place of where we usually pass the current child set. This has\n\t// the effect of remounting all children regardless of whether their\n\t// identities match.\n\tworkInProgress.child=reconcileChildFibers(workInProgress,null,nextChildren,renderLanes);}function updateForwardRef(current,workInProgress,Component,nextProps,renderLanes){// TODO: current can be non-null here even if the component\n\t// hasn't yet mounted. This happens after the first render suspends.\n\t// We'll need to figure out if this is fine or can cause issues.\n\t{if(workInProgress.type!==workInProgress.elementType){// Lazy component props can't be validated in createElement\n\t// because they're only guaranteed to be resolved here.\n\tvar innerPropTypes=Component.propTypes;if(innerPropTypes){checkPropTypes(innerPropTypes,nextProps,// Resolved props\n\t'prop',getComponentNameFromType(Component));}}}var render=Component.render;var ref=workInProgress.ref;// The rest is a fork of updateFunctionComponent\n\tvar nextChildren;var hasId;prepareToReadContext(workInProgress,renderLanes);{markComponentRenderStarted(workInProgress);}{ReactCurrentOwner$1.current=workInProgress;setIsRendering(true);nextChildren=renderWithHooks(current,workInProgress,render,nextProps,ref,renderLanes);hasId=checkDidRenderIdHook();if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{nextChildren=renderWithHooks(current,workInProgress,render,nextProps,ref,renderLanes);hasId=checkDidRenderIdHook();}finally{setIsStrictModeForDevtools(false);}}setIsRendering(false);}{markComponentRenderStopped();}if(current!==null&&!didReceiveUpdate){bailoutHooks(current,workInProgress,renderLanes);return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}if(getIsHydrating()&&hasId){pushMaterializedTreeId(workInProgress);}// React DevTools reads this flag.\n\tworkInProgress.flags|=PerformedWork;reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function updateMemoComponent(current,workInProgress,Component,nextProps,renderLanes){if(current===null){var type=Component.type;if(isSimpleFunctionComponent(type)&&Component.compare===null&&// SimpleMemoComponent codepath doesn't resolve outer props either.\n\tComponent.defaultProps===undefined){var resolvedType=type;{resolvedType=resolveFunctionForHotReloading(type);}// If this is a plain function component without default props,\n\t// and with only the default shallow comparison, we upgrade it\n\t// to a SimpleMemoComponent to allow fast path updates.\n\tworkInProgress.tag=SimpleMemoComponent;workInProgress.type=resolvedType;{validateFunctionComponentInDev(workInProgress,type);}return updateSimpleMemoComponent(current,workInProgress,resolvedType,nextProps,renderLanes);}{var innerPropTypes=type.propTypes;if(innerPropTypes){// Inner memo component props aren't currently validated in createElement.\n\t// We could move it there, but we'd still need this for lazy code path.\n\tcheckPropTypes(innerPropTypes,nextProps,// Resolved props\n\t'prop',getComponentNameFromType(type));}}var child=createFiberFromTypeAndProps(Component.type,null,nextProps,workInProgress,workInProgress.mode,renderLanes);child.ref=workInProgress.ref;child.return=workInProgress;workInProgress.child=child;return child;}{var _type=Component.type;var _innerPropTypes=_type.propTypes;if(_innerPropTypes){// Inner memo component props aren't currently validated in createElement.\n\t// We could move it there, but we'd still need this for lazy code path.\n\tcheckPropTypes(_innerPropTypes,nextProps,// Resolved props\n\t'prop',getComponentNameFromType(_type));}}var currentChild=current.child;// This is always exactly one child\n\tvar hasScheduledUpdateOrContext=checkScheduledUpdateOrContext(current,renderLanes);if(!hasScheduledUpdateOrContext){// This will be the props with resolved defaultProps,\n\t// unlike current.memoizedProps which will be the unresolved ones.\n\tvar prevProps=currentChild.memoizedProps;// Default to shallow comparison\n\tvar compare=Component.compare;compare=compare!==null?compare:shallowEqual;if(compare(prevProps,nextProps)&&current.ref===workInProgress.ref){return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}}// React DevTools reads this flag.\n\tworkInProgress.flags|=PerformedWork;var newChild=createWorkInProgress(currentChild,nextProps);newChild.ref=workInProgress.ref;newChild.return=workInProgress;workInProgress.child=newChild;return newChild;}function updateSimpleMemoComponent(current,workInProgress,Component,nextProps,renderLanes){// TODO: current can be non-null here even if the component\n\t// hasn't yet mounted. This happens when the inner render suspends.\n\t// We'll need to figure out if this is fine or can cause issues.\n\t{if(workInProgress.type!==workInProgress.elementType){// Lazy component props can't be validated in createElement\n\t// because they're only guaranteed to be resolved here.\n\tvar outerMemoType=workInProgress.elementType;if(outerMemoType.$$typeof===REACT_LAZY_TYPE){// We warn when you define propTypes on lazy()\n\t// so let's just skip over it to find memo() outer wrapper.\n\t// Inner props for memo are validated later.\n\tvar lazyComponent=outerMemoType;var payload=lazyComponent._payload;var init=lazyComponent._init;try{outerMemoType=init(payload);}catch(x){outerMemoType=null;}// Inner propTypes will be validated in the function component path.\n\tvar outerPropTypes=outerMemoType&&outerMemoType.propTypes;if(outerPropTypes){checkPropTypes(outerPropTypes,nextProps,// Resolved (SimpleMemoComponent has no defaultProps)\n\t'prop',getComponentNameFromType(outerMemoType));}}}}if(current!==null){var prevProps=current.memoizedProps;if(shallowEqual(prevProps,nextProps)&&current.ref===workInProgress.ref&&// Prevent bailout if the implementation changed due to hot reload.\n\tworkInProgress.type===current.type){didReceiveUpdate=false;// The props are shallowly equal. Reuse the previous props object, like we\n\t// would during a normal fiber bailout.\n\t//\n\t// We don't have strong guarantees that the props object is referentially\n\t// equal during updates where we can't bail out anyway — like if the props\n\t// are shallowly equal, but there's a local state or context update in the\n\t// same batch.\n\t//\n\t// However, as a principle, we should aim to make the behavior consistent\n\t// across different ways of memoizing a component. For example, React.memo\n\t// has a different internal Fiber layout if you pass a normal function\n\t// component (SimpleMemoComponent) versus if you pass a different type\n\t// like forwardRef (MemoComponent). But this is an implementation detail.\n\t// Wrapping a component in forwardRef (or React.lazy, etc) shouldn't\n\t// affect whether the props object is reused during a bailout.\n\tworkInProgress.pendingProps=nextProps=prevProps;if(!checkScheduledUpdateOrContext(current,renderLanes)){// The pending lanes were cleared at the beginning of beginWork. We're\n\t// about to bail out, but there might be other lanes that weren't\n\t// included in the current render. Usually, the priority level of the\n\t// remaining updates is accumulated during the evaluation of the\n\t// component (i.e. when processing the update queue). But since since\n\t// we're bailing out early *without* evaluating the component, we need\n\t// to account for it here, too. Reset to the value of the current fiber.\n\t// NOTE: This only applies to SimpleMemoComponent, not MemoComponent,\n\t// because a MemoComponent fiber does not have hooks or an update queue;\n\t// rather, it wraps around an inner component, which may or may not\n\t// contains hooks.\n\t// TODO: Move the reset at in beginWork out of the common path so that\n\t// this is no longer necessary.\n\tworkInProgress.lanes=current.lanes;return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}else if((current.flags&ForceUpdateForLegacySuspense)!==NoFlags){// This is a special case that only exists for legacy mode.\n\t// See https://github.com/facebook/react/pull/19216.\n\tdidReceiveUpdate=true;}}}return updateFunctionComponent(current,workInProgress,Component,nextProps,renderLanes);}function updateOffscreenComponent(current,workInProgress,renderLanes){var nextProps=workInProgress.pendingProps;var nextChildren=nextProps.children;var prevState=current!==null?current.memoizedState:null;if(nextProps.mode==='hidden'||enableLegacyHidden){// Rendering a hidden tree.\n\tif((workInProgress.mode&ConcurrentMode)===NoMode){// In legacy sync mode, don't defer the subtree. Render it now.\n\t// TODO: Consider how Offscreen should work with transitions in the future\n\tvar nextState={baseLanes:NoLanes,cachePool:null,transitions:null};workInProgress.memoizedState=nextState;pushRenderLanes(workInProgress,renderLanes);}else if(!includesSomeLane(renderLanes,OffscreenLane)){var spawnedCachePool=null;// We're hidden, and we're not rendering at Offscreen. We will bail out\n\t// and resume this tree later.\n\tvar nextBaseLanes;if(prevState!==null){var prevBaseLanes=prevState.baseLanes;nextBaseLanes=mergeLanes(prevBaseLanes,renderLanes);}else {nextBaseLanes=renderLanes;}// Schedule this fiber to re-render at offscreen priority. Then bailout.\n\tworkInProgress.lanes=workInProgress.childLanes=laneToLanes(OffscreenLane);var _nextState={baseLanes:nextBaseLanes,cachePool:spawnedCachePool,transitions:null};workInProgress.memoizedState=_nextState;workInProgress.updateQueue=null;// to avoid a push/pop misalignment.\n\tpushRenderLanes(workInProgress,nextBaseLanes);return null;}else {// This is the second render. The surrounding visible content has already\n\t// committed. Now we resume rendering the hidden tree.\n\t// Rendering at offscreen, so we can clear the base lanes.\n\tvar _nextState2={baseLanes:NoLanes,cachePool:null,transitions:null};workInProgress.memoizedState=_nextState2;// Push the lanes that were skipped when we bailed out.\n\tvar subtreeRenderLanes=prevState!==null?prevState.baseLanes:renderLanes;pushRenderLanes(workInProgress,subtreeRenderLanes);}}else {// Rendering a visible tree.\n\tvar _subtreeRenderLanes;if(prevState!==null){// We're going from hidden -> visible.\n\t_subtreeRenderLanes=mergeLanes(prevState.baseLanes,renderLanes);workInProgress.memoizedState=null;}else {// We weren't previously hidden, and we still aren't, so there's nothing\n\t// special to do. Need to push to the stack regardless, though, to avoid\n\t// a push/pop misalignment.\n\t_subtreeRenderLanes=renderLanes;}pushRenderLanes(workInProgress,_subtreeRenderLanes);}reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}// Note: These happen to have identical begin phases, for now. We shouldn't hold\n\tfunction updateFragment(current,workInProgress,renderLanes){var nextChildren=workInProgress.pendingProps;reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function updateMode(current,workInProgress,renderLanes){var nextChildren=workInProgress.pendingProps.children;reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function updateProfiler(current,workInProgress,renderLanes){{workInProgress.flags|=Update;{// Reset effect durations for the next eventual effect phase.\n\t// These are reset during render to allow the DevTools commit hook a chance to read them,\n\tvar stateNode=workInProgress.stateNode;stateNode.effectDuration=0;stateNode.passiveEffectDuration=0;}}var nextProps=workInProgress.pendingProps;var nextChildren=nextProps.children;reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function markRef(current,workInProgress){var ref=workInProgress.ref;if(current===null&&ref!==null||current!==null&&current.ref!==ref){// Schedule a Ref effect\n\tworkInProgress.flags|=Ref;{workInProgress.flags|=RefStatic;}}}function updateFunctionComponent(current,workInProgress,Component,nextProps,renderLanes){{if(workInProgress.type!==workInProgress.elementType){// Lazy component props can't be validated in createElement\n\t// because they're only guaranteed to be resolved here.\n\tvar innerPropTypes=Component.propTypes;if(innerPropTypes){checkPropTypes(innerPropTypes,nextProps,// Resolved props\n\t'prop',getComponentNameFromType(Component));}}}var context;{var unmaskedContext=getUnmaskedContext(workInProgress,Component,true);context=getMaskedContext(workInProgress,unmaskedContext);}var nextChildren;var hasId;prepareToReadContext(workInProgress,renderLanes);{markComponentRenderStarted(workInProgress);}{ReactCurrentOwner$1.current=workInProgress;setIsRendering(true);nextChildren=renderWithHooks(current,workInProgress,Component,nextProps,context,renderLanes);hasId=checkDidRenderIdHook();if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{nextChildren=renderWithHooks(current,workInProgress,Component,nextProps,context,renderLanes);hasId=checkDidRenderIdHook();}finally{setIsStrictModeForDevtools(false);}}setIsRendering(false);}{markComponentRenderStopped();}if(current!==null&&!didReceiveUpdate){bailoutHooks(current,workInProgress,renderLanes);return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}if(getIsHydrating()&&hasId){pushMaterializedTreeId(workInProgress);}// React DevTools reads this flag.\n\tworkInProgress.flags|=PerformedWork;reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function updateClassComponent(current,workInProgress,Component,nextProps,renderLanes){{// This is used by DevTools to force a boundary to error.\n\tswitch(shouldError(workInProgress)){case false:{var _instance=workInProgress.stateNode;var ctor=workInProgress.type;// TODO This way of resetting the error boundary state is a hack.\n\t// Is there a better way to do this?\n\tvar tempInstance=new ctor(workInProgress.memoizedProps,_instance.context);var state=tempInstance.state;_instance.updater.enqueueSetState(_instance,state,null);break;}case true:{workInProgress.flags|=DidCapture;workInProgress.flags|=ShouldCapture;// eslint-disable-next-line react-internal/prod-error-codes\n\tvar error$1=new Error('Simulated error coming from DevTools');var lane=pickArbitraryLane(renderLanes);workInProgress.lanes=mergeLanes(workInProgress.lanes,lane);// Schedule the error boundary to re-render using updated state\n\tvar update=createClassErrorUpdate(workInProgress,createCapturedValueAtFiber(error$1,workInProgress),lane);enqueueCapturedUpdate(workInProgress,update);break;}}if(workInProgress.type!==workInProgress.elementType){// Lazy component props can't be validated in createElement\n\t// because they're only guaranteed to be resolved here.\n\tvar innerPropTypes=Component.propTypes;if(innerPropTypes){checkPropTypes(innerPropTypes,nextProps,// Resolved props\n\t'prop',getComponentNameFromType(Component));}}}// Push context providers early to prevent context stack mismatches.\n\t// During mounting we don't know the child context yet as the instance doesn't exist.\n\t// We will invalidate the child context in finishClassComponent() right after rendering.\n\tvar hasContext;if(isContextProvider(Component)){hasContext=true;pushContextProvider(workInProgress);}else {hasContext=false;}prepareToReadContext(workInProgress,renderLanes);var instance=workInProgress.stateNode;var shouldUpdate;if(instance===null){resetSuspendedCurrentOnMountInLegacyMode(current,workInProgress);// In the initial pass we might need to construct the instance.\n\tconstructClassInstance(workInProgress,Component,nextProps);mountClassInstance(workInProgress,Component,nextProps,renderLanes);shouldUpdate=true;}else if(current===null){// In a resume, we'll already have an instance we can reuse.\n\tshouldUpdate=resumeMountClassInstance(workInProgress,Component,nextProps,renderLanes);}else {shouldUpdate=updateClassInstance(current,workInProgress,Component,nextProps,renderLanes);}var nextUnitOfWork=finishClassComponent(current,workInProgress,Component,shouldUpdate,hasContext,renderLanes);{var inst=workInProgress.stateNode;if(shouldUpdate&&inst.props!==nextProps){if(!didWarnAboutReassigningProps){error('It looks like %s is reassigning its own `this.props` while rendering. '+'This is not supported and can lead to confusing bugs.',getComponentNameFromFiber(workInProgress)||'a component');}didWarnAboutReassigningProps=true;}}return nextUnitOfWork;}function finishClassComponent(current,workInProgress,Component,shouldUpdate,hasContext,renderLanes){// Refs should update even if shouldComponentUpdate returns false\n\tmarkRef(current,workInProgress);var didCaptureError=(workInProgress.flags&DidCapture)!==NoFlags;if(!shouldUpdate&&!didCaptureError){// Context providers should defer to sCU for rendering\n\tif(hasContext){invalidateContextProvider(workInProgress,Component,false);}return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}var instance=workInProgress.stateNode;// Rerender\n\tReactCurrentOwner$1.current=workInProgress;var nextChildren;if(didCaptureError&&typeof Component.getDerivedStateFromError!=='function'){// If we captured an error, but getDerivedStateFromError is not defined,\n\t// unmount all the children. componentDidCatch will schedule an update to\n\t// re-render a fallback. This is temporary until we migrate everyone to\n\t// the new API.\n\t// TODO: Warn in a future release.\n\tnextChildren=null;{stopProfilerTimerIfRunning();}}else {{markComponentRenderStarted(workInProgress);}{setIsRendering(true);nextChildren=instance.render();if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{instance.render();}finally{setIsStrictModeForDevtools(false);}}setIsRendering(false);}{markComponentRenderStopped();}}// React DevTools reads this flag.\n\tworkInProgress.flags|=PerformedWork;if(current!==null&&didCaptureError){// If we're recovering from an error, reconcile without reusing any of\n\t// the existing children. Conceptually, the normal children and the children\n\t// that are shown on error are two different sets, so we shouldn't reuse\n\t// normal children even if their identities match.\n\tforceUnmountCurrentAndReconcile(current,workInProgress,nextChildren,renderLanes);}else {reconcileChildren(current,workInProgress,nextChildren,renderLanes);}// Memoize state using the values we just used to render.\n\t// TODO: Restructure so we never read values from the instance.\n\tworkInProgress.memoizedState=instance.state;// The context might have changed so we need to recalculate it.\n\tif(hasContext){invalidateContextProvider(workInProgress,Component,true);}return workInProgress.child;}function pushHostRootContext(workInProgress){var root=workInProgress.stateNode;if(root.pendingContext){pushTopLevelContextObject(workInProgress,root.pendingContext,root.pendingContext!==root.context);}else if(root.context){// Should always be set\n\tpushTopLevelContextObject(workInProgress,root.context,false);}pushHostContainer(workInProgress,root.containerInfo);}function updateHostRoot(current,workInProgress,renderLanes){pushHostRootContext(workInProgress);if(current===null){throw new Error('Should have a current fiber. This is a bug in React.');}var nextProps=workInProgress.pendingProps;var prevState=workInProgress.memoizedState;var prevChildren=prevState.element;cloneUpdateQueue(current,workInProgress);processUpdateQueue(workInProgress,nextProps,null,renderLanes);var nextState=workInProgress.memoizedState;workInProgress.stateNode;// being called \"element\".\n\tvar nextChildren=nextState.element;if(prevState.isDehydrated){// This is a hydration root whose shell has not yet hydrated. We should\n\t// attempt to hydrate.\n\t// Flip isDehydrated to false to indicate that when this render\n\t// finishes, the root will no longer be dehydrated.\n\tvar overrideState={element:nextChildren,isDehydrated:false,cache:nextState.cache,pendingSuspenseBoundaries:nextState.pendingSuspenseBoundaries,transitions:nextState.transitions};var updateQueue=workInProgress.updateQueue;// `baseState` can always be the last state because the root doesn't\n\t// have reducer functions so it doesn't need rebasing.\n\tupdateQueue.baseState=overrideState;workInProgress.memoizedState=overrideState;if(workInProgress.flags&ForceClientRender){// Something errored during a previous attempt to hydrate the shell, so we\n\t// forced a client render.\n\tvar recoverableError=createCapturedValueAtFiber(new Error('There was an error while hydrating. Because the error happened outside '+'of a Suspense boundary, the entire root will switch to '+'client rendering.'),workInProgress);return mountHostRootWithoutHydrating(current,workInProgress,nextChildren,renderLanes,recoverableError);}else if(nextChildren!==prevChildren){var _recoverableError=createCapturedValueAtFiber(new Error('This root received an early update, before anything was able '+'hydrate. Switched the entire root to client rendering.'),workInProgress);return mountHostRootWithoutHydrating(current,workInProgress,nextChildren,renderLanes,_recoverableError);}else {// The outermost shell has not hydrated yet. Start hydrating.\n\tenterHydrationState(workInProgress);var child=mountChildFibers(workInProgress,null,nextChildren,renderLanes);workInProgress.child=child;var node=child;while(node){// Mark each child as hydrating. This is a fast path to know whether this\n\t// tree is part of a hydrating tree. This is used to determine if a child\n\t// node has fully mounted yet, and for scheduling event replaying.\n\t// Conceptually this is similar to Placement in that a new subtree is\n\t// inserted into the React tree here. It just happens to not need DOM\n\t// mutations because it already exists.\n\tnode.flags=node.flags&~Placement|Hydrating;node=node.sibling;}}}else {// Root is not dehydrated. Either this is a client-only root, or it\n\t// already hydrated.\n\tresetHydrationState();if(nextChildren===prevChildren){return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}reconcileChildren(current,workInProgress,nextChildren,renderLanes);}return workInProgress.child;}function mountHostRootWithoutHydrating(current,workInProgress,nextChildren,renderLanes,recoverableError){// Revert to client rendering.\n\tresetHydrationState();queueHydrationError(recoverableError);workInProgress.flags|=ForceClientRender;reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function updateHostComponent(current,workInProgress,renderLanes){pushHostContext(workInProgress);if(current===null){tryToClaimNextHydratableInstance(workInProgress);}var type=workInProgress.type;var nextProps=workInProgress.pendingProps;var prevProps=current!==null?current.memoizedProps:null;var nextChildren=nextProps.children;var isDirectTextChild=shouldSetTextContent(type,nextProps);if(isDirectTextChild){// We special case a direct text child of a host node. This is a common\n\t// case. We won't handle it as a reified child. We will instead handle\n\t// this in the host environment that also has access to this prop. That\n\t// avoids allocating another HostText fiber and traversing it.\n\tnextChildren=null;}else if(prevProps!==null&&shouldSetTextContent(type,prevProps)){// If we're switching from a direct text child to a normal child, or to\n\t// empty, we need to schedule the text content to be reset.\n\tworkInProgress.flags|=ContentReset;}markRef(current,workInProgress);reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child;}function updateHostText(current,workInProgress){if(current===null){tryToClaimNextHydratableInstance(workInProgress);}// Nothing to do here. This is terminal. We'll do the completion step\n\t// immediately after.\n\treturn null;}function mountLazyComponent(_current,workInProgress,elementType,renderLanes){resetSuspendedCurrentOnMountInLegacyMode(_current,workInProgress);var props=workInProgress.pendingProps;var lazyComponent=elementType;var payload=lazyComponent._payload;var init=lazyComponent._init;var Component=init(payload);// Store the unwrapped component in the type.\n\tworkInProgress.type=Component;var resolvedTag=workInProgress.tag=resolveLazyComponentTag(Component);var resolvedProps=resolveDefaultProps(Component,props);var child;switch(resolvedTag){case FunctionComponent:{{validateFunctionComponentInDev(workInProgress,Component);workInProgress.type=Component=resolveFunctionForHotReloading(Component);}child=updateFunctionComponent(null,workInProgress,Component,resolvedProps,renderLanes);return child;}case ClassComponent:{{workInProgress.type=Component=resolveClassForHotReloading(Component);}child=updateClassComponent(null,workInProgress,Component,resolvedProps,renderLanes);return child;}case ForwardRef:{{workInProgress.type=Component=resolveForwardRefForHotReloading(Component);}child=updateForwardRef(null,workInProgress,Component,resolvedProps,renderLanes);return child;}case MemoComponent:{{if(workInProgress.type!==workInProgress.elementType){var outerPropTypes=Component.propTypes;if(outerPropTypes){checkPropTypes(outerPropTypes,resolvedProps,// Resolved for outer only\n\t'prop',getComponentNameFromType(Component));}}}child=updateMemoComponent(null,workInProgress,Component,resolveDefaultProps(Component.type,resolvedProps),// The inner type can have defaults too\n\trenderLanes);return child;}}var hint='';{if(Component!==null&&typeof Component==='object'&&Component.$$typeof===REACT_LAZY_TYPE){hint=' Did you wrap a component in React.lazy() more than once?';}}// This message intentionally doesn't mention ForwardRef or MemoComponent\n\t// because the fact that it's a separate type of work is an\n\t// implementation detail.\n\tthrow new Error(\"Element type is invalid. Received a promise that resolves to: \"+Component+\". \"+(\"Lazy element type must resolve to a class or function.\"+hint));}function mountIncompleteClassComponent(_current,workInProgress,Component,nextProps,renderLanes){resetSuspendedCurrentOnMountInLegacyMode(_current,workInProgress);// Promote the fiber to a class and try rendering again.\n\tworkInProgress.tag=ClassComponent;// The rest of this function is a fork of `updateClassComponent`\n\t// Push context providers early to prevent context stack mismatches.\n\t// During mounting we don't know the child context yet as the instance doesn't exist.\n\t// We will invalidate the child context in finishClassComponent() right after rendering.\n\tvar hasContext;if(isContextProvider(Component)){hasContext=true;pushContextProvider(workInProgress);}else {hasContext=false;}prepareToReadContext(workInProgress,renderLanes);constructClassInstance(workInProgress,Component,nextProps);mountClassInstance(workInProgress,Component,nextProps,renderLanes);return finishClassComponent(null,workInProgress,Component,true,hasContext,renderLanes);}function mountIndeterminateComponent(_current,workInProgress,Component,renderLanes){resetSuspendedCurrentOnMountInLegacyMode(_current,workInProgress);var props=workInProgress.pendingProps;var context;{var unmaskedContext=getUnmaskedContext(workInProgress,Component,false);context=getMaskedContext(workInProgress,unmaskedContext);}prepareToReadContext(workInProgress,renderLanes);var value;var hasId;{markComponentRenderStarted(workInProgress);}{if(Component.prototype&&typeof Component.prototype.render==='function'){var componentName=getComponentNameFromType(Component)||'Unknown';if(!didWarnAboutBadClass[componentName]){error(\"The <%s /> component appears to have a render method, but doesn't extend React.Component. \"+'This is likely to cause errors. Change %s to extend React.Component instead.',componentName,componentName);didWarnAboutBadClass[componentName]=true;}}if(workInProgress.mode&StrictLegacyMode){ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress,null);}setIsRendering(true);ReactCurrentOwner$1.current=workInProgress;value=renderWithHooks(null,workInProgress,Component,props,context,renderLanes);hasId=checkDidRenderIdHook();setIsRendering(false);}{markComponentRenderStopped();}// React DevTools reads this flag.\n\tworkInProgress.flags|=PerformedWork;{// Support for module components is deprecated and is removed behind a flag.\n\t// Whether or not it would crash later, we want to show a good message in DEV first.\n\tif(typeof value==='object'&&value!==null&&typeof value.render==='function'&&value.$$typeof===undefined){var _componentName=getComponentNameFromType(Component)||'Unknown';if(!didWarnAboutModulePatternComponent[_componentName]){error('The <%s /> component appears to be a function component that returns a class instance. '+'Change %s to a class that extends React.Component instead. '+\"If you can't use a class try assigning the prototype on the function as a workaround. \"+\"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it \"+'cannot be called with `new` by React.',_componentName,_componentName,_componentName);didWarnAboutModulePatternComponent[_componentName]=true;}}}if(// Run these checks in production only if the flag is off.\n\t// Eventually we'll delete this branch altogether.\n\ttypeof value==='object'&&value!==null&&typeof value.render==='function'&&value.$$typeof===undefined){{var _componentName2=getComponentNameFromType(Component)||'Unknown';if(!didWarnAboutModulePatternComponent[_componentName2]){error('The <%s /> component appears to be a function component that returns a class instance. '+'Change %s to a class that extends React.Component instead. '+\"If you can't use a class try assigning the prototype on the function as a workaround. \"+\"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it \"+'cannot be called with `new` by React.',_componentName2,_componentName2,_componentName2);didWarnAboutModulePatternComponent[_componentName2]=true;}}// Proceed under the assumption that this is a class instance\n\tworkInProgress.tag=ClassComponent;// Throw out any hooks that were used.\n\tworkInProgress.memoizedState=null;workInProgress.updateQueue=null;// Push context providers early to prevent context stack mismatches.\n\t// During mounting we don't know the child context yet as the instance doesn't exist.\n\t// We will invalidate the child context in finishClassComponent() right after rendering.\n\tvar hasContext=false;if(isContextProvider(Component)){hasContext=true;pushContextProvider(workInProgress);}else {hasContext=false;}workInProgress.memoizedState=value.state!==null&&value.state!==undefined?value.state:null;initializeUpdateQueue(workInProgress);adoptClassInstance(workInProgress,value);mountClassInstance(workInProgress,Component,props,renderLanes);return finishClassComponent(null,workInProgress,Component,true,hasContext,renderLanes);}else {// Proceed under the assumption that this is a function component\n\tworkInProgress.tag=FunctionComponent;{if(workInProgress.mode&StrictLegacyMode){setIsStrictModeForDevtools(true);try{value=renderWithHooks(null,workInProgress,Component,props,context,renderLanes);hasId=checkDidRenderIdHook();}finally{setIsStrictModeForDevtools(false);}}}if(getIsHydrating()&&hasId){pushMaterializedTreeId(workInProgress);}reconcileChildren(null,workInProgress,value,renderLanes);{validateFunctionComponentInDev(workInProgress,Component);}return workInProgress.child;}}function validateFunctionComponentInDev(workInProgress,Component){{if(Component){if(Component.childContextTypes){error('%s(...): childContextTypes cannot be defined on a function component.',Component.displayName||Component.name||'Component');}}if(workInProgress.ref!==null){var info='';var ownerName=getCurrentFiberOwnerNameInDevOrNull();if(ownerName){info+='\\n\\nCheck the render method of `'+ownerName+'`.';}var warningKey=ownerName||'';var debugSource=workInProgress._debugSource;if(debugSource){warningKey=debugSource.fileName+':'+debugSource.lineNumber;}if(!didWarnAboutFunctionRefs[warningKey]){didWarnAboutFunctionRefs[warningKey]=true;error('Function components cannot be given refs. '+'Attempts to access this ref will fail. '+'Did you mean to use React.forwardRef()?%s',info);}}if(typeof Component.getDerivedStateFromProps==='function'){var _componentName3=getComponentNameFromType(Component)||'Unknown';if(!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]){error('%s: Function components do not support getDerivedStateFromProps.',_componentName3);didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]=true;}}if(typeof Component.contextType==='object'&&Component.contextType!==null){var _componentName4=getComponentNameFromType(Component)||'Unknown';if(!didWarnAboutContextTypeOnFunctionComponent[_componentName4]){error('%s: Function components do not support contextType.',_componentName4);didWarnAboutContextTypeOnFunctionComponent[_componentName4]=true;}}}}var SUSPENDED_MARKER={dehydrated:null,treeContext:null,retryLane:NoLane};function mountSuspenseOffscreenState(renderLanes){return {baseLanes:renderLanes,cachePool:getSuspendedCache(),transitions:null};}function updateSuspenseOffscreenState(prevOffscreenState,renderLanes){var cachePool=null;return {baseLanes:mergeLanes(prevOffscreenState.baseLanes,renderLanes),cachePool:cachePool,transitions:prevOffscreenState.transitions};}// TODO: Probably should inline this back\n\tfunction shouldRemainOnFallback(suspenseContext,current,workInProgress,renderLanes){// If we're already showing a fallback, there are cases where we need to\n\t// remain on that fallback regardless of whether the content has resolved.\n\t// For example, SuspenseList coordinates when nested content appears.\n\tif(current!==null){var suspenseState=current.memoizedState;if(suspenseState===null){// Currently showing content. Don't hide it, even if ForceSuspenseFallback\n\t// is true. More precise name might be \"ForceRemainSuspenseFallback\".\n\t// Note: This is a factoring smell. Can't remain on a fallback if there's\n\t// no fallback to remain on.\n\treturn false;}}// Not currently showing content. Consult the Suspense context.\n\treturn hasSuspenseContext(suspenseContext,ForceSuspenseFallback);}function getRemainingWorkInPrimaryTree(current,renderLanes){// TODO: Should not remove render lanes that were pinged during this render\n\treturn removeLanes(current.childLanes,renderLanes);}function updateSuspenseComponent(current,workInProgress,renderLanes){var nextProps=workInProgress.pendingProps;// This is used by DevTools to force a boundary to suspend.\n\t{if(shouldSuspend(workInProgress)){workInProgress.flags|=DidCapture;}}var suspenseContext=suspenseStackCursor.current;var showFallback=false;var didSuspend=(workInProgress.flags&DidCapture)!==NoFlags;if(didSuspend||shouldRemainOnFallback(suspenseContext,current)){// Something in this boundary's subtree already suspended. Switch to\n\t// rendering the fallback children.\n\tshowFallback=true;workInProgress.flags&=~DidCapture;}else {// Attempting the main content\n\tif(current===null||current.memoizedState!==null){// This is a new mount or this boundary is already showing a fallback state.\n\t// Mark this subtree context as having at least one invisible parent that could\n\t// handle the fallback state.\n\t// Avoided boundaries are not considered since they cannot handle preferred fallback states.\n\t{suspenseContext=addSubtreeSuspenseContext(suspenseContext,InvisibleParentSuspenseContext);}}}suspenseContext=setDefaultShallowSuspenseContext(suspenseContext);pushSuspenseContext(workInProgress,suspenseContext);// OK, the next part is confusing. We're about to reconcile the Suspense\n\t// boundary's children. This involves some custom reconciliation logic. Two\n\t// main reasons this is so complicated.\n\t//\n\t// First, Legacy Mode has different semantics for backwards compatibility. The\n\t// primary tree will commit in an inconsistent state, so when we do the\n\t// second pass to render the fallback, we do some exceedingly, uh, clever\n\t// hacks to make that not totally break. Like transferring effects and\n\t// deletions from hidden tree. In Concurrent Mode, it's much simpler,\n\t// because we bailout on the primary tree completely and leave it in its old\n\t// state, no effects. Same as what we do for Offscreen (except that\n\t// Offscreen doesn't have the first render pass).\n\t//\n\t// Second is hydration. During hydration, the Suspense fiber has a slightly\n\t// different layout, where the child points to a dehydrated fragment, which\n\t// contains the DOM rendered by the server.\n\t//\n\t// Third, even if you set all that aside, Suspense is like error boundaries in\n\t// that we first we try to render one tree, and if that fails, we render again\n\t// and switch to a different tree. Like a try/catch block. So we have to track\n\t// which branch we're currently rendering. Ideally we would model this using\n\t// a stack.\n\tif(current===null){// Initial mount\n\t// Special path for hydration\n\t// If we're currently hydrating, try to hydrate this boundary.\n\ttryToClaimNextHydratableInstance(workInProgress);// This could've been a dehydrated suspense component.\n\tvar suspenseState=workInProgress.memoizedState;if(suspenseState!==null){var dehydrated=suspenseState.dehydrated;if(dehydrated!==null){return mountDehydratedSuspenseComponent(workInProgress,dehydrated);}}var nextPrimaryChildren=nextProps.children;var nextFallbackChildren=nextProps.fallback;if(showFallback){var fallbackFragment=mountSuspenseFallbackChildren(workInProgress,nextPrimaryChildren,nextFallbackChildren,renderLanes);var primaryChildFragment=workInProgress.child;primaryChildFragment.memoizedState=mountSuspenseOffscreenState(renderLanes);workInProgress.memoizedState=SUSPENDED_MARKER;return fallbackFragment;}else {return mountSuspensePrimaryChildren(workInProgress,nextPrimaryChildren);}}else {// This is an update.\n\t// Special path for hydration\n\tvar prevState=current.memoizedState;if(prevState!==null){var _dehydrated=prevState.dehydrated;if(_dehydrated!==null){return updateDehydratedSuspenseComponent(current,workInProgress,didSuspend,nextProps,_dehydrated,prevState,renderLanes);}}if(showFallback){var _nextFallbackChildren=nextProps.fallback;var _nextPrimaryChildren=nextProps.children;var fallbackChildFragment=updateSuspenseFallbackChildren(current,workInProgress,_nextPrimaryChildren,_nextFallbackChildren,renderLanes);var _primaryChildFragment2=workInProgress.child;var prevOffscreenState=current.child.memoizedState;_primaryChildFragment2.memoizedState=prevOffscreenState===null?mountSuspenseOffscreenState(renderLanes):updateSuspenseOffscreenState(prevOffscreenState,renderLanes);_primaryChildFragment2.childLanes=getRemainingWorkInPrimaryTree(current,renderLanes);workInProgress.memoizedState=SUSPENDED_MARKER;return fallbackChildFragment;}else {var _nextPrimaryChildren2=nextProps.children;var _primaryChildFragment3=updateSuspensePrimaryChildren(current,workInProgress,_nextPrimaryChildren2,renderLanes);workInProgress.memoizedState=null;return _primaryChildFragment3;}}}function mountSuspensePrimaryChildren(workInProgress,primaryChildren,renderLanes){var mode=workInProgress.mode;var primaryChildProps={mode:'visible',children:primaryChildren};var primaryChildFragment=mountWorkInProgressOffscreenFiber(primaryChildProps,mode);primaryChildFragment.return=workInProgress;workInProgress.child=primaryChildFragment;return primaryChildFragment;}function mountSuspenseFallbackChildren(workInProgress,primaryChildren,fallbackChildren,renderLanes){var mode=workInProgress.mode;var progressedPrimaryFragment=workInProgress.child;var primaryChildProps={mode:'hidden',children:primaryChildren};var primaryChildFragment;var fallbackChildFragment;if((mode&ConcurrentMode)===NoMode&&progressedPrimaryFragment!==null){// In legacy mode, we commit the primary tree as if it successfully\n\t// completed, even though it's in an inconsistent state.\n\tprimaryChildFragment=progressedPrimaryFragment;primaryChildFragment.childLanes=NoLanes;primaryChildFragment.pendingProps=primaryChildProps;if(workInProgress.mode&ProfileMode){// Reset the durations from the first pass so they aren't included in the\n\t// final amounts. This seems counterintuitive, since we're intentionally\n\t// not measuring part of the render phase, but this makes it match what we\n\t// do in Concurrent Mode.\n\tprimaryChildFragment.actualDuration=0;primaryChildFragment.actualStartTime=-1;primaryChildFragment.selfBaseDuration=0;primaryChildFragment.treeBaseDuration=0;}fallbackChildFragment=createFiberFromFragment(fallbackChildren,mode,renderLanes,null);}else {primaryChildFragment=mountWorkInProgressOffscreenFiber(primaryChildProps,mode);fallbackChildFragment=createFiberFromFragment(fallbackChildren,mode,renderLanes,null);}primaryChildFragment.return=workInProgress;fallbackChildFragment.return=workInProgress;primaryChildFragment.sibling=fallbackChildFragment;workInProgress.child=primaryChildFragment;return fallbackChildFragment;}function mountWorkInProgressOffscreenFiber(offscreenProps,mode,renderLanes){// The props argument to `createFiberFromOffscreen` is `any` typed, so we use\n\t// this wrapper function to constrain it.\n\treturn createFiberFromOffscreen(offscreenProps,mode,NoLanes,null);}function updateWorkInProgressOffscreenFiber(current,offscreenProps){// The props argument to `createWorkInProgress` is `any` typed, so we use this\n\t// wrapper function to constrain it.\n\treturn createWorkInProgress(current,offscreenProps);}function updateSuspensePrimaryChildren(current,workInProgress,primaryChildren,renderLanes){var currentPrimaryChildFragment=current.child;var currentFallbackChildFragment=currentPrimaryChildFragment.sibling;var primaryChildFragment=updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment,{mode:'visible',children:primaryChildren});if((workInProgress.mode&ConcurrentMode)===NoMode){primaryChildFragment.lanes=renderLanes;}primaryChildFragment.return=workInProgress;primaryChildFragment.sibling=null;if(currentFallbackChildFragment!==null){// Delete the fallback child fragment\n\tvar deletions=workInProgress.deletions;if(deletions===null){workInProgress.deletions=[currentFallbackChildFragment];workInProgress.flags|=ChildDeletion;}else {deletions.push(currentFallbackChildFragment);}}workInProgress.child=primaryChildFragment;return primaryChildFragment;}function updateSuspenseFallbackChildren(current,workInProgress,primaryChildren,fallbackChildren,renderLanes){var mode=workInProgress.mode;var currentPrimaryChildFragment=current.child;var currentFallbackChildFragment=currentPrimaryChildFragment.sibling;var primaryChildProps={mode:'hidden',children:primaryChildren};var primaryChildFragment;if(// In legacy mode, we commit the primary tree as if it successfully\n\t// completed, even though it's in an inconsistent state.\n\t(mode&ConcurrentMode)===NoMode&&// Make sure we're on the second pass, i.e. the primary child fragment was\n\t// already cloned. In legacy mode, the only case where this isn't true is\n\t// when DevTools forces us to display a fallback; we skip the first render\n\t// pass entirely and go straight to rendering the fallback. (In Concurrent\n\t// Mode, SuspenseList can also trigger this scenario, but this is a legacy-\n\t// only codepath.)\n\tworkInProgress.child!==currentPrimaryChildFragment){var progressedPrimaryFragment=workInProgress.child;primaryChildFragment=progressedPrimaryFragment;primaryChildFragment.childLanes=NoLanes;primaryChildFragment.pendingProps=primaryChildProps;if(workInProgress.mode&ProfileMode){// Reset the durations from the first pass so they aren't included in the\n\t// final amounts. This seems counterintuitive, since we're intentionally\n\t// not measuring part of the render phase, but this makes it match what we\n\t// do in Concurrent Mode.\n\tprimaryChildFragment.actualDuration=0;primaryChildFragment.actualStartTime=-1;primaryChildFragment.selfBaseDuration=currentPrimaryChildFragment.selfBaseDuration;primaryChildFragment.treeBaseDuration=currentPrimaryChildFragment.treeBaseDuration;}// The fallback fiber was added as a deletion during the first pass.\n\t// However, since we're going to remain on the fallback, we no longer want\n\t// to delete it.\n\tworkInProgress.deletions=null;}else {primaryChildFragment=updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment,primaryChildProps);// Since we're reusing a current tree, we need to reuse the flags, too.\n\t// (We don't do this in legacy mode, because in legacy mode we don't re-use\n\t// the current tree; see previous branch.)\n\tprimaryChildFragment.subtreeFlags=currentPrimaryChildFragment.subtreeFlags&StaticMask;}var fallbackChildFragment;if(currentFallbackChildFragment!==null){fallbackChildFragment=createWorkInProgress(currentFallbackChildFragment,fallbackChildren);}else {fallbackChildFragment=createFiberFromFragment(fallbackChildren,mode,renderLanes,null);// Needs a placement effect because the parent (the Suspense boundary) already\n\t// mounted but this is a new fiber.\n\tfallbackChildFragment.flags|=Placement;}fallbackChildFragment.return=workInProgress;primaryChildFragment.return=workInProgress;primaryChildFragment.sibling=fallbackChildFragment;workInProgress.child=primaryChildFragment;return fallbackChildFragment;}function retrySuspenseComponentWithoutHydrating(current,workInProgress,renderLanes,recoverableError){// Falling back to client rendering. Because this has performance\n\t// implications, it's considered a recoverable error, even though the user\n\t// likely won't observe anything wrong with the UI.\n\t//\n\t// The error is passed in as an argument to enforce that every caller provide\n\t// a custom message, or explicitly opt out (currently the only path that opts\n\t// out is legacy mode; every concurrent path provides an error).\n\tif(recoverableError!==null){queueHydrationError(recoverableError);}// This will add the old fiber to the deletion list\n\treconcileChildFibers(workInProgress,current.child,null,renderLanes);// We're now not suspended nor dehydrated.\n\tvar nextProps=workInProgress.pendingProps;var primaryChildren=nextProps.children;var primaryChildFragment=mountSuspensePrimaryChildren(workInProgress,primaryChildren);// Needs a placement effect because the parent (the Suspense boundary) already\n\t// mounted but this is a new fiber.\n\tprimaryChildFragment.flags|=Placement;workInProgress.memoizedState=null;return primaryChildFragment;}function mountSuspenseFallbackAfterRetryWithoutHydrating(current,workInProgress,primaryChildren,fallbackChildren,renderLanes){var fiberMode=workInProgress.mode;var primaryChildProps={mode:'visible',children:primaryChildren};var primaryChildFragment=mountWorkInProgressOffscreenFiber(primaryChildProps,fiberMode);var fallbackChildFragment=createFiberFromFragment(fallbackChildren,fiberMode,renderLanes,null);// Needs a placement effect because the parent (the Suspense\n\t// boundary) already mounted but this is a new fiber.\n\tfallbackChildFragment.flags|=Placement;primaryChildFragment.return=workInProgress;fallbackChildFragment.return=workInProgress;primaryChildFragment.sibling=fallbackChildFragment;workInProgress.child=primaryChildFragment;if((workInProgress.mode&ConcurrentMode)!==NoMode){// We will have dropped the effect list which contains the\n\t// deletion. We need to reconcile to delete the current child.\n\treconcileChildFibers(workInProgress,current.child,null,renderLanes);}return fallbackChildFragment;}function mountDehydratedSuspenseComponent(workInProgress,suspenseInstance,renderLanes){// During the first pass, we'll bail out and not drill into the children.\n\t// Instead, we'll leave the content in place and try to hydrate it later.\n\tif((workInProgress.mode&ConcurrentMode)===NoMode){{error('Cannot hydrate Suspense in legacy mode. Switch from '+'ReactDOM.hydrate(element, container) to '+'ReactDOMClient.hydrateRoot(container, <App />)'+'.render(element) or remove the Suspense components from '+'the server rendered components.');}workInProgress.lanes=laneToLanes(SyncLane);}else if(isSuspenseInstanceFallback(suspenseInstance)){// This is a client-only boundary. Since we won't get any content from the server\n\t// for this, we need to schedule that at a higher priority based on when it would\n\t// have timed out. In theory we could render it in this pass but it would have the\n\t// wrong priority associated with it and will prevent hydration of parent path.\n\t// Instead, we'll leave work left on it to render it in a separate commit.\n\t// TODO This time should be the time at which the server rendered response that is\n\t// a parent to this boundary was displayed. However, since we currently don't have\n\t// a protocol to transfer that time, we'll just estimate it by using the current\n\t// time. This will mean that Suspense timeouts are slightly shifted to later than\n\t// they should be.\n\t// Schedule a normal pri update to render this content.\n\tworkInProgress.lanes=laneToLanes(DefaultHydrationLane);}else {// We'll continue hydrating the rest at offscreen priority since we'll already\n\t// be showing the right content coming from the server, it is no rush.\n\tworkInProgress.lanes=laneToLanes(OffscreenLane);}return null;}function updateDehydratedSuspenseComponent(current,workInProgress,didSuspend,nextProps,suspenseInstance,suspenseState,renderLanes){if(!didSuspend){// This is the first render pass. Attempt to hydrate.\n\t// We should never be hydrating at this point because it is the first pass,\n\t// but after we've already committed once.\n\twarnIfHydrating();if((workInProgress.mode&ConcurrentMode)===NoMode){return retrySuspenseComponentWithoutHydrating(current,workInProgress,renderLanes,// TODO: When we delete legacy mode, we should make this error argument\n\t// required — every concurrent mode path that causes hydration to\n\t// de-opt to client rendering should have an error message.\n\tnull);}if(isSuspenseInstanceFallback(suspenseInstance)){// This boundary is in a permanent fallback state. In this case, we'll never\n\t// get an update and we'll never be able to hydrate the final content. Let's just try the\n\t// client side render instead.\n\tvar digest,message,stack;{var _getSuspenseInstanceF=getSuspenseInstanceFallbackErrorDetails(suspenseInstance);digest=_getSuspenseInstanceF.digest;message=_getSuspenseInstanceF.message;stack=_getSuspenseInstanceF.stack;}var error;if(message){// eslint-disable-next-line react-internal/prod-error-codes\n\terror=new Error(message);}else {error=new Error('The server could not finish this Suspense boundary, likely '+'due to an error during server rendering. Switched to '+'client rendering.');}var capturedValue=createCapturedValue(error,digest,stack);return retrySuspenseComponentWithoutHydrating(current,workInProgress,renderLanes,capturedValue);}// any context has changed, we need to treat is as if the input might have changed.\n\tvar hasContextChanged=includesSomeLane(renderLanes,current.childLanes);if(didReceiveUpdate||hasContextChanged){// This boundary has changed since the first render. This means that we are now unable to\n\t// hydrate it. We might still be able to hydrate it using a higher priority lane.\n\tvar root=getWorkInProgressRoot();if(root!==null){var attemptHydrationAtLane=getBumpedLaneForHydration(root,renderLanes);if(attemptHydrationAtLane!==NoLane&&attemptHydrationAtLane!==suspenseState.retryLane){// Intentionally mutating since this render will get interrupted. This\n\t// is one of the very rare times where we mutate the current tree\n\t// during the render phase.\n\tsuspenseState.retryLane=attemptHydrationAtLane;// TODO: Ideally this would inherit the event time of the current render\n\tvar eventTime=NoTimestamp;enqueueConcurrentRenderForLane(current,attemptHydrationAtLane);scheduleUpdateOnFiber(root,current,attemptHydrationAtLane,eventTime);}}// If we have scheduled higher pri work above, this will probably just abort the render\n\t// since we now have higher priority work, but in case it doesn't, we need to prepare to\n\t// render something, if we time out. Even if that requires us to delete everything and\n\t// skip hydration.\n\t// Delay having to do this as long as the suspense timeout allows us.\n\trenderDidSuspendDelayIfPossible();var _capturedValue=createCapturedValue(new Error('This Suspense boundary received an update before it finished '+'hydrating. This caused the boundary to switch to client rendering. '+'The usual way to fix this is to wrap the original update '+'in startTransition.'));return retrySuspenseComponentWithoutHydrating(current,workInProgress,renderLanes,_capturedValue);}else if(isSuspenseInstancePending(suspenseInstance)){// This component is still pending more data from the server, so we can't hydrate its\n\t// content. We treat it as if this component suspended itself. It might seem as if\n\t// we could just try to render it client-side instead. However, this will perform a\n\t// lot of unnecessary work and is unlikely to complete since it often will suspend\n\t// on missing data anyway. Additionally, the server might be able to render more\n\t// than we can on the client yet. In that case we'd end up with more fallback states\n\t// on the client than if we just leave it alone. If the server times out or errors\n\t// these should update this boundary to the permanent Fallback state instead.\n\t// Mark it as having captured (i.e. suspended).\n\tworkInProgress.flags|=DidCapture;// Leave the child in place. I.e. the dehydrated fragment.\n\tworkInProgress.child=current.child;// Register a callback to retry this boundary once the server has sent the result.\n\tvar retry=retryDehydratedSuspenseBoundary.bind(null,current);registerSuspenseInstanceRetry(suspenseInstance,retry);return null;}else {// This is the first attempt.\n\treenterHydrationStateFromDehydratedSuspenseInstance(workInProgress,suspenseInstance,suspenseState.treeContext);var primaryChildren=nextProps.children;var primaryChildFragment=mountSuspensePrimaryChildren(workInProgress,primaryChildren);// Mark the children as hydrating. This is a fast path to know whether this\n\t// tree is part of a hydrating tree. This is used to determine if a child\n\t// node has fully mounted yet, and for scheduling event replaying.\n\t// Conceptually this is similar to Placement in that a new subtree is\n\t// inserted into the React tree here. It just happens to not need DOM\n\t// mutations because it already exists.\n\tprimaryChildFragment.flags|=Hydrating;return primaryChildFragment;}}else {// This is the second render pass. We already attempted to hydrated, but\n\t// something either suspended or errored.\n\tif(workInProgress.flags&ForceClientRender){// Something errored during hydration. Try again without hydrating.\n\tworkInProgress.flags&=~ForceClientRender;var _capturedValue2=createCapturedValue(new Error('There was an error while hydrating this Suspense boundary. '+'Switched to client rendering.'));return retrySuspenseComponentWithoutHydrating(current,workInProgress,renderLanes,_capturedValue2);}else if(workInProgress.memoizedState!==null){// Something suspended and we should still be in dehydrated mode.\n\t// Leave the existing child in place.\n\tworkInProgress.child=current.child;// The dehydrated completion pass expects this flag to be there\n\t// but the normal suspense pass doesn't.\n\tworkInProgress.flags|=DidCapture;return null;}else {// Suspended but we should no longer be in dehydrated mode.\n\t// Therefore we now have to render the fallback.\n\tvar nextPrimaryChildren=nextProps.children;var nextFallbackChildren=nextProps.fallback;var fallbackChildFragment=mountSuspenseFallbackAfterRetryWithoutHydrating(current,workInProgress,nextPrimaryChildren,nextFallbackChildren,renderLanes);var _primaryChildFragment4=workInProgress.child;_primaryChildFragment4.memoizedState=mountSuspenseOffscreenState(renderLanes);workInProgress.memoizedState=SUSPENDED_MARKER;return fallbackChildFragment;}}}function scheduleSuspenseWorkOnFiber(fiber,renderLanes,propagationRoot){fiber.lanes=mergeLanes(fiber.lanes,renderLanes);var alternate=fiber.alternate;if(alternate!==null){alternate.lanes=mergeLanes(alternate.lanes,renderLanes);}scheduleContextWorkOnParentPath(fiber.return,renderLanes,propagationRoot);}function propagateSuspenseContextChange(workInProgress,firstChild,renderLanes){// Mark any Suspense boundaries with fallbacks as having work to do.\n\t// If they were previously forced into fallbacks, they may now be able\n\t// to unblock.\n\tvar node=firstChild;while(node!==null){if(node.tag===SuspenseComponent){var state=node.memoizedState;if(state!==null){scheduleSuspenseWorkOnFiber(node,renderLanes,workInProgress);}}else if(node.tag===SuspenseListComponent){// If the tail is hidden there might not be an Suspense boundaries\n\t// to schedule work on. In this case we have to schedule it on the\n\t// list itself.\n\t// We don't have to traverse to the children of the list since\n\t// the list will propagate the change when it rerenders.\n\tscheduleSuspenseWorkOnFiber(node,renderLanes,workInProgress);}else if(node.child!==null){node.child.return=node;node=node.child;continue;}if(node===workInProgress){return;}while(node.sibling===null){if(node.return===null||node.return===workInProgress){return;}node=node.return;}node.sibling.return=node.return;node=node.sibling;}}function findLastContentRow(firstChild){// This is going to find the last row among these children that is already\n\t// showing content on the screen, as opposed to being in fallback state or\n\t// new. If a row has multiple Suspense boundaries, any of them being in the\n\t// fallback state, counts as the whole row being in a fallback state.\n\t// Note that the \"rows\" will be workInProgress, but any nested children\n\t// will still be current since we haven't rendered them yet. The mounted\n\t// order may not be the same as the new order. We use the new order.\n\tvar row=firstChild;var lastContentRow=null;while(row!==null){var currentRow=row.alternate;// New rows can't be content rows.\n\tif(currentRow!==null&&findFirstSuspended(currentRow)===null){lastContentRow=row;}row=row.sibling;}return lastContentRow;}function validateRevealOrder(revealOrder){{if(revealOrder!==undefined&&revealOrder!=='forwards'&&revealOrder!=='backwards'&&revealOrder!=='together'&&!didWarnAboutRevealOrder[revealOrder]){didWarnAboutRevealOrder[revealOrder]=true;if(typeof revealOrder==='string'){switch(revealOrder.toLowerCase()){case'together':case'forwards':case'backwards':{error('\"%s\" is not a valid value for revealOrder on <SuspenseList />. '+'Use lowercase \"%s\" instead.',revealOrder,revealOrder.toLowerCase());break;}case'forward':case'backward':{error('\"%s\" is not a valid value for revealOrder on <SuspenseList />. '+'React uses the -s suffix in the spelling. Use \"%ss\" instead.',revealOrder,revealOrder.toLowerCase());break;}default:error('\"%s\" is not a supported revealOrder on <SuspenseList />. '+'Did you mean \"together\", \"forwards\" or \"backwards\"?',revealOrder);break;}}else {error('%s is not a supported value for revealOrder on <SuspenseList />. '+'Did you mean \"together\", \"forwards\" or \"backwards\"?',revealOrder);}}}}function validateTailOptions(tailMode,revealOrder){{if(tailMode!==undefined&&!didWarnAboutTailOptions[tailMode]){if(tailMode!=='collapsed'&&tailMode!=='hidden'){didWarnAboutTailOptions[tailMode]=true;error('\"%s\" is not a supported value for tail on <SuspenseList />. '+'Did you mean \"collapsed\" or \"hidden\"?',tailMode);}else if(revealOrder!=='forwards'&&revealOrder!=='backwards'){didWarnAboutTailOptions[tailMode]=true;error('<SuspenseList tail=\"%s\" /> is only valid if revealOrder is '+'\"forwards\" or \"backwards\". '+'Did you mean to specify revealOrder=\"forwards\"?',tailMode);}}}}function validateSuspenseListNestedChild(childSlot,index){{var isAnArray=isArray(childSlot);var isIterable=!isAnArray&&typeof getIteratorFn(childSlot)==='function';if(isAnArray||isIterable){var type=isAnArray?'array':'iterable';error('A nested %s was passed to row #%s in <SuspenseList />. Wrap it in '+'an additional SuspenseList to configure its revealOrder: '+'<SuspenseList revealOrder=...> ... '+'<SuspenseList revealOrder=...>{%s}</SuspenseList> ... '+'</SuspenseList>',type,index,type);return false;}}return true;}function validateSuspenseListChildren(children,revealOrder){{if((revealOrder==='forwards'||revealOrder==='backwards')&&children!==undefined&&children!==null&&children!==false){if(isArray(children)){for(var i=0;i<children.length;i++){if(!validateSuspenseListNestedChild(children[i],i)){return;}}}else {var iteratorFn=getIteratorFn(children);if(typeof iteratorFn==='function'){var childrenIterator=iteratorFn.call(children);if(childrenIterator){var step=childrenIterator.next();var _i=0;for(;!step.done;step=childrenIterator.next()){if(!validateSuspenseListNestedChild(step.value,_i)){return;}_i++;}}}else {error('A single row was passed to a <SuspenseList revealOrder=\"%s\" />. '+'This is not useful since it needs multiple rows. '+'Did you mean to pass multiple children or an array?',revealOrder);}}}}}function initSuspenseListRenderState(workInProgress,isBackwards,tail,lastContentRow,tailMode){var renderState=workInProgress.memoizedState;if(renderState===null){workInProgress.memoizedState={isBackwards:isBackwards,rendering:null,renderingStartTime:0,last:lastContentRow,tail:tail,tailMode:tailMode};}else {// We can reuse the existing object from previous renders.\n\trenderState.isBackwards=isBackwards;renderState.rendering=null;renderState.renderingStartTime=0;renderState.last=lastContentRow;renderState.tail=tail;renderState.tailMode=tailMode;}}// This can end up rendering this component multiple passes.\n\t// The first pass splits the children fibers into two sets. A head and tail.\n\t// We first render the head. If anything is in fallback state, we do another\n\t// pass through beginWork to rerender all children (including the tail) with\n\t// the force suspend context. If the first render didn't have anything in\n\t// in fallback state. Then we render each row in the tail one-by-one.\n\t// That happens in the completeWork phase without going back to beginWork.\n\tfunction updateSuspenseListComponent(current,workInProgress,renderLanes){var nextProps=workInProgress.pendingProps;var revealOrder=nextProps.revealOrder;var tailMode=nextProps.tail;var newChildren=nextProps.children;validateRevealOrder(revealOrder);validateTailOptions(tailMode,revealOrder);validateSuspenseListChildren(newChildren,revealOrder);reconcileChildren(current,workInProgress,newChildren,renderLanes);var suspenseContext=suspenseStackCursor.current;var shouldForceFallback=hasSuspenseContext(suspenseContext,ForceSuspenseFallback);if(shouldForceFallback){suspenseContext=setShallowSuspenseContext(suspenseContext,ForceSuspenseFallback);workInProgress.flags|=DidCapture;}else {var didSuspendBefore=current!==null&&(current.flags&DidCapture)!==NoFlags;if(didSuspendBefore){// If we previously forced a fallback, we need to schedule work\n\t// on any nested boundaries to let them know to try to render\n\t// again. This is the same as context updating.\n\tpropagateSuspenseContextChange(workInProgress,workInProgress.child,renderLanes);}suspenseContext=setDefaultShallowSuspenseContext(suspenseContext);}pushSuspenseContext(workInProgress,suspenseContext);if((workInProgress.mode&ConcurrentMode)===NoMode){// In legacy mode, SuspenseList doesn't work so we just\n\t// use make it a noop by treating it as the default revealOrder.\n\tworkInProgress.memoizedState=null;}else {switch(revealOrder){case'forwards':{var lastContentRow=findLastContentRow(workInProgress.child);var tail;if(lastContentRow===null){// The whole list is part of the tail.\n\t// TODO: We could fast path by just rendering the tail now.\n\ttail=workInProgress.child;workInProgress.child=null;}else {// Disconnect the tail rows after the content row.\n\t// We're going to render them separately later.\n\ttail=lastContentRow.sibling;lastContentRow.sibling=null;}initSuspenseListRenderState(workInProgress,false,// isBackwards\n\ttail,lastContentRow,tailMode);break;}case'backwards':{// We're going to find the first row that has existing content.\n\t// At the same time we're going to reverse the list of everything\n\t// we pass in the meantime. That's going to be our tail in reverse\n\t// order.\n\tvar _tail=null;var row=workInProgress.child;workInProgress.child=null;while(row!==null){var currentRow=row.alternate;// New rows can't be content rows.\n\tif(currentRow!==null&&findFirstSuspended(currentRow)===null){// This is the beginning of the main content.\n\tworkInProgress.child=row;break;}var nextRow=row.sibling;row.sibling=_tail;_tail=row;row=nextRow;}// TODO: If workInProgress.child is null, we can continue on the tail immediately.\n\tinitSuspenseListRenderState(workInProgress,true,// isBackwards\n\t_tail,null,// last\n\ttailMode);break;}case'together':{initSuspenseListRenderState(workInProgress,false,// isBackwards\n\tnull,// tail\n\tnull,// last\n\tundefined);break;}default:{// The default reveal order is the same as not having\n\t// a boundary.\n\tworkInProgress.memoizedState=null;}}}return workInProgress.child;}function updatePortalComponent(current,workInProgress,renderLanes){pushHostContainer(workInProgress,workInProgress.stateNode.containerInfo);var nextChildren=workInProgress.pendingProps;if(current===null){// Portals are special because we don't append the children during mount\n\t// but at commit. Therefore we need to track insertions which the normal\n\t// flow doesn't do during mount. This doesn't happen at the root because\n\t// the root always starts with a \"current\" with a null child.\n\t// TODO: Consider unifying this with how the root works.\n\tworkInProgress.child=reconcileChildFibers(workInProgress,null,nextChildren,renderLanes);}else {reconcileChildren(current,workInProgress,nextChildren,renderLanes);}return workInProgress.child;}var hasWarnedAboutUsingNoValuePropOnContextProvider=false;function updateContextProvider(current,workInProgress,renderLanes){var providerType=workInProgress.type;var context=providerType._context;var newProps=workInProgress.pendingProps;var oldProps=workInProgress.memoizedProps;var newValue=newProps.value;{if(!('value'in newProps)){if(!hasWarnedAboutUsingNoValuePropOnContextProvider){hasWarnedAboutUsingNoValuePropOnContextProvider=true;error('The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?');}}var providerPropTypes=workInProgress.type.propTypes;if(providerPropTypes){checkPropTypes(providerPropTypes,newProps,'prop','Context.Provider');}}pushProvider(workInProgress,context,newValue);{if(oldProps!==null){var oldValue=oldProps.value;if(objectIs(oldValue,newValue)){// No change. Bailout early if children are the same.\n\tif(oldProps.children===newProps.children&&!hasContextChanged()){return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}}else {// The context value changed. Search for matching consumers and schedule\n\t// them to update.\n\tpropagateContextChange(workInProgress,context,renderLanes);}}}var newChildren=newProps.children;reconcileChildren(current,workInProgress,newChildren,renderLanes);return workInProgress.child;}var hasWarnedAboutUsingContextAsConsumer=false;function updateContextConsumer(current,workInProgress,renderLanes){var context=workInProgress.type;// The logic below for Context differs depending on PROD or DEV mode. In\n\t// DEV mode, we create a separate object for Context.Consumer that acts\n\t// like a proxy to Context. This proxy object adds unnecessary code in PROD\n\t// so we use the old behaviour (Context.Consumer references Context) to\n\t// reduce size and overhead. The separate object references context via\n\t// a property called \"_context\", which also gives us the ability to check\n\t// in DEV mode if this property exists or not and warn if it does not.\n\t{if(context._context===undefined){// This may be because it's a Context (rather than a Consumer).\n\t// Or it may be because it's older React where they're the same thing.\n\t// We only want to warn if we're sure it's a new React.\n\tif(context!==context.Consumer){if(!hasWarnedAboutUsingContextAsConsumer){hasWarnedAboutUsingContextAsConsumer=true;error('Rendering <Context> directly is not supported and will be removed in '+'a future major release. Did you mean to render <Context.Consumer> instead?');}}}else {context=context._context;}}var newProps=workInProgress.pendingProps;var render=newProps.children;{if(typeof render!=='function'){error('A context consumer was rendered with multiple children, or a child '+\"that isn't a function. A context consumer expects a single child \"+'that is a function. If you did pass a function, make sure there '+'is no trailing or leading whitespace around it.');}}prepareToReadContext(workInProgress,renderLanes);var newValue=readContext(context);{markComponentRenderStarted(workInProgress);}var newChildren;{ReactCurrentOwner$1.current=workInProgress;setIsRendering(true);newChildren=render(newValue);setIsRendering(false);}{markComponentRenderStopped();}// React DevTools reads this flag.\n\tworkInProgress.flags|=PerformedWork;reconcileChildren(current,workInProgress,newChildren,renderLanes);return workInProgress.child;}function markWorkInProgressReceivedUpdate(){didReceiveUpdate=true;}function resetSuspendedCurrentOnMountInLegacyMode(current,workInProgress){if((workInProgress.mode&ConcurrentMode)===NoMode){if(current!==null){// A lazy component only mounts if it suspended inside a non-\n\t// concurrent tree, in an inconsistent state. We want to treat it like\n\t// a new mount, even though an empty version of it already committed.\n\t// Disconnect the alternate pointers.\n\tcurrent.alternate=null;workInProgress.alternate=null;// Since this is conceptually a new fiber, schedule a Placement effect\n\tworkInProgress.flags|=Placement;}}}function bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes){if(current!==null){// Reuse previous dependencies\n\tworkInProgress.dependencies=current.dependencies;}{// Don't update \"base\" render times for bailouts.\n\tstopProfilerTimerIfRunning();}markSkippedUpdateLanes(workInProgress.lanes);// Check if the children have any pending work.\n\tif(!includesSomeLane(renderLanes,workInProgress.childLanes)){// The children don't have any work either. We can skip them.\n\t// TODO: Once we add back resuming, we should check if the children are\n\t// a work-in-progress set. If so, we need to transfer their effects.\n\t{return null;}}// This fiber doesn't have work, but its subtree does. Clone the child\n\t// fibers and continue.\n\tcloneChildFibers(current,workInProgress);return workInProgress.child;}function remountFiber(current,oldWorkInProgress,newWorkInProgress){{var returnFiber=oldWorkInProgress.return;if(returnFiber===null){// eslint-disable-next-line react-internal/prod-error-codes\n\tthrow new Error('Cannot swap the root fiber.');}// Disconnect from the old current.\n\t// It will get deleted.\n\tcurrent.alternate=null;oldWorkInProgress.alternate=null;// Connect to the new tree.\n\tnewWorkInProgress.index=oldWorkInProgress.index;newWorkInProgress.sibling=oldWorkInProgress.sibling;newWorkInProgress.return=oldWorkInProgress.return;newWorkInProgress.ref=oldWorkInProgress.ref;// Replace the child/sibling pointers above it.\n\tif(oldWorkInProgress===returnFiber.child){returnFiber.child=newWorkInProgress;}else {var prevSibling=returnFiber.child;if(prevSibling===null){// eslint-disable-next-line react-internal/prod-error-codes\n\tthrow new Error('Expected parent to have a child.');}while(prevSibling.sibling!==oldWorkInProgress){prevSibling=prevSibling.sibling;if(prevSibling===null){// eslint-disable-next-line react-internal/prod-error-codes\n\tthrow new Error('Expected to find the previous sibling.');}}prevSibling.sibling=newWorkInProgress;}// Delete the old fiber and place the new one.\n\t// Since the old fiber is disconnected, we have to schedule it manually.\n\tvar deletions=returnFiber.deletions;if(deletions===null){returnFiber.deletions=[current];returnFiber.flags|=ChildDeletion;}else {deletions.push(current);}newWorkInProgress.flags|=Placement;// Restart work from the new fiber.\n\treturn newWorkInProgress;}}function checkScheduledUpdateOrContext(current,renderLanes){// Before performing an early bailout, we must check if there are pending\n\t// updates or context.\n\tvar updateLanes=current.lanes;if(includesSomeLane(updateLanes,renderLanes)){return true;}// No pending update, but because context is propagated lazily, we need\n\treturn false;}function attemptEarlyBailoutIfNoScheduledUpdate(current,workInProgress,renderLanes){// This fiber does not have any pending work. Bailout without entering\n\t// the begin phase. There's still some bookkeeping we that needs to be done\n\t// in this optimized path, mostly pushing stuff onto the stack.\n\tswitch(workInProgress.tag){case HostRoot:pushHostRootContext(workInProgress);workInProgress.stateNode;resetHydrationState();break;case HostComponent:pushHostContext(workInProgress);break;case ClassComponent:{var Component=workInProgress.type;if(isContextProvider(Component)){pushContextProvider(workInProgress);}break;}case HostPortal:pushHostContainer(workInProgress,workInProgress.stateNode.containerInfo);break;case ContextProvider:{var newValue=workInProgress.memoizedProps.value;var context=workInProgress.type._context;pushProvider(workInProgress,context,newValue);break;}case Profiler:{// Profiler should only call onRender when one of its descendants actually rendered.\n\tvar hasChildWork=includesSomeLane(renderLanes,workInProgress.childLanes);if(hasChildWork){workInProgress.flags|=Update;}{// Reset effect durations for the next eventual effect phase.\n\t// These are reset during render to allow the DevTools commit hook a chance to read them,\n\tvar stateNode=workInProgress.stateNode;stateNode.effectDuration=0;stateNode.passiveEffectDuration=0;}}break;case SuspenseComponent:{var state=workInProgress.memoizedState;if(state!==null){if(state.dehydrated!==null){pushSuspenseContext(workInProgress,setDefaultShallowSuspenseContext(suspenseStackCursor.current));// We know that this component will suspend again because if it has\n\t// been unsuspended it has committed as a resolved Suspense component.\n\t// If it needs to be retried, it should have work scheduled on it.\n\tworkInProgress.flags|=DidCapture;// We should never render the children of a dehydrated boundary until we\n\t// upgrade it. We return null instead of bailoutOnAlreadyFinishedWork.\n\treturn null;}// If this boundary is currently timed out, we need to decide\n\t// whether to retry the primary children, or to skip over it and\n\t// go straight to the fallback. Check the priority of the primary\n\t// child fragment.\n\tvar primaryChildFragment=workInProgress.child;var primaryChildLanes=primaryChildFragment.childLanes;if(includesSomeLane(renderLanes,primaryChildLanes)){// The primary children have pending work. Use the normal path\n\t// to attempt to render the primary children again.\n\treturn updateSuspenseComponent(current,workInProgress,renderLanes);}else {// The primary child fragment does not have pending work marked\n\t// on it\n\tpushSuspenseContext(workInProgress,setDefaultShallowSuspenseContext(suspenseStackCursor.current));// The primary children do not have pending work with sufficient\n\t// priority. Bailout.\n\tvar child=bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);if(child!==null){// The fallback children have pending work. Skip over the\n\t// primary children and work on the fallback.\n\treturn child.sibling;}else {// Note: We can return `null` here because we already checked\n\t// whether there were nested context consumers, via the call to\n\t// `bailoutOnAlreadyFinishedWork` above.\n\treturn null;}}}else {pushSuspenseContext(workInProgress,setDefaultShallowSuspenseContext(suspenseStackCursor.current));}break;}case SuspenseListComponent:{var didSuspendBefore=(current.flags&DidCapture)!==NoFlags;var _hasChildWork=includesSomeLane(renderLanes,workInProgress.childLanes);if(didSuspendBefore){if(_hasChildWork){// If something was in fallback state last time, and we have all the\n\t// same children then we're still in progressive loading state.\n\t// Something might get unblocked by state updates or retries in the\n\t// tree which will affect the tail. So we need to use the normal\n\t// path to compute the correct tail.\n\treturn updateSuspenseListComponent(current,workInProgress,renderLanes);}// If none of the children had any work, that means that none of\n\t// them got retried so they'll still be blocked in the same way\n\t// as before. We can fast bail out.\n\tworkInProgress.flags|=DidCapture;}// If nothing suspended before and we're rendering the same children,\n\t// then the tail doesn't matter. Anything new that suspends will work\n\t// in the \"together\" mode, so we can continue from the state we had.\n\tvar renderState=workInProgress.memoizedState;if(renderState!==null){// Reset to the \"together\" mode in case we've started a different\n\t// update in the past but didn't complete it.\n\trenderState.rendering=null;renderState.tail=null;renderState.lastEffect=null;}pushSuspenseContext(workInProgress,suspenseStackCursor.current);if(_hasChildWork){break;}else {// If none of the children had any work, that means that none of\n\t// them got retried so they'll still be blocked in the same way\n\t// as before. We can fast bail out.\n\treturn null;}}case OffscreenComponent:case LegacyHiddenComponent:{// Need to check if the tree still needs to be deferred. This is\n\t// almost identical to the logic used in the normal update path,\n\t// so we'll just enter that. The only difference is we'll bail out\n\t// at the next level instead of this one, because the child props\n\t// have not changed. Which is fine.\n\t// TODO: Probably should refactor `beginWork` to split the bailout\n\t// path from the normal path. I'm tempted to do a labeled break here\n\t// but I won't :)\n\tworkInProgress.lanes=NoLanes;return updateOffscreenComponent(current,workInProgress,renderLanes);}}return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);}function beginWork(current,workInProgress,renderLanes){{if(workInProgress._debugNeedsRemount&&current!==null){// This will restart the begin phase with a new fiber.\n\treturn remountFiber(current,workInProgress,createFiberFromTypeAndProps(workInProgress.type,workInProgress.key,workInProgress.pendingProps,workInProgress._debugOwner||null,workInProgress.mode,workInProgress.lanes));}}if(current!==null){var oldProps=current.memoizedProps;var newProps=workInProgress.pendingProps;if(oldProps!==newProps||hasContextChanged()||// Force a re-render if the implementation changed due to hot reload:\n\tworkInProgress.type!==current.type){// If props or context changed, mark the fiber as having performed work.\n\t// This may be unset if the props are determined to be equal later (memo).\n\tdidReceiveUpdate=true;}else {// Neither props nor legacy context changes. Check if there's a pending\n\t// update or context change.\n\tvar hasScheduledUpdateOrContext=checkScheduledUpdateOrContext(current,renderLanes);if(!hasScheduledUpdateOrContext&&// If this is the second pass of an error or suspense boundary, there\n\t// may not be work scheduled on `current`, so we check for this flag.\n\t(workInProgress.flags&DidCapture)===NoFlags){// No pending updates or context. Bail out now.\n\tdidReceiveUpdate=false;return attemptEarlyBailoutIfNoScheduledUpdate(current,workInProgress,renderLanes);}if((current.flags&ForceUpdateForLegacySuspense)!==NoFlags){// This is a special case that only exists for legacy mode.\n\t// See https://github.com/facebook/react/pull/19216.\n\tdidReceiveUpdate=true;}else {// An update was scheduled on this fiber, but there are no new props\n\t// nor legacy context. Set this to false. If an update queue or context\n\t// consumer produces a changed value, it will set this to true. Otherwise,\n\t// the component will assume the children have not changed and bail out.\n\tdidReceiveUpdate=false;}}}else {didReceiveUpdate=false;if(getIsHydrating()&&isForkedChild(workInProgress)){// Check if this child belongs to a list of muliple children in\n\t// its parent.\n\t//\n\t// In a true multi-threaded implementation, we would render children on\n\t// parallel threads. This would represent the beginning of a new render\n\t// thread for this subtree.\n\t//\n\t// We only use this for id generation during hydration, which is why the\n\t// logic is located in this special branch.\n\tvar slotIndex=workInProgress.index;var numberOfForks=getForksAtLevel();pushTreeId(workInProgress,numberOfForks,slotIndex);}}// Before entering the begin phase, clear pending update priority.\n\t// TODO: This assumes that we're about to evaluate the component and process\n\t// the update queue. However, there's an exception: SimpleMemoComponent\n\t// sometimes bails out later in the begin phase. This indicates that we should\n\t// move this assignment out of the common path and into each branch.\n\tworkInProgress.lanes=NoLanes;switch(workInProgress.tag){case IndeterminateComponent:{return mountIndeterminateComponent(current,workInProgress,workInProgress.type,renderLanes);}case LazyComponent:{var elementType=workInProgress.elementType;return mountLazyComponent(current,workInProgress,elementType,renderLanes);}case FunctionComponent:{var Component=workInProgress.type;var unresolvedProps=workInProgress.pendingProps;var resolvedProps=workInProgress.elementType===Component?unresolvedProps:resolveDefaultProps(Component,unresolvedProps);return updateFunctionComponent(current,workInProgress,Component,resolvedProps,renderLanes);}case ClassComponent:{var _Component=workInProgress.type;var _unresolvedProps=workInProgress.pendingProps;var _resolvedProps=workInProgress.elementType===_Component?_unresolvedProps:resolveDefaultProps(_Component,_unresolvedProps);return updateClassComponent(current,workInProgress,_Component,_resolvedProps,renderLanes);}case HostRoot:return updateHostRoot(current,workInProgress,renderLanes);case HostComponent:return updateHostComponent(current,workInProgress,renderLanes);case HostText:return updateHostText(current,workInProgress);case SuspenseComponent:return updateSuspenseComponent(current,workInProgress,renderLanes);case HostPortal:return updatePortalComponent(current,workInProgress,renderLanes);case ForwardRef:{var type=workInProgress.type;var _unresolvedProps2=workInProgress.pendingProps;var _resolvedProps2=workInProgress.elementType===type?_unresolvedProps2:resolveDefaultProps(type,_unresolvedProps2);return updateForwardRef(current,workInProgress,type,_resolvedProps2,renderLanes);}case Fragment:return updateFragment(current,workInProgress,renderLanes);case Mode:return updateMode(current,workInProgress,renderLanes);case Profiler:return updateProfiler(current,workInProgress,renderLanes);case ContextProvider:return updateContextProvider(current,workInProgress,renderLanes);case ContextConsumer:return updateContextConsumer(current,workInProgress,renderLanes);case MemoComponent:{var _type2=workInProgress.type;var _unresolvedProps3=workInProgress.pendingProps;// Resolve outer props first, then resolve inner props.\n\tvar _resolvedProps3=resolveDefaultProps(_type2,_unresolvedProps3);{if(workInProgress.type!==workInProgress.elementType){var outerPropTypes=_type2.propTypes;if(outerPropTypes){checkPropTypes(outerPropTypes,_resolvedProps3,// Resolved for outer only\n\t'prop',getComponentNameFromType(_type2));}}}_resolvedProps3=resolveDefaultProps(_type2.type,_resolvedProps3);return updateMemoComponent(current,workInProgress,_type2,_resolvedProps3,renderLanes);}case SimpleMemoComponent:{return updateSimpleMemoComponent(current,workInProgress,workInProgress.type,workInProgress.pendingProps,renderLanes);}case IncompleteClassComponent:{var _Component2=workInProgress.type;var _unresolvedProps4=workInProgress.pendingProps;var _resolvedProps4=workInProgress.elementType===_Component2?_unresolvedProps4:resolveDefaultProps(_Component2,_unresolvedProps4);return mountIncompleteClassComponent(current,workInProgress,_Component2,_resolvedProps4,renderLanes);}case SuspenseListComponent:{return updateSuspenseListComponent(current,workInProgress,renderLanes);}case ScopeComponent:{break;}case OffscreenComponent:{return updateOffscreenComponent(current,workInProgress,renderLanes);}}throw new Error(\"Unknown unit of work tag (\"+workInProgress.tag+\"). This error is likely caused by a bug in \"+'React. Please file an issue.');}function markUpdate(workInProgress){// Tag the fiber with an update effect. This turns a Placement into\n\t// a PlacementAndUpdate.\n\tworkInProgress.flags|=Update;}function markRef$1(workInProgress){workInProgress.flags|=Ref;{workInProgress.flags|=RefStatic;}}var appendAllChildren;var updateHostContainer;var updateHostComponent$1;var updateHostText$1;{// Mutation mode\n\tappendAllChildren=function(parent,workInProgress,needsVisibilityToggle,isHidden){// We only have the top Fiber that was created but we need recurse down its\n\t// children to find all the terminal nodes.\n\tvar node=workInProgress.child;while(node!==null){if(node.tag===HostComponent||node.tag===HostText){appendInitialChild(parent,node.stateNode);}else if(node.tag===HostPortal);else if(node.child!==null){node.child.return=node;node=node.child;continue;}if(node===workInProgress){return;}while(node.sibling===null){if(node.return===null||node.return===workInProgress){return;}node=node.return;}node.sibling.return=node.return;node=node.sibling;}};updateHostContainer=function(current,workInProgress){// Noop\n\t};updateHostComponent$1=function(current,workInProgress,type,newProps,rootContainerInstance){// If we have an alternate, that means this is an update and we need to\n\t// schedule a side-effect to do the updates.\n\tvar oldProps=current.memoizedProps;if(oldProps===newProps){// In mutation mode, this is sufficient for a bailout because\n\t// we won't touch this node even if children changed.\n\treturn;}// If we get updated because one of our children updated, we don't\n\t// have newProps so we'll have to reuse them.\n\t// TODO: Split the update API as separate for the props vs. children.\n\t// Even better would be if children weren't special cased at all tho.\n\tvar instance=workInProgress.stateNode;var currentHostContext=getHostContext();// TODO: Experiencing an error where oldProps is null. Suggests a host\n\t// component is hitting the resume path. Figure out why. Possibly\n\t// related to `hidden`.\n\tvar updatePayload=prepareUpdate(instance,type,oldProps,newProps,rootContainerInstance,currentHostContext);// TODO: Type this specific to this type of component.\n\tworkInProgress.updateQueue=updatePayload;// If the update payload indicates that there is a change or if there\n\t// is a new ref we mark this as an update. All the work is done in commitWork.\n\tif(updatePayload){markUpdate(workInProgress);}};updateHostText$1=function(current,workInProgress,oldText,newText){// If the text differs, mark it as an update. All the work in done in commitWork.\n\tif(oldText!==newText){markUpdate(workInProgress);}};}function cutOffTailIfNeeded(renderState,hasRenderedATailFallback){if(getIsHydrating()){// If we're hydrating, we should consume as many items as we can\n\t// so we don't leave any behind.\n\treturn;}switch(renderState.tailMode){case'hidden':{// Any insertions at the end of the tail list after this point\n\t// should be invisible. If there are already mounted boundaries\n\t// anything before them are not considered for collapsing.\n\t// Therefore we need to go through the whole tail to find if\n\t// there are any.\n\tvar tailNode=renderState.tail;var lastTailNode=null;while(tailNode!==null){if(tailNode.alternate!==null){lastTailNode=tailNode;}tailNode=tailNode.sibling;}// Next we're simply going to delete all insertions after the\n\t// last rendered item.\n\tif(lastTailNode===null){// All remaining items in the tail are insertions.\n\trenderState.tail=null;}else {// Detach the insertion after the last node that was already\n\t// inserted.\n\tlastTailNode.sibling=null;}break;}case'collapsed':{// Any insertions at the end of the tail list after this point\n\t// should be invisible. If there are already mounted boundaries\n\t// anything before them are not considered for collapsing.\n\t// Therefore we need to go through the whole tail to find if\n\t// there are any.\n\tvar _tailNode=renderState.tail;var _lastTailNode=null;while(_tailNode!==null){if(_tailNode.alternate!==null){_lastTailNode=_tailNode;}_tailNode=_tailNode.sibling;}// Next we're simply going to delete all insertions after the\n\t// last rendered item.\n\tif(_lastTailNode===null){// All remaining items in the tail are insertions.\n\tif(!hasRenderedATailFallback&&renderState.tail!==null){// We suspended during the head. We want to show at least one\n\t// row at the tail. So we'll keep on and cut off the rest.\n\trenderState.tail.sibling=null;}else {renderState.tail=null;}}else {// Detach the insertion after the last node that was already\n\t// inserted.\n\t_lastTailNode.sibling=null;}break;}}}function bubbleProperties(completedWork){var didBailout=completedWork.alternate!==null&&completedWork.alternate.child===completedWork.child;var newChildLanes=NoLanes;var subtreeFlags=NoFlags;if(!didBailout){// Bubble up the earliest expiration time.\n\tif((completedWork.mode&ProfileMode)!==NoMode){// In profiling mode, resetChildExpirationTime is also used to reset\n\t// profiler durations.\n\tvar actualDuration=completedWork.actualDuration;var treeBaseDuration=completedWork.selfBaseDuration;var child=completedWork.child;while(child!==null){newChildLanes=mergeLanes(newChildLanes,mergeLanes(child.lanes,child.childLanes));subtreeFlags|=child.subtreeFlags;subtreeFlags|=child.flags;// When a fiber is cloned, its actualDuration is reset to 0. This value will\n\t// only be updated if work is done on the fiber (i.e. it doesn't bailout).\n\t// When work is done, it should bubble to the parent's actualDuration. If\n\t// the fiber has not been cloned though, (meaning no work was done), then\n\t// this value will reflect the amount of time spent working on a previous\n\t// render. In that case it should not bubble. We determine whether it was\n\t// cloned by comparing the child pointer.\n\tactualDuration+=child.actualDuration;treeBaseDuration+=child.treeBaseDuration;child=child.sibling;}completedWork.actualDuration=actualDuration;completedWork.treeBaseDuration=treeBaseDuration;}else {var _child=completedWork.child;while(_child!==null){newChildLanes=mergeLanes(newChildLanes,mergeLanes(_child.lanes,_child.childLanes));subtreeFlags|=_child.subtreeFlags;subtreeFlags|=_child.flags;// Update the return pointer so the tree is consistent. This is a code\n\t// smell because it assumes the commit phase is never concurrent with\n\t// the render phase. Will address during refactor to alternate model.\n\t_child.return=completedWork;_child=_child.sibling;}}completedWork.subtreeFlags|=subtreeFlags;}else {// Bubble up the earliest expiration time.\n\tif((completedWork.mode&ProfileMode)!==NoMode){// In profiling mode, resetChildExpirationTime is also used to reset\n\t// profiler durations.\n\tvar _treeBaseDuration=completedWork.selfBaseDuration;var _child2=completedWork.child;while(_child2!==null){newChildLanes=mergeLanes(newChildLanes,mergeLanes(_child2.lanes,_child2.childLanes));// \"Static\" flags share the lifetime of the fiber/hook they belong to,\n\t// so we should bubble those up even during a bailout. All the other\n\t// flags have a lifetime only of a single render + commit, so we should\n\t// ignore them.\n\tsubtreeFlags|=_child2.subtreeFlags&StaticMask;subtreeFlags|=_child2.flags&StaticMask;_treeBaseDuration+=_child2.treeBaseDuration;_child2=_child2.sibling;}completedWork.treeBaseDuration=_treeBaseDuration;}else {var _child3=completedWork.child;while(_child3!==null){newChildLanes=mergeLanes(newChildLanes,mergeLanes(_child3.lanes,_child3.childLanes));// \"Static\" flags share the lifetime of the fiber/hook they belong to,\n\t// so we should bubble those up even during a bailout. All the other\n\t// flags have a lifetime only of a single render + commit, so we should\n\t// ignore them.\n\tsubtreeFlags|=_child3.subtreeFlags&StaticMask;subtreeFlags|=_child3.flags&StaticMask;// Update the return pointer so the tree is consistent. This is a code\n\t// smell because it assumes the commit phase is never concurrent with\n\t// the render phase. Will address during refactor to alternate model.\n\t_child3.return=completedWork;_child3=_child3.sibling;}}completedWork.subtreeFlags|=subtreeFlags;}completedWork.childLanes=newChildLanes;return didBailout;}function completeDehydratedSuspenseBoundary(current,workInProgress,nextState){if(hasUnhydratedTailNodes()&&(workInProgress.mode&ConcurrentMode)!==NoMode&&(workInProgress.flags&DidCapture)===NoFlags){warnIfUnhydratedTailNodes(workInProgress);resetHydrationState();workInProgress.flags|=ForceClientRender|Incomplete|ShouldCapture;return false;}var wasHydrated=popHydrationState(workInProgress);if(nextState!==null&&nextState.dehydrated!==null){// We might be inside a hydration state the first time we're picking up this\n\t// Suspense boundary, and also after we've reentered it for further hydration.\n\tif(current===null){if(!wasHydrated){throw new Error('A dehydrated suspense component was completed without a hydrated node. '+'This is probably a bug in React.');}prepareToHydrateHostSuspenseInstance(workInProgress);bubbleProperties(workInProgress);{if((workInProgress.mode&ProfileMode)!==NoMode){var isTimedOutSuspense=nextState!==null;if(isTimedOutSuspense){// Don't count time spent in a timed out Suspense subtree as part of the base duration.\n\tvar primaryChildFragment=workInProgress.child;if(primaryChildFragment!==null){// $FlowFixMe Flow doesn't support type casting in combination with the -= operator\n\tworkInProgress.treeBaseDuration-=primaryChildFragment.treeBaseDuration;}}}}return false;}else {// We might have reentered this boundary to hydrate it. If so, we need to reset the hydration\n\t// state since we're now exiting out of it. popHydrationState doesn't do that for us.\n\tresetHydrationState();if((workInProgress.flags&DidCapture)===NoFlags){// This boundary did not suspend so it's now hydrated and unsuspended.\n\tworkInProgress.memoizedState=null;}// If nothing suspended, we need to schedule an effect to mark this boundary\n\t// as having hydrated so events know that they're free to be invoked.\n\t// It's also a signal to replay events and the suspense callback.\n\t// If something suspended, schedule an effect to attach retry listeners.\n\t// So we might as well always mark this.\n\tworkInProgress.flags|=Update;bubbleProperties(workInProgress);{if((workInProgress.mode&ProfileMode)!==NoMode){var _isTimedOutSuspense=nextState!==null;if(_isTimedOutSuspense){// Don't count time spent in a timed out Suspense subtree as part of the base duration.\n\tvar _primaryChildFragment=workInProgress.child;if(_primaryChildFragment!==null){// $FlowFixMe Flow doesn't support type casting in combination with the -= operator\n\tworkInProgress.treeBaseDuration-=_primaryChildFragment.treeBaseDuration;}}}}return false;}}else {// Successfully completed this tree. If this was a forced client render,\n\t// there may have been recoverable errors during first hydration\n\t// attempt. If so, add them to a queue so we can log them in the\n\t// commit phase.\n\tupgradeHydrationErrorsToRecoverable();// Fall through to normal Suspense path\n\treturn true;}}function completeWork(current,workInProgress,renderLanes){var newProps=workInProgress.pendingProps;// Note: This intentionally doesn't check if we're hydrating because comparing\n\t// to the current tree provider fiber is just as fast and less error-prone.\n\t// Ideally we would have a special version of the work loop only\n\t// for hydration.\n\tpopTreeContext(workInProgress);switch(workInProgress.tag){case IndeterminateComponent:case LazyComponent:case SimpleMemoComponent:case FunctionComponent:case ForwardRef:case Fragment:case Mode:case Profiler:case ContextConsumer:case MemoComponent:bubbleProperties(workInProgress);return null;case ClassComponent:{var Component=workInProgress.type;if(isContextProvider(Component)){popContext(workInProgress);}bubbleProperties(workInProgress);return null;}case HostRoot:{var fiberRoot=workInProgress.stateNode;popHostContainer(workInProgress);popTopLevelContextObject(workInProgress);resetWorkInProgressVersions();if(fiberRoot.pendingContext){fiberRoot.context=fiberRoot.pendingContext;fiberRoot.pendingContext=null;}if(current===null||current.child===null){// If we hydrated, pop so that we can delete any remaining children\n\t// that weren't hydrated.\n\tvar wasHydrated=popHydrationState(workInProgress);if(wasHydrated){// If we hydrated, then we'll need to schedule an update for\n\t// the commit side-effects on the root.\n\tmarkUpdate(workInProgress);}else {if(current!==null){var prevState=current.memoizedState;if(// Check if this is a client root\n\t!prevState.isDehydrated||// Check if we reverted to client rendering (e.g. due to an error)\n\t(workInProgress.flags&ForceClientRender)!==NoFlags){// Schedule an effect to clear this container at the start of the\n\t// next commit. This handles the case of React rendering into a\n\t// container with previous children. It's also safe to do for\n\t// updates too, because current.child would only be null if the\n\t// previous render was null (so the container would already\n\t// be empty).\n\tworkInProgress.flags|=Snapshot;// If this was a forced client render, there may have been\n\t// recoverable errors during first hydration attempt. If so, add\n\t// them to a queue so we can log them in the commit phase.\n\tupgradeHydrationErrorsToRecoverable();}}}}updateHostContainer(current,workInProgress);bubbleProperties(workInProgress);return null;}case HostComponent:{popHostContext(workInProgress);var rootContainerInstance=getRootHostContainer();var type=workInProgress.type;if(current!==null&&workInProgress.stateNode!=null){updateHostComponent$1(current,workInProgress,type,newProps,rootContainerInstance);if(current.ref!==workInProgress.ref){markRef$1(workInProgress);}}else {if(!newProps){if(workInProgress.stateNode===null){throw new Error('We must have new props for new mounts. This error is likely '+'caused by a bug in React. Please file an issue.');}// This can happen when we abort work.\n\tbubbleProperties(workInProgress);return null;}var currentHostContext=getHostContext();// TODO: Move createInstance to beginWork and keep it on a context\n\t// \"stack\" as the parent. Then append children as we go in beginWork\n\t// or completeWork depending on whether we want to add them top->down or\n\t// bottom->up. Top->down is faster in IE11.\n\tvar _wasHydrated=popHydrationState(workInProgress);if(_wasHydrated){// TODO: Move this and createInstance step into the beginPhase\n\t// to consolidate.\n\tif(prepareToHydrateHostInstance(workInProgress,rootContainerInstance,currentHostContext)){// If changes to the hydrated node need to be applied at the\n\t// commit-phase we mark this as such.\n\tmarkUpdate(workInProgress);}}else {var instance=createInstance(type,newProps,rootContainerInstance,currentHostContext,workInProgress);appendAllChildren(instance,workInProgress,false,false);workInProgress.stateNode=instance;// Certain renderers require commit-time effects for initial mount.\n\t// (eg DOM renderer supports auto-focus for certain elements).\n\t// Make sure such renderers get scheduled for later work.\n\tif(finalizeInitialChildren(instance,type,newProps,rootContainerInstance)){markUpdate(workInProgress);}}if(workInProgress.ref!==null){// If there is a ref on a host node we need to schedule a callback\n\tmarkRef$1(workInProgress);}}bubbleProperties(workInProgress);return null;}case HostText:{var newText=newProps;if(current&&workInProgress.stateNode!=null){var oldText=current.memoizedProps;// If we have an alternate, that means this is an update and we need\n\t// to schedule a side-effect to do the updates.\n\tupdateHostText$1(current,workInProgress,oldText,newText);}else {if(typeof newText!=='string'){if(workInProgress.stateNode===null){throw new Error('We must have new props for new mounts. This error is likely '+'caused by a bug in React. Please file an issue.');}// This can happen when we abort work.\n\t}var _rootContainerInstance=getRootHostContainer();var _currentHostContext=getHostContext();var _wasHydrated2=popHydrationState(workInProgress);if(_wasHydrated2){if(prepareToHydrateHostTextInstance(workInProgress)){markUpdate(workInProgress);}}else {workInProgress.stateNode=createTextInstance(newText,_rootContainerInstance,_currentHostContext,workInProgress);}}bubbleProperties(workInProgress);return null;}case SuspenseComponent:{popSuspenseContext(workInProgress);var nextState=workInProgress.memoizedState;// Special path for dehydrated boundaries. We may eventually move this\n\t// to its own fiber type so that we can add other kinds of hydration\n\t// boundaries that aren't associated with a Suspense tree. In anticipation\n\t// of such a refactor, all the hydration logic is contained in\n\t// this branch.\n\tif(current===null||current.memoizedState!==null&&current.memoizedState.dehydrated!==null){var fallthroughToNormalSuspensePath=completeDehydratedSuspenseBoundary(current,workInProgress,nextState);if(!fallthroughToNormalSuspensePath){if(workInProgress.flags&ShouldCapture){// Special case. There were remaining unhydrated nodes. We treat\n\t// this as a mismatch. Revert to client rendering.\n\treturn workInProgress;}else {// Did not finish hydrating, either because this is the initial\n\t// render or because something suspended.\n\treturn null;}}// Continue with the normal Suspense path.\n\t}if((workInProgress.flags&DidCapture)!==NoFlags){// Something suspended. Re-render with the fallback children.\n\tworkInProgress.lanes=renderLanes;// Do not reset the effect list.\n\tif((workInProgress.mode&ProfileMode)!==NoMode){transferActualDuration(workInProgress);}// Don't bubble properties in this case.\n\treturn workInProgress;}var nextDidTimeout=nextState!==null;var prevDidTimeout=current!==null&&current.memoizedState!==null;// a passive effect, which is when we process the transitions\n\tif(nextDidTimeout!==prevDidTimeout){// an effect to toggle the subtree's visibility. When we switch from\n\t// fallback -> primary, the inner Offscreen fiber schedules this effect\n\t// as part of its normal complete phase. But when we switch from\n\t// primary -> fallback, the inner Offscreen fiber does not have a complete\n\t// phase. So we need to schedule its effect here.\n\t//\n\t// We also use this flag to connect/disconnect the effects, but the same\n\t// logic applies: when re-connecting, the Offscreen fiber's complete\n\t// phase will handle scheduling the effect. It's only when the fallback\n\t// is active that we have to do anything special.\n\tif(nextDidTimeout){var _offscreenFiber2=workInProgress.child;_offscreenFiber2.flags|=Visibility;// TODO: This will still suspend a synchronous tree if anything\n\t// in the concurrent tree already suspended during this render.\n\t// This is a known bug.\n\tif((workInProgress.mode&ConcurrentMode)!==NoMode){// TODO: Move this back to throwException because this is too late\n\t// if this is a large tree which is common for initial loads. We\n\t// don't know if we should restart a render or not until we get\n\t// this marker, and this is too late.\n\t// If this render already had a ping or lower pri updates,\n\t// and this is the first time we know we're going to suspend we\n\t// should be able to immediately restart from within throwException.\n\tvar hasInvisibleChildContext=current===null&&(workInProgress.memoizedProps.unstable_avoidThisFallback!==true||!enableSuspenseAvoidThisFallback);if(hasInvisibleChildContext||hasSuspenseContext(suspenseStackCursor.current,InvisibleParentSuspenseContext)){// If this was in an invisible tree or a new render, then showing\n\t// this boundary is ok.\n\trenderDidSuspend();}else {// Otherwise, we're going to have to hide content so we should\n\t// suspend for longer if possible.\n\trenderDidSuspendDelayIfPossible();}}}}var wakeables=workInProgress.updateQueue;if(wakeables!==null){// Schedule an effect to attach a retry listener to the promise.\n\t// TODO: Move to passive phase\n\tworkInProgress.flags|=Update;}bubbleProperties(workInProgress);{if((workInProgress.mode&ProfileMode)!==NoMode){if(nextDidTimeout){// Don't count time spent in a timed out Suspense subtree as part of the base duration.\n\tvar primaryChildFragment=workInProgress.child;if(primaryChildFragment!==null){// $FlowFixMe Flow doesn't support type casting in combination with the -= operator\n\tworkInProgress.treeBaseDuration-=primaryChildFragment.treeBaseDuration;}}}}return null;}case HostPortal:popHostContainer(workInProgress);updateHostContainer(current,workInProgress);if(current===null){preparePortalMount(workInProgress.stateNode.containerInfo);}bubbleProperties(workInProgress);return null;case ContextProvider:// Pop provider fiber\n\tvar context=workInProgress.type._context;popProvider(context,workInProgress);bubbleProperties(workInProgress);return null;case IncompleteClassComponent:{// Same as class component case. I put it down here so that the tags are\n\t// sequential to ensure this switch is compiled to a jump table.\n\tvar _Component=workInProgress.type;if(isContextProvider(_Component)){popContext(workInProgress);}bubbleProperties(workInProgress);return null;}case SuspenseListComponent:{popSuspenseContext(workInProgress);var renderState=workInProgress.memoizedState;if(renderState===null){// We're running in the default, \"independent\" mode.\n\t// We don't do anything in this mode.\n\tbubbleProperties(workInProgress);return null;}var didSuspendAlready=(workInProgress.flags&DidCapture)!==NoFlags;var renderedTail=renderState.rendering;if(renderedTail===null){// We just rendered the head.\n\tif(!didSuspendAlready){// This is the first pass. We need to figure out if anything is still\n\t// suspended in the rendered set.\n\t// If new content unsuspended, but there's still some content that\n\t// didn't. Then we need to do a second pass that forces everything\n\t// to keep showing their fallbacks.\n\t// We might be suspended if something in this render pass suspended, or\n\t// something in the previous committed pass suspended. Otherwise,\n\t// there's no chance so we can skip the expensive call to\n\t// findFirstSuspended.\n\tvar cannotBeSuspended=renderHasNotSuspendedYet()&&(current===null||(current.flags&DidCapture)===NoFlags);if(!cannotBeSuspended){var row=workInProgress.child;while(row!==null){var suspended=findFirstSuspended(row);if(suspended!==null){didSuspendAlready=true;workInProgress.flags|=DidCapture;cutOffTailIfNeeded(renderState,false);// If this is a newly suspended tree, it might not get committed as\n\t// part of the second pass. In that case nothing will subscribe to\n\t// its thenables. Instead, we'll transfer its thenables to the\n\t// SuspenseList so that it can retry if they resolve.\n\t// There might be multiple of these in the list but since we're\n\t// going to wait for all of them anyway, it doesn't really matter\n\t// which ones gets to ping. In theory we could get clever and keep\n\t// track of how many dependencies remain but it gets tricky because\n\t// in the meantime, we can add/remove/change items and dependencies.\n\t// We might bail out of the loop before finding any but that\n\t// doesn't matter since that means that the other boundaries that\n\t// we did find already has their listeners attached.\n\tvar newThenables=suspended.updateQueue;if(newThenables!==null){workInProgress.updateQueue=newThenables;workInProgress.flags|=Update;}// Rerender the whole list, but this time, we'll force fallbacks\n\t// to stay in place.\n\t// Reset the effect flags before doing the second pass since that's now invalid.\n\t// Reset the child fibers to their original state.\n\tworkInProgress.subtreeFlags=NoFlags;resetChildFibers(workInProgress,renderLanes);// Set up the Suspense Context to force suspense and immediately\n\t// rerender the children.\n\tpushSuspenseContext(workInProgress,setShallowSuspenseContext(suspenseStackCursor.current,ForceSuspenseFallback));// Don't bubble properties in this case.\n\treturn workInProgress.child;}row=row.sibling;}}if(renderState.tail!==null&&now()>getRenderTargetTime()){// We have already passed our CPU deadline but we still have rows\n\t// left in the tail. We'll just give up further attempts to render\n\t// the main content and only render fallbacks.\n\tworkInProgress.flags|=DidCapture;didSuspendAlready=true;cutOffTailIfNeeded(renderState,false);// Since nothing actually suspended, there will nothing to ping this\n\t// to get it started back up to attempt the next item. While in terms\n\t// of priority this work has the same priority as this current render,\n\t// it's not part of the same transition once the transition has\n\t// committed. If it's sync, we still want to yield so that it can be\n\t// painted. Conceptually, this is really the same as pinging.\n\t// We can use any RetryLane even if it's the one currently rendering\n\t// since we're leaving it behind on this node.\n\tworkInProgress.lanes=SomeRetryLane;}}else {cutOffTailIfNeeded(renderState,false);}// Next we're going to render the tail.\n\t}else {// Append the rendered row to the child list.\n\tif(!didSuspendAlready){var _suspended=findFirstSuspended(renderedTail);if(_suspended!==null){workInProgress.flags|=DidCapture;didSuspendAlready=true;// Ensure we transfer the update queue to the parent so that it doesn't\n\t// get lost if this row ends up dropped during a second pass.\n\tvar _newThenables=_suspended.updateQueue;if(_newThenables!==null){workInProgress.updateQueue=_newThenables;workInProgress.flags|=Update;}cutOffTailIfNeeded(renderState,true);// This might have been modified.\n\tif(renderState.tail===null&&renderState.tailMode==='hidden'&&!renderedTail.alternate&&!getIsHydrating()// We don't cut it if we're hydrating.\n\t){// We're done.\n\tbubbleProperties(workInProgress);return null;}}else if(// The time it took to render last row is greater than the remaining\n\t// time we have to render. So rendering one more row would likely\n\t// exceed it.\n\tnow()*2-renderState.renderingStartTime>getRenderTargetTime()&&renderLanes!==OffscreenLane){// We have now passed our CPU deadline and we'll just give up further\n\t// attempts to render the main content and only render fallbacks.\n\t// The assumption is that this is usually faster.\n\tworkInProgress.flags|=DidCapture;didSuspendAlready=true;cutOffTailIfNeeded(renderState,false);// Since nothing actually suspended, there will nothing to ping this\n\t// to get it started back up to attempt the next item. While in terms\n\t// of priority this work has the same priority as this current render,\n\t// it's not part of the same transition once the transition has\n\t// committed. If it's sync, we still want to yield so that it can be\n\t// painted. Conceptually, this is really the same as pinging.\n\t// We can use any RetryLane even if it's the one currently rendering\n\t// since we're leaving it behind on this node.\n\tworkInProgress.lanes=SomeRetryLane;}}if(renderState.isBackwards){// The effect list of the backwards tail will have been added\n\t// to the end. This breaks the guarantee that life-cycles fire in\n\t// sibling order but that isn't a strong guarantee promised by React.\n\t// Especially since these might also just pop in during future commits.\n\t// Append to the beginning of the list.\n\trenderedTail.sibling=workInProgress.child;workInProgress.child=renderedTail;}else {var previousSibling=renderState.last;if(previousSibling!==null){previousSibling.sibling=renderedTail;}else {workInProgress.child=renderedTail;}renderState.last=renderedTail;}}if(renderState.tail!==null){// We still have tail rows to render.\n\t// Pop a row.\n\tvar next=renderState.tail;renderState.rendering=next;renderState.tail=next.sibling;renderState.renderingStartTime=now();next.sibling=null;// Restore the context.\n\t// TODO: We can probably just avoid popping it instead and only\n\t// setting it the first time we go from not suspended to suspended.\n\tvar suspenseContext=suspenseStackCursor.current;if(didSuspendAlready){suspenseContext=setShallowSuspenseContext(suspenseContext,ForceSuspenseFallback);}else {suspenseContext=setDefaultShallowSuspenseContext(suspenseContext);}pushSuspenseContext(workInProgress,suspenseContext);// Do a pass over the next row.\n\t// Don't bubble properties in this case.\n\treturn next;}bubbleProperties(workInProgress);return null;}case ScopeComponent:{break;}case OffscreenComponent:case LegacyHiddenComponent:{popRenderLanes(workInProgress);var _nextState=workInProgress.memoizedState;var nextIsHidden=_nextState!==null;if(current!==null){var _prevState=current.memoizedState;var prevIsHidden=_prevState!==null;if(prevIsHidden!==nextIsHidden&&// LegacyHidden doesn't do any hiding — it only pre-renders.\n\t!enableLegacyHidden){workInProgress.flags|=Visibility;}}if(!nextIsHidden||(workInProgress.mode&ConcurrentMode)===NoMode){bubbleProperties(workInProgress);}else {// Don't bubble properties for hidden children unless we're rendering\n\t// at offscreen priority.\n\tif(includesSomeLane(subtreeRenderLanes,OffscreenLane)){bubbleProperties(workInProgress);{// Check if there was an insertion or update in the hidden subtree.\n\t// If so, we need to hide those nodes in the commit phase, so\n\t// schedule a visibility effect.\n\tif(workInProgress.subtreeFlags&(Placement|Update)){workInProgress.flags|=Visibility;}}}}return null;}case CacheComponent:{return null;}case TracingMarkerComponent:{return null;}}throw new Error(\"Unknown unit of work tag (\"+workInProgress.tag+\"). This error is likely caused by a bug in \"+'React. Please file an issue.');}function unwindWork(current,workInProgress,renderLanes){// Note: This intentionally doesn't check if we're hydrating because comparing\n\t// to the current tree provider fiber is just as fast and less error-prone.\n\t// Ideally we would have a special version of the work loop only\n\t// for hydration.\n\tpopTreeContext(workInProgress);switch(workInProgress.tag){case ClassComponent:{var Component=workInProgress.type;if(isContextProvider(Component)){popContext(workInProgress);}var flags=workInProgress.flags;if(flags&ShouldCapture){workInProgress.flags=flags&~ShouldCapture|DidCapture;if((workInProgress.mode&ProfileMode)!==NoMode){transferActualDuration(workInProgress);}return workInProgress;}return null;}case HostRoot:{workInProgress.stateNode;popHostContainer(workInProgress);popTopLevelContextObject(workInProgress);resetWorkInProgressVersions();var _flags=workInProgress.flags;if((_flags&ShouldCapture)!==NoFlags&&(_flags&DidCapture)===NoFlags){// There was an error during render that wasn't captured by a suspense\n\t// boundary. Do a second pass on the root to unmount the children.\n\tworkInProgress.flags=_flags&~ShouldCapture|DidCapture;return workInProgress;}// We unwound to the root without completing it. Exit.\n\treturn null;}case HostComponent:{// TODO: popHydrationState\n\tpopHostContext(workInProgress);return null;}case SuspenseComponent:{popSuspenseContext(workInProgress);var suspenseState=workInProgress.memoizedState;if(suspenseState!==null&&suspenseState.dehydrated!==null){if(workInProgress.alternate===null){throw new Error('Threw in newly mounted dehydrated component. This is likely a bug in '+'React. Please file an issue.');}resetHydrationState();}var _flags2=workInProgress.flags;if(_flags2&ShouldCapture){workInProgress.flags=_flags2&~ShouldCapture|DidCapture;// Captured a suspense effect. Re-render the boundary.\n\tif((workInProgress.mode&ProfileMode)!==NoMode){transferActualDuration(workInProgress);}return workInProgress;}return null;}case SuspenseListComponent:{popSuspenseContext(workInProgress);// SuspenseList doesn't actually catch anything. It should've been\n\t// caught by a nested boundary. If not, it should bubble through.\n\treturn null;}case HostPortal:popHostContainer(workInProgress);return null;case ContextProvider:var context=workInProgress.type._context;popProvider(context,workInProgress);return null;case OffscreenComponent:case LegacyHiddenComponent:popRenderLanes(workInProgress);return null;case CacheComponent:return null;default:return null;}}function unwindInterruptedWork(current,interruptedWork,renderLanes){// Note: This intentionally doesn't check if we're hydrating because comparing\n\t// to the current tree provider fiber is just as fast and less error-prone.\n\t// Ideally we would have a special version of the work loop only\n\t// for hydration.\n\tpopTreeContext(interruptedWork);switch(interruptedWork.tag){case ClassComponent:{var childContextTypes=interruptedWork.type.childContextTypes;if(childContextTypes!==null&&childContextTypes!==undefined){popContext(interruptedWork);}break;}case HostRoot:{interruptedWork.stateNode;popHostContainer(interruptedWork);popTopLevelContextObject(interruptedWork);resetWorkInProgressVersions();break;}case HostComponent:{popHostContext(interruptedWork);break;}case HostPortal:popHostContainer(interruptedWork);break;case SuspenseComponent:popSuspenseContext(interruptedWork);break;case SuspenseListComponent:popSuspenseContext(interruptedWork);break;case ContextProvider:var context=interruptedWork.type._context;popProvider(context,interruptedWork);break;case OffscreenComponent:case LegacyHiddenComponent:popRenderLanes(interruptedWork);break;}}var didWarnAboutUndefinedSnapshotBeforeUpdate=null;{didWarnAboutUndefinedSnapshotBeforeUpdate=new Set();}// Used during the commit phase to track the state of the Offscreen component stack.\n\t// Allows us to avoid traversing the return path to find the nearest Offscreen ancestor.\n\t// Only used when enableSuspenseLayoutEffectSemantics is enabled.\n\tvar offscreenSubtreeIsHidden=false;var offscreenSubtreeWasHidden=false;var PossiblyWeakSet=typeof WeakSet==='function'?WeakSet:Set;var nextEffect=null;// Used for Profiling builds to track updaters.\n\tvar inProgressLanes=null;var inProgressRoot=null;function reportUncaughtErrorInDEV(error){// Wrapping each small part of the commit phase into a guarded\n\t// callback is a bit too slow (https://github.com/facebook/react/pull/21666).\n\t// But we rely on it to surface errors to DEV tools like overlays\n\t// (https://github.com/facebook/react/issues/21712).\n\t// As a compromise, rethrow only caught errors in a guard.\n\t{invokeGuardedCallback(null,function(){throw error;});clearCaughtError();}}var callComponentWillUnmountWithTimer=function(current,instance){instance.props=current.memoizedProps;instance.state=current.memoizedState;if(current.mode&ProfileMode){try{startLayoutEffectTimer();instance.componentWillUnmount();}finally{recordLayoutEffectDuration(current);}}else {instance.componentWillUnmount();}};// Capture errors so they don't interrupt mounting.\n\tfunction safelyCallCommitHookLayoutEffectListMount(current,nearestMountedAncestor){try{commitHookEffectListMount(Layout,current);}catch(error){captureCommitPhaseError(current,nearestMountedAncestor,error);}}// Capture errors so they don't interrupt unmounting.\n\tfunction safelyCallComponentWillUnmount(current,nearestMountedAncestor,instance){try{callComponentWillUnmountWithTimer(current,instance);}catch(error){captureCommitPhaseError(current,nearestMountedAncestor,error);}}// Capture errors so they don't interrupt mounting.\n\tfunction safelyCallComponentDidMount(current,nearestMountedAncestor,instance){try{instance.componentDidMount();}catch(error){captureCommitPhaseError(current,nearestMountedAncestor,error);}}// Capture errors so they don't interrupt mounting.\n\tfunction safelyAttachRef(current,nearestMountedAncestor){try{commitAttachRef(current);}catch(error){captureCommitPhaseError(current,nearestMountedAncestor,error);}}function safelyDetachRef(current,nearestMountedAncestor){var ref=current.ref;if(ref!==null){if(typeof ref==='function'){var retVal;try{if(enableProfilerTimer&&enableProfilerCommitHooks&&current.mode&ProfileMode){try{startLayoutEffectTimer();retVal=ref(null);}finally{recordLayoutEffectDuration(current);}}else {retVal=ref(null);}}catch(error){captureCommitPhaseError(current,nearestMountedAncestor,error);}{if(typeof retVal==='function'){error('Unexpected return value from a callback ref in %s. '+'A callback ref should not return a function.',getComponentNameFromFiber(current));}}}else {ref.current=null;}}}function safelyCallDestroy(current,nearestMountedAncestor,destroy){try{destroy();}catch(error){captureCommitPhaseError(current,nearestMountedAncestor,error);}}var shouldFireAfterActiveInstanceBlur=false;function commitBeforeMutationEffects(root,firstChild){prepareForCommit(root.containerInfo);nextEffect=firstChild;commitBeforeMutationEffects_begin();// We no longer need to track the active instance fiber\n\tvar shouldFire=shouldFireAfterActiveInstanceBlur;shouldFireAfterActiveInstanceBlur=false;return shouldFire;}function commitBeforeMutationEffects_begin(){while(nextEffect!==null){var fiber=nextEffect;// This phase is only used for beforeActiveInstanceBlur.\n\tvar child=fiber.child;if((fiber.subtreeFlags&BeforeMutationMask)!==NoFlags&&child!==null){child.return=fiber;nextEffect=child;}else {commitBeforeMutationEffects_complete();}}}function commitBeforeMutationEffects_complete(){while(nextEffect!==null){var fiber=nextEffect;setCurrentFiber(fiber);try{commitBeforeMutationEffectsOnFiber(fiber);}catch(error){captureCommitPhaseError(fiber,fiber.return,error);}resetCurrentFiber();var sibling=fiber.sibling;if(sibling!==null){sibling.return=fiber.return;nextEffect=sibling;return;}nextEffect=fiber.return;}}function commitBeforeMutationEffectsOnFiber(finishedWork){var current=finishedWork.alternate;var flags=finishedWork.flags;if((flags&Snapshot)!==NoFlags){setCurrentFiber(finishedWork);switch(finishedWork.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{break;}case ClassComponent:{if(current!==null){var prevProps=current.memoizedProps;var prevState=current.memoizedState;var instance=finishedWork.stateNode;// We could update instance props and state here,\n\t// but instead we rely on them being set during last render.\n\t// TODO: revisit this when we implement resuming.\n\t{if(finishedWork.type===finishedWork.elementType&&!didWarnAboutReassigningProps){if(instance.props!==finishedWork.memoizedProps){error('Expected %s props to match memoized props before '+'getSnapshotBeforeUpdate. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.props`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}if(instance.state!==finishedWork.memoizedState){error('Expected %s state to match memoized state before '+'getSnapshotBeforeUpdate. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.state`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}}}var snapshot=instance.getSnapshotBeforeUpdate(finishedWork.elementType===finishedWork.type?prevProps:resolveDefaultProps(finishedWork.type,prevProps),prevState);{var didWarnSet=didWarnAboutUndefinedSnapshotBeforeUpdate;if(snapshot===undefined&&!didWarnSet.has(finishedWork.type)){didWarnSet.add(finishedWork.type);error('%s.getSnapshotBeforeUpdate(): A snapshot value (or null) '+'must be returned. You have returned undefined.',getComponentNameFromFiber(finishedWork));}}instance.__reactInternalSnapshotBeforeUpdate=snapshot;}break;}case HostRoot:{{var root=finishedWork.stateNode;clearContainer(root.containerInfo);}break;}case HostComponent:case HostText:case HostPortal:case IncompleteClassComponent:// Nothing to do for these component types\n\tbreak;default:{throw new Error('This unit of work tag should not have side-effects. This error is '+'likely caused by a bug in React. Please file an issue.');}}resetCurrentFiber();}}function commitHookEffectListUnmount(flags,finishedWork,nearestMountedAncestor){var updateQueue=finishedWork.updateQueue;var lastEffect=updateQueue!==null?updateQueue.lastEffect:null;if(lastEffect!==null){var firstEffect=lastEffect.next;var effect=firstEffect;do{if((effect.tag&flags)===flags){// Unmount\n\tvar destroy=effect.destroy;effect.destroy=undefined;if(destroy!==undefined){{if((flags&Passive$1)!==NoFlags$1){markComponentPassiveEffectUnmountStarted(finishedWork);}else if((flags&Layout)!==NoFlags$1){markComponentLayoutEffectUnmountStarted(finishedWork);}}{if((flags&Insertion)!==NoFlags$1){setIsRunningInsertionEffect(true);}}safelyCallDestroy(finishedWork,nearestMountedAncestor,destroy);{if((flags&Insertion)!==NoFlags$1){setIsRunningInsertionEffect(false);}}{if((flags&Passive$1)!==NoFlags$1){markComponentPassiveEffectUnmountStopped();}else if((flags&Layout)!==NoFlags$1){markComponentLayoutEffectUnmountStopped();}}}}effect=effect.next;}while(effect!==firstEffect);}}function commitHookEffectListMount(flags,finishedWork){var updateQueue=finishedWork.updateQueue;var lastEffect=updateQueue!==null?updateQueue.lastEffect:null;if(lastEffect!==null){var firstEffect=lastEffect.next;var effect=firstEffect;do{if((effect.tag&flags)===flags){{if((flags&Passive$1)!==NoFlags$1){markComponentPassiveEffectMountStarted(finishedWork);}else if((flags&Layout)!==NoFlags$1){markComponentLayoutEffectMountStarted(finishedWork);}}// Mount\n\tvar create=effect.create;{if((flags&Insertion)!==NoFlags$1){setIsRunningInsertionEffect(true);}}effect.destroy=create();{if((flags&Insertion)!==NoFlags$1){setIsRunningInsertionEffect(false);}}{if((flags&Passive$1)!==NoFlags$1){markComponentPassiveEffectMountStopped();}else if((flags&Layout)!==NoFlags$1){markComponentLayoutEffectMountStopped();}}{var destroy=effect.destroy;if(destroy!==undefined&&typeof destroy!=='function'){var hookName=void 0;if((effect.tag&Layout)!==NoFlags){hookName='useLayoutEffect';}else if((effect.tag&Insertion)!==NoFlags){hookName='useInsertionEffect';}else {hookName='useEffect';}var addendum=void 0;if(destroy===null){addendum=' You returned null. If your effect does not require clean '+'up, return undefined (or nothing).';}else if(typeof destroy.then==='function'){addendum='\\n\\nIt looks like you wrote '+hookName+'(async () => ...) or returned a Promise. '+'Instead, write the async function inside your effect '+'and call it immediately:\\n\\n'+hookName+'(() => {\\n'+'  async function fetchData() {\\n'+'    // You can await here\\n'+'    const response = await MyAPI.getData(someId);\\n'+'    // ...\\n'+'  }\\n'+'  fetchData();\\n'+\"}, [someId]); // Or [] if effect doesn't need props or state\\n\\n\"+'Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching';}else {addendum=' You returned: '+destroy;}error('%s must not return anything besides a function, '+'which is used for clean-up.%s',hookName,addendum);}}}effect=effect.next;}while(effect!==firstEffect);}}function commitPassiveEffectDurations(finishedRoot,finishedWork){{// Only Profilers with work in their subtree will have an Update effect scheduled.\n\tif((finishedWork.flags&Update)!==NoFlags){switch(finishedWork.tag){case Profiler:{var passiveEffectDuration=finishedWork.stateNode.passiveEffectDuration;var _finishedWork$memoize=finishedWork.memoizedProps,id=_finishedWork$memoize.id,onPostCommit=_finishedWork$memoize.onPostCommit;// This value will still reflect the previous commit phase.\n\t// It does not get reset until the start of the next commit phase.\n\tvar commitTime=getCommitTime();var phase=finishedWork.alternate===null?'mount':'update';{if(isCurrentUpdateNested()){phase='nested-update';}}if(typeof onPostCommit==='function'){onPostCommit(id,phase,passiveEffectDuration,commitTime);}// Bubble times to the next nearest ancestor Profiler.\n\t// After we process that Profiler, we'll bubble further up.\n\tvar parentFiber=finishedWork.return;outer:while(parentFiber!==null){switch(parentFiber.tag){case HostRoot:var root=parentFiber.stateNode;root.passiveEffectDuration+=passiveEffectDuration;break outer;case Profiler:var parentStateNode=parentFiber.stateNode;parentStateNode.passiveEffectDuration+=passiveEffectDuration;break outer;}parentFiber=parentFiber.return;}break;}}}}}function commitLayoutEffectOnFiber(finishedRoot,current,finishedWork,committedLanes){if((finishedWork.flags&LayoutMask)!==NoFlags){switch(finishedWork.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{if(!offscreenSubtreeWasHidden){// At this point layout effects have already been destroyed (during mutation phase).\n\t// This is done to prevent sibling component effects from interfering with each other,\n\t// e.g. a destroy function in one component should never override a ref set\n\t// by a create function in another component during the same commit.\n\tif(finishedWork.mode&ProfileMode){try{startLayoutEffectTimer();commitHookEffectListMount(Layout|HasEffect,finishedWork);}finally{recordLayoutEffectDuration(finishedWork);}}else {commitHookEffectListMount(Layout|HasEffect,finishedWork);}}break;}case ClassComponent:{var instance=finishedWork.stateNode;if(finishedWork.flags&Update){if(!offscreenSubtreeWasHidden){if(current===null){// We could update instance props and state here,\n\t// but instead we rely on them being set during last render.\n\t// TODO: revisit this when we implement resuming.\n\t{if(finishedWork.type===finishedWork.elementType&&!didWarnAboutReassigningProps){if(instance.props!==finishedWork.memoizedProps){error('Expected %s props to match memoized props before '+'componentDidMount. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.props`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}if(instance.state!==finishedWork.memoizedState){error('Expected %s state to match memoized state before '+'componentDidMount. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.state`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}}}if(finishedWork.mode&ProfileMode){try{startLayoutEffectTimer();instance.componentDidMount();}finally{recordLayoutEffectDuration(finishedWork);}}else {instance.componentDidMount();}}else {var prevProps=finishedWork.elementType===finishedWork.type?current.memoizedProps:resolveDefaultProps(finishedWork.type,current.memoizedProps);var prevState=current.memoizedState;// We could update instance props and state here,\n\t// but instead we rely on them being set during last render.\n\t// TODO: revisit this when we implement resuming.\n\t{if(finishedWork.type===finishedWork.elementType&&!didWarnAboutReassigningProps){if(instance.props!==finishedWork.memoizedProps){error('Expected %s props to match memoized props before '+'componentDidUpdate. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.props`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}if(instance.state!==finishedWork.memoizedState){error('Expected %s state to match memoized state before '+'componentDidUpdate. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.state`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}}}if(finishedWork.mode&ProfileMode){try{startLayoutEffectTimer();instance.componentDidUpdate(prevProps,prevState,instance.__reactInternalSnapshotBeforeUpdate);}finally{recordLayoutEffectDuration(finishedWork);}}else {instance.componentDidUpdate(prevProps,prevState,instance.__reactInternalSnapshotBeforeUpdate);}}}}// TODO: I think this is now always non-null by the time it reaches the\n\t// commit phase. Consider removing the type check.\n\tvar updateQueue=finishedWork.updateQueue;if(updateQueue!==null){{if(finishedWork.type===finishedWork.elementType&&!didWarnAboutReassigningProps){if(instance.props!==finishedWork.memoizedProps){error('Expected %s props to match memoized props before '+'processing the update queue. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.props`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}if(instance.state!==finishedWork.memoizedState){error('Expected %s state to match memoized state before '+'processing the update queue. '+'This might either be because of a bug in React, or because '+'a component reassigns its own `this.state`. '+'Please file an issue.',getComponentNameFromFiber(finishedWork)||'instance');}}}// We could update instance props and state here,\n\t// but instead we rely on them being set during last render.\n\t// TODO: revisit this when we implement resuming.\n\tcommitUpdateQueue(finishedWork,updateQueue,instance);}break;}case HostRoot:{// TODO: I think this is now always non-null by the time it reaches the\n\t// commit phase. Consider removing the type check.\n\tvar _updateQueue=finishedWork.updateQueue;if(_updateQueue!==null){var _instance=null;if(finishedWork.child!==null){switch(finishedWork.child.tag){case HostComponent:_instance=getPublicInstance(finishedWork.child.stateNode);break;case ClassComponent:_instance=finishedWork.child.stateNode;break;}}commitUpdateQueue(finishedWork,_updateQueue,_instance);}break;}case HostComponent:{var _instance2=finishedWork.stateNode;// Renderers may schedule work to be done after host components are mounted\n\t// (eg DOM renderer may schedule auto-focus for inputs and form controls).\n\t// These effects should only be committed when components are first mounted,\n\t// aka when there is no current/alternate.\n\tif(current===null&&finishedWork.flags&Update){var type=finishedWork.type;var props=finishedWork.memoizedProps;commitMount(_instance2,type,props);}break;}case HostText:{// We have no life-cycles associated with text.\n\tbreak;}case HostPortal:{// We have no life-cycles associated with portals.\n\tbreak;}case Profiler:{{var _finishedWork$memoize2=finishedWork.memoizedProps,onCommit=_finishedWork$memoize2.onCommit,onRender=_finishedWork$memoize2.onRender;var effectDuration=finishedWork.stateNode.effectDuration;var commitTime=getCommitTime();var phase=current===null?'mount':'update';{if(isCurrentUpdateNested()){phase='nested-update';}}if(typeof onRender==='function'){onRender(finishedWork.memoizedProps.id,phase,finishedWork.actualDuration,finishedWork.treeBaseDuration,finishedWork.actualStartTime,commitTime);}{if(typeof onCommit==='function'){onCommit(finishedWork.memoizedProps.id,phase,effectDuration,commitTime);}// Schedule a passive effect for this Profiler to call onPostCommit hooks.\n\t// This effect should be scheduled even if there is no onPostCommit callback for this Profiler,\n\t// because the effect is also where times bubble to parent Profilers.\n\tenqueuePendingPassiveProfilerEffect(finishedWork);// Propagate layout effect durations to the next nearest Profiler ancestor.\n\t// Do not reset these values until the next render so DevTools has a chance to read them first.\n\tvar parentFiber=finishedWork.return;outer:while(parentFiber!==null){switch(parentFiber.tag){case HostRoot:var root=parentFiber.stateNode;root.effectDuration+=effectDuration;break outer;case Profiler:var parentStateNode=parentFiber.stateNode;parentStateNode.effectDuration+=effectDuration;break outer;}parentFiber=parentFiber.return;}}}break;}case SuspenseComponent:{commitSuspenseHydrationCallbacks(finishedRoot,finishedWork);break;}case SuspenseListComponent:case IncompleteClassComponent:case ScopeComponent:case OffscreenComponent:case LegacyHiddenComponent:case TracingMarkerComponent:{break;}default:throw new Error('This unit of work tag should not have side-effects. This error is '+'likely caused by a bug in React. Please file an issue.');}}if(!offscreenSubtreeWasHidden){{if(finishedWork.flags&Ref){commitAttachRef(finishedWork);}}}}function reappearLayoutEffectsOnFiber(node){// Turn on layout effects in a tree that previously disappeared.\n\t// TODO (Offscreen) Check: flags & LayoutStatic\n\tswitch(node.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{if(node.mode&ProfileMode){try{startLayoutEffectTimer();safelyCallCommitHookLayoutEffectListMount(node,node.return);}finally{recordLayoutEffectDuration(node);}}else {safelyCallCommitHookLayoutEffectListMount(node,node.return);}break;}case ClassComponent:{var instance=node.stateNode;if(typeof instance.componentDidMount==='function'){safelyCallComponentDidMount(node,node.return,instance);}safelyAttachRef(node,node.return);break;}case HostComponent:{safelyAttachRef(node,node.return);break;}}}function hideOrUnhideAllChildren(finishedWork,isHidden){// Only hide or unhide the top-most host nodes.\n\tvar hostSubtreeRoot=null;{// We only have the top Fiber that was inserted but we need to recurse down its\n\t// children to find all the terminal nodes.\n\tvar node=finishedWork;while(true){if(node.tag===HostComponent){if(hostSubtreeRoot===null){hostSubtreeRoot=node;try{var instance=node.stateNode;if(isHidden){hideInstance(instance);}else {unhideInstance(node.stateNode,node.memoizedProps);}}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}}}else if(node.tag===HostText){if(hostSubtreeRoot===null){try{var _instance3=node.stateNode;if(isHidden){hideTextInstance(_instance3);}else {unhideTextInstance(_instance3,node.memoizedProps);}}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}}}else if((node.tag===OffscreenComponent||node.tag===LegacyHiddenComponent)&&node.memoizedState!==null&&node!==finishedWork);else if(node.child!==null){node.child.return=node;node=node.child;continue;}if(node===finishedWork){return;}while(node.sibling===null){if(node.return===null||node.return===finishedWork){return;}if(hostSubtreeRoot===node){hostSubtreeRoot=null;}node=node.return;}if(hostSubtreeRoot===node){hostSubtreeRoot=null;}node.sibling.return=node.return;node=node.sibling;}}}function commitAttachRef(finishedWork){var ref=finishedWork.ref;if(ref!==null){var instance=finishedWork.stateNode;var instanceToUse;switch(finishedWork.tag){case HostComponent:instanceToUse=getPublicInstance(instance);break;default:instanceToUse=instance;}// Moved outside to ensure DCE works with this flag\n\tif(typeof ref==='function'){var retVal;if(finishedWork.mode&ProfileMode){try{startLayoutEffectTimer();retVal=ref(instanceToUse);}finally{recordLayoutEffectDuration(finishedWork);}}else {retVal=ref(instanceToUse);}{if(typeof retVal==='function'){error('Unexpected return value from a callback ref in %s. '+'A callback ref should not return a function.',getComponentNameFromFiber(finishedWork));}}}else {{if(!ref.hasOwnProperty('current')){error('Unexpected ref object provided for %s. '+'Use either a ref-setter function or React.createRef().',getComponentNameFromFiber(finishedWork));}}ref.current=instanceToUse;}}}function detachFiberMutation(fiber){// Cut off the return pointer to disconnect it from the tree.\n\t// This enables us to detect and warn against state updates on an unmounted component.\n\t// It also prevents events from bubbling from within disconnected components.\n\t//\n\t// Ideally, we should also clear the child pointer of the parent alternate to let this\n\t// get GC:ed but we don't know which for sure which parent is the current\n\t// one so we'll settle for GC:ing the subtree of this child.\n\t// This child itself will be GC:ed when the parent updates the next time.\n\t//\n\t// Note that we can't clear child or sibling pointers yet.\n\t// They're needed for passive effects and for findDOMNode.\n\t// We defer those fields, and all other cleanup, to the passive phase (see detachFiberAfterEffects).\n\t//\n\t// Don't reset the alternate yet, either. We need that so we can detach the\n\t// alternate's fields in the passive phase. Clearing the return pointer is\n\t// sufficient for findDOMNode semantics.\n\tvar alternate=fiber.alternate;if(alternate!==null){alternate.return=null;}fiber.return=null;}function detachFiberAfterEffects(fiber){var alternate=fiber.alternate;if(alternate!==null){fiber.alternate=null;detachFiberAfterEffects(alternate);}// Note: Defensively using negation instead of < in case\n\t// `deletedTreeCleanUpLevel` is undefined.\n\t{// Clear cyclical Fiber fields. This level alone is designed to roughly\n\t// approximate the planned Fiber refactor. In that world, `setState` will be\n\t// bound to a special \"instance\" object instead of a Fiber. The Instance\n\t// object will not have any of these fields. It will only be connected to\n\t// the fiber tree via a single link at the root. So if this level alone is\n\t// sufficient to fix memory issues, that bodes well for our plans.\n\tfiber.child=null;fiber.deletions=null;fiber.sibling=null;// The `stateNode` is cyclical because on host nodes it points to the host\n\t// tree, which has its own pointers to children, parents, and siblings.\n\t// The other host nodes also point back to fibers, so we should detach that\n\t// one, too.\n\tif(fiber.tag===HostComponent){var hostInstance=fiber.stateNode;if(hostInstance!==null){detachDeletedInstance(hostInstance);}}fiber.stateNode=null;// I'm intentionally not clearing the `return` field in this level. We\n\t// already disconnect the `return` pointer at the root of the deleted\n\t// subtree (in `detachFiberMutation`). Besides, `return` by itself is not\n\t// cyclical — it's only cyclical when combined with `child`, `sibling`, and\n\t// `alternate`. But we'll clear it in the next level anyway, just in case.\n\t{fiber._debugOwner=null;}{// Theoretically, nothing in here should be necessary, because we already\n\t// disconnected the fiber from the tree. So even if something leaks this\n\t// particular fiber, it won't leak anything else\n\t//\n\t// The purpose of this branch is to be super aggressive so we can measure\n\t// if there's any difference in memory impact. If there is, that could\n\t// indicate a React leak we don't know about.\n\tfiber.return=null;fiber.dependencies=null;fiber.memoizedProps=null;fiber.memoizedState=null;fiber.pendingProps=null;fiber.stateNode=null;// TODO: Move to `commitPassiveUnmountInsideDeletedTreeOnFiber` instead.\n\tfiber.updateQueue=null;}}}function getHostParentFiber(fiber){var parent=fiber.return;while(parent!==null){if(isHostParent(parent)){return parent;}parent=parent.return;}throw new Error('Expected to find a host parent. This error is likely caused by a bug '+'in React. Please file an issue.');}function isHostParent(fiber){return fiber.tag===HostComponent||fiber.tag===HostRoot||fiber.tag===HostPortal;}function getHostSibling(fiber){// We're going to search forward into the tree until we find a sibling host\n\t// node. Unfortunately, if multiple insertions are done in a row we have to\n\t// search past them. This leads to exponential search for the next sibling.\n\t// TODO: Find a more efficient way to do this.\n\tvar node=fiber;siblings:while(true){// If we didn't find anything, let's try the next sibling.\n\twhile(node.sibling===null){if(node.return===null||isHostParent(node.return)){// If we pop out of the root or hit the parent the fiber we are the\n\t// last sibling.\n\treturn null;}node=node.return;}node.sibling.return=node.return;node=node.sibling;while(node.tag!==HostComponent&&node.tag!==HostText&&node.tag!==DehydratedFragment){// If it is not host node and, we might have a host node inside it.\n\t// Try to search down until we find one.\n\tif(node.flags&Placement){// If we don't have a child, try the siblings instead.\n\tcontinue siblings;}// If we don't have a child, try the siblings instead.\n\t// We also skip portals because they are not part of this host tree.\n\tif(node.child===null||node.tag===HostPortal){continue siblings;}else {node.child.return=node;node=node.child;}}// Check if this host node is stable or about to be placed.\n\tif(!(node.flags&Placement)){// Found it!\n\treturn node.stateNode;}}}function commitPlacement(finishedWork){var parentFiber=getHostParentFiber(finishedWork);// Note: these two variables *must* always be updated together.\n\tswitch(parentFiber.tag){case HostComponent:{var parent=parentFiber.stateNode;if(parentFiber.flags&ContentReset){// Reset the text content of the parent before doing any insertions\n\tresetTextContent(parent);// Clear ContentReset from the effect tag\n\tparentFiber.flags&=~ContentReset;}var before=getHostSibling(finishedWork);// We only have the top Fiber that was inserted but we need to recurse down its\n\t// children to find all the terminal nodes.\n\tinsertOrAppendPlacementNode(finishedWork,before,parent);break;}case HostRoot:case HostPortal:{var _parent=parentFiber.stateNode.containerInfo;var _before=getHostSibling(finishedWork);insertOrAppendPlacementNodeIntoContainer(finishedWork,_before,_parent);break;}// eslint-disable-next-line-no-fallthrough\n\tdefault:throw new Error('Invalid host parent fiber. This error is likely caused by a bug '+'in React. Please file an issue.');}}function insertOrAppendPlacementNodeIntoContainer(node,before,parent){var tag=node.tag;var isHost=tag===HostComponent||tag===HostText;if(isHost){var stateNode=node.stateNode;if(before){insertInContainerBefore(parent,stateNode,before);}else {appendChildToContainer(parent,stateNode);}}else if(tag===HostPortal);else {var child=node.child;if(child!==null){insertOrAppendPlacementNodeIntoContainer(child,before,parent);var sibling=child.sibling;while(sibling!==null){insertOrAppendPlacementNodeIntoContainer(sibling,before,parent);sibling=sibling.sibling;}}}}function insertOrAppendPlacementNode(node,before,parent){var tag=node.tag;var isHost=tag===HostComponent||tag===HostText;if(isHost){var stateNode=node.stateNode;if(before){insertBefore(parent,stateNode,before);}else {appendChild(parent,stateNode);}}else if(tag===HostPortal);else {var child=node.child;if(child!==null){insertOrAppendPlacementNode(child,before,parent);var sibling=child.sibling;while(sibling!==null){insertOrAppendPlacementNode(sibling,before,parent);sibling=sibling.sibling;}}}}// These are tracked on the stack as we recursively traverse a\n\t// deleted subtree.\n\t// TODO: Update these during the whole mutation phase, not just during\n\t// a deletion.\n\tvar hostParent=null;var hostParentIsContainer=false;function commitDeletionEffects(root,returnFiber,deletedFiber){{// We only have the top Fiber that was deleted but we need to recurse down its\n\t// children to find all the terminal nodes.\n\t// Recursively delete all host nodes from the parent, detach refs, clean\n\t// up mounted layout effects, and call componentWillUnmount.\n\t// We only need to remove the topmost host child in each branch. But then we\n\t// still need to keep traversing to unmount effects, refs, and cWU. TODO: We\n\t// could split this into two separate traversals functions, where the second\n\t// one doesn't include any removeChild logic. This is maybe the same\n\t// function as \"disappearLayoutEffects\" (or whatever that turns into after\n\t// the layout phase is refactored to use recursion).\n\t// Before starting, find the nearest host parent on the stack so we know\n\t// which instance/container to remove the children from.\n\t// TODO: Instead of searching up the fiber return path on every deletion, we\n\t// can track the nearest host component on the JS stack as we traverse the\n\t// tree during the commit phase. This would make insertions faster, too.\n\tvar parent=returnFiber;findParent:while(parent!==null){switch(parent.tag){case HostComponent:{hostParent=parent.stateNode;hostParentIsContainer=false;break findParent;}case HostRoot:{hostParent=parent.stateNode.containerInfo;hostParentIsContainer=true;break findParent;}case HostPortal:{hostParent=parent.stateNode.containerInfo;hostParentIsContainer=true;break findParent;}}parent=parent.return;}if(hostParent===null){throw new Error('Expected to find a host parent. This error is likely caused by '+'a bug in React. Please file an issue.');}commitDeletionEffectsOnFiber(root,returnFiber,deletedFiber);hostParent=null;hostParentIsContainer=false;}detachFiberMutation(deletedFiber);}function recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,parent){// TODO: Use a static flag to skip trees that don't have unmount effects\n\tvar child=parent.child;while(child!==null){commitDeletionEffectsOnFiber(finishedRoot,nearestMountedAncestor,child);child=child.sibling;}}function commitDeletionEffectsOnFiber(finishedRoot,nearestMountedAncestor,deletedFiber){onCommitUnmount(deletedFiber);// The cases in this outer switch modify the stack before they traverse\n\t// into their subtree. There are simpler cases in the inner switch\n\t// that don't modify the stack.\n\tswitch(deletedFiber.tag){case HostComponent:{if(!offscreenSubtreeWasHidden){safelyDetachRef(deletedFiber,nearestMountedAncestor);}// Intentional fallthrough to next branch\n\t}// eslint-disable-next-line-no-fallthrough\n\tcase HostText:{// We only need to remove the nearest host child. Set the host parent\n\t// to `null` on the stack to indicate that nested children don't\n\t// need to be removed.\n\t{var prevHostParent=hostParent;var prevHostParentIsContainer=hostParentIsContainer;hostParent=null;recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);hostParent=prevHostParent;hostParentIsContainer=prevHostParentIsContainer;if(hostParent!==null){// Now that all the child effects have unmounted, we can remove the\n\t// node from the tree.\n\tif(hostParentIsContainer){removeChildFromContainer(hostParent,deletedFiber.stateNode);}else {removeChild(hostParent,deletedFiber.stateNode);}}}return;}case DehydratedFragment:{// Delete the dehydrated suspense boundary and all of its content.\n\t{if(hostParent!==null){if(hostParentIsContainer){clearSuspenseBoundaryFromContainer(hostParent,deletedFiber.stateNode);}else {clearSuspenseBoundary(hostParent,deletedFiber.stateNode);}}}return;}case HostPortal:{{// When we go into a portal, it becomes the parent to remove from.\n\tvar _prevHostParent=hostParent;var _prevHostParentIsContainer=hostParentIsContainer;hostParent=deletedFiber.stateNode.containerInfo;hostParentIsContainer=true;recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);hostParent=_prevHostParent;hostParentIsContainer=_prevHostParentIsContainer;}return;}case FunctionComponent:case ForwardRef:case MemoComponent:case SimpleMemoComponent:{if(!offscreenSubtreeWasHidden){var updateQueue=deletedFiber.updateQueue;if(updateQueue!==null){var lastEffect=updateQueue.lastEffect;if(lastEffect!==null){var firstEffect=lastEffect.next;var effect=firstEffect;do{var _effect=effect,destroy=_effect.destroy,tag=_effect.tag;if(destroy!==undefined){if((tag&Insertion)!==NoFlags$1){safelyCallDestroy(deletedFiber,nearestMountedAncestor,destroy);}else if((tag&Layout)!==NoFlags$1){{markComponentLayoutEffectUnmountStarted(deletedFiber);}if(deletedFiber.mode&ProfileMode){startLayoutEffectTimer();safelyCallDestroy(deletedFiber,nearestMountedAncestor,destroy);recordLayoutEffectDuration(deletedFiber);}else {safelyCallDestroy(deletedFiber,nearestMountedAncestor,destroy);}{markComponentLayoutEffectUnmountStopped();}}}effect=effect.next;}while(effect!==firstEffect);}}}recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);return;}case ClassComponent:{if(!offscreenSubtreeWasHidden){safelyDetachRef(deletedFiber,nearestMountedAncestor);var instance=deletedFiber.stateNode;if(typeof instance.componentWillUnmount==='function'){safelyCallComponentWillUnmount(deletedFiber,nearestMountedAncestor,instance);}}recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);return;}case ScopeComponent:{recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);return;}case OffscreenComponent:{if(// TODO: Remove this dead flag\n\tdeletedFiber.mode&ConcurrentMode){// If this offscreen component is hidden, we already unmounted it. Before\n\t// deleting the children, track that it's already unmounted so that we\n\t// don't attempt to unmount the effects again.\n\t// TODO: If the tree is hidden, in most cases we should be able to skip\n\t// over the nested children entirely. An exception is we haven't yet found\n\t// the topmost host node to delete, which we already track on the stack.\n\t// But the other case is portals, which need to be detached no matter how\n\t// deeply they are nested. We should use a subtree flag to track whether a\n\t// subtree includes a nested portal.\n\tvar prevOffscreenSubtreeWasHidden=offscreenSubtreeWasHidden;offscreenSubtreeWasHidden=prevOffscreenSubtreeWasHidden||deletedFiber.memoizedState!==null;recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);offscreenSubtreeWasHidden=prevOffscreenSubtreeWasHidden;}else {recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);}break;}default:{recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);return;}}}function commitSuspenseCallback(finishedWork){// TODO: Move this to passive phase\n\tfinishedWork.memoizedState;}function commitSuspenseHydrationCallbacks(finishedRoot,finishedWork){var newState=finishedWork.memoizedState;if(newState===null){var current=finishedWork.alternate;if(current!==null){var prevState=current.memoizedState;if(prevState!==null){var suspenseInstance=prevState.dehydrated;if(suspenseInstance!==null){commitHydratedSuspenseInstance(suspenseInstance);}}}}}function attachSuspenseRetryListeners(finishedWork){// If this boundary just timed out, then it will have a set of wakeables.\n\t// For each wakeable, attach a listener so that when it resolves, React\n\t// attempts to re-render the boundary in the primary (pre-timeout) state.\n\tvar wakeables=finishedWork.updateQueue;if(wakeables!==null){finishedWork.updateQueue=null;var retryCache=finishedWork.stateNode;if(retryCache===null){retryCache=finishedWork.stateNode=new PossiblyWeakSet();}wakeables.forEach(function(wakeable){// Memoize using the boundary fiber to prevent redundant listeners.\n\tvar retry=resolveRetryWakeable.bind(null,finishedWork,wakeable);if(!retryCache.has(wakeable)){retryCache.add(wakeable);{if(isDevToolsPresent){if(inProgressLanes!==null&&inProgressRoot!==null){// If we have pending work still, associate the original updaters with it.\n\trestorePendingUpdaters(inProgressRoot,inProgressLanes);}else {throw Error('Expected finished root and lanes to be set. This is a bug in React.');}}}wakeable.then(retry,retry);}});}}// This function detects when a Suspense boundary goes from visible to hidden.\n\tfunction commitMutationEffects(root,finishedWork,committedLanes){inProgressLanes=committedLanes;inProgressRoot=root;setCurrentFiber(finishedWork);commitMutationEffectsOnFiber(finishedWork,root);setCurrentFiber(finishedWork);inProgressLanes=null;inProgressRoot=null;}function recursivelyTraverseMutationEffects(root,parentFiber,lanes){// Deletions effects can be scheduled on any fiber type. They need to happen\n\t// before the children effects hae fired.\n\tvar deletions=parentFiber.deletions;if(deletions!==null){for(var i=0;i<deletions.length;i++){var childToDelete=deletions[i];try{commitDeletionEffects(root,parentFiber,childToDelete);}catch(error){captureCommitPhaseError(childToDelete,parentFiber,error);}}}var prevDebugFiber=getCurrentFiber();if(parentFiber.subtreeFlags&MutationMask){var child=parentFiber.child;while(child!==null){setCurrentFiber(child);commitMutationEffectsOnFiber(child,root);child=child.sibling;}}setCurrentFiber(prevDebugFiber);}function commitMutationEffectsOnFiber(finishedWork,root,lanes){var current=finishedWork.alternate;var flags=finishedWork.flags;// The effect flag should be checked *after* we refine the type of fiber,\n\t// because the fiber tag is more specific. An exception is any flag related\n\t// to reconcilation, because those can be set on all fiber types.\n\tswitch(finishedWork.tag){case FunctionComponent:case ForwardRef:case MemoComponent:case SimpleMemoComponent:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);if(flags&Update){try{commitHookEffectListUnmount(Insertion|HasEffect,finishedWork,finishedWork.return);commitHookEffectListMount(Insertion|HasEffect,finishedWork);}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}// Layout effects are destroyed during the mutation phase so that all\n\t// destroy functions for all fibers are called before any create functions.\n\t// This prevents sibling component effects from interfering with each other,\n\t// e.g. a destroy function in one component should never override a ref set\n\t// by a create function in another component during the same commit.\n\tif(finishedWork.mode&ProfileMode){try{startLayoutEffectTimer();commitHookEffectListUnmount(Layout|HasEffect,finishedWork,finishedWork.return);}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}recordLayoutEffectDuration(finishedWork);}else {try{commitHookEffectListUnmount(Layout|HasEffect,finishedWork,finishedWork.return);}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}}}return;}case ClassComponent:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);if(flags&Ref){if(current!==null){safelyDetachRef(current,current.return);}}return;}case HostComponent:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);if(flags&Ref){if(current!==null){safelyDetachRef(current,current.return);}}{// TODO: ContentReset gets cleared by the children during the commit\n\t// phase. This is a refactor hazard because it means we must read\n\t// flags the flags after `commitReconciliationEffects` has already run;\n\t// the order matters. We should refactor so that ContentReset does not\n\t// rely on mutating the flag during commit. Like by setting a flag\n\t// during the render phase instead.\n\tif(finishedWork.flags&ContentReset){var instance=finishedWork.stateNode;try{resetTextContent(instance);}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}}if(flags&Update){var _instance4=finishedWork.stateNode;if(_instance4!=null){// Commit the work prepared earlier.\n\tvar newProps=finishedWork.memoizedProps;// For hydration we reuse the update path but we treat the oldProps\n\t// as the newProps. The updatePayload will contain the real change in\n\t// this case.\n\tvar oldProps=current!==null?current.memoizedProps:newProps;var type=finishedWork.type;// TODO: Type the updateQueue to be specific to host components.\n\tvar updatePayload=finishedWork.updateQueue;finishedWork.updateQueue=null;if(updatePayload!==null){try{commitUpdate(_instance4,updatePayload,type,oldProps,newProps,finishedWork);}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}}}}}return;}case HostText:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);if(flags&Update){{if(finishedWork.stateNode===null){throw new Error('This should have a text node initialized. This error is likely '+'caused by a bug in React. Please file an issue.');}var textInstance=finishedWork.stateNode;var newText=finishedWork.memoizedProps;// For hydration we reuse the update path but we treat the oldProps\n\t// as the newProps. The updatePayload will contain the real change in\n\t// this case.\n\tvar oldText=current!==null?current.memoizedProps:newText;try{commitTextUpdate(textInstance,oldText,newText);}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}}}return;}case HostRoot:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);if(flags&Update){{if(current!==null){var prevRootState=current.memoizedState;if(prevRootState.isDehydrated){try{commitHydratedContainer(root.containerInfo);}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}}}}}return;}case HostPortal:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);return;}case SuspenseComponent:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);var offscreenFiber=finishedWork.child;if(offscreenFiber.flags&Visibility){var offscreenInstance=offscreenFiber.stateNode;var newState=offscreenFiber.memoizedState;var isHidden=newState!==null;// Track the current state on the Offscreen instance so we can\n\t// read it during an event\n\toffscreenInstance.isHidden=isHidden;if(isHidden){var wasHidden=offscreenFiber.alternate!==null&&offscreenFiber.alternate.memoizedState!==null;if(!wasHidden){// TODO: Move to passive phase\n\tmarkCommitTimeOfFallback();}}}if(flags&Update){try{commitSuspenseCallback(finishedWork);}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}attachSuspenseRetryListeners(finishedWork);}return;}case OffscreenComponent:{var _wasHidden=current!==null&&current.memoizedState!==null;if(// TODO: Remove this dead flag\n\tfinishedWork.mode&ConcurrentMode){// Before committing the children, track on the stack whether this\n\t// offscreen subtree was already hidden, so that we don't unmount the\n\t// effects again.\n\tvar prevOffscreenSubtreeWasHidden=offscreenSubtreeWasHidden;offscreenSubtreeWasHidden=prevOffscreenSubtreeWasHidden||_wasHidden;recursivelyTraverseMutationEffects(root,finishedWork);offscreenSubtreeWasHidden=prevOffscreenSubtreeWasHidden;}else {recursivelyTraverseMutationEffects(root,finishedWork);}commitReconciliationEffects(finishedWork);if(flags&Visibility){var _offscreenInstance=finishedWork.stateNode;var _newState=finishedWork.memoizedState;var _isHidden=_newState!==null;var offscreenBoundary=finishedWork;// Track the current state on the Offscreen instance so we can\n\t// read it during an event\n\t_offscreenInstance.isHidden=_isHidden;{if(_isHidden){if(!_wasHidden){if((offscreenBoundary.mode&ConcurrentMode)!==NoMode){nextEffect=offscreenBoundary;var offscreenChild=offscreenBoundary.child;while(offscreenChild!==null){nextEffect=offscreenChild;disappearLayoutEffects_begin(offscreenChild);offscreenChild=offscreenChild.sibling;}}}}}{// TODO: This needs to run whenever there's an insertion or update\n\t// inside a hidden Offscreen tree.\n\thideOrUnhideAllChildren(offscreenBoundary,_isHidden);}}return;}case SuspenseListComponent:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);if(flags&Update){attachSuspenseRetryListeners(finishedWork);}return;}case ScopeComponent:{return;}default:{recursivelyTraverseMutationEffects(root,finishedWork);commitReconciliationEffects(finishedWork);return;}}}function commitReconciliationEffects(finishedWork){// Placement effects (insertions, reorders) can be scheduled on any fiber\n\t// type. They needs to happen after the children effects have fired, but\n\t// before the effects on this fiber have fired.\n\tvar flags=finishedWork.flags;if(flags&Placement){try{commitPlacement(finishedWork);}catch(error){captureCommitPhaseError(finishedWork,finishedWork.return,error);}// Clear the \"placement\" from effect tag so that we know that this is\n\t// inserted, before any life-cycles like componentDidMount gets called.\n\t// TODO: findDOMNode doesn't rely on this any more but isMounted does\n\t// and isMounted is deprecated anyway so we should be able to kill this.\n\tfinishedWork.flags&=~Placement;}if(flags&Hydrating){finishedWork.flags&=~Hydrating;}}function commitLayoutEffects(finishedWork,root,committedLanes){inProgressLanes=committedLanes;inProgressRoot=root;nextEffect=finishedWork;commitLayoutEffects_begin(finishedWork,root,committedLanes);inProgressLanes=null;inProgressRoot=null;}function commitLayoutEffects_begin(subtreeRoot,root,committedLanes){// Suspense layout effects semantics don't change for legacy roots.\n\tvar isModernRoot=(subtreeRoot.mode&ConcurrentMode)!==NoMode;while(nextEffect!==null){var fiber=nextEffect;var firstChild=fiber.child;if(fiber.tag===OffscreenComponent&&isModernRoot){// Keep track of the current Offscreen stack's state.\n\tvar isHidden=fiber.memoizedState!==null;var newOffscreenSubtreeIsHidden=isHidden||offscreenSubtreeIsHidden;if(newOffscreenSubtreeIsHidden){// The Offscreen tree is hidden. Skip over its layout effects.\n\tcommitLayoutMountEffects_complete(subtreeRoot,root,committedLanes);continue;}else {// TODO (Offscreen) Also check: subtreeFlags & LayoutMask\n\tvar current=fiber.alternate;var wasHidden=current!==null&&current.memoizedState!==null;var newOffscreenSubtreeWasHidden=wasHidden||offscreenSubtreeWasHidden;var prevOffscreenSubtreeIsHidden=offscreenSubtreeIsHidden;var prevOffscreenSubtreeWasHidden=offscreenSubtreeWasHidden;// Traverse the Offscreen subtree with the current Offscreen as the root.\n\toffscreenSubtreeIsHidden=newOffscreenSubtreeIsHidden;offscreenSubtreeWasHidden=newOffscreenSubtreeWasHidden;if(offscreenSubtreeWasHidden&&!prevOffscreenSubtreeWasHidden){// This is the root of a reappearing boundary. Turn its layout effects\n\t// back on.\n\tnextEffect=fiber;reappearLayoutEffects_begin(fiber);}var child=firstChild;while(child!==null){nextEffect=child;commitLayoutEffects_begin(child,// New root; bubble back up to here and stop.\n\troot,committedLanes);child=child.sibling;}// Restore Offscreen state and resume in our-progress traversal.\n\tnextEffect=fiber;offscreenSubtreeIsHidden=prevOffscreenSubtreeIsHidden;offscreenSubtreeWasHidden=prevOffscreenSubtreeWasHidden;commitLayoutMountEffects_complete(subtreeRoot,root,committedLanes);continue;}}if((fiber.subtreeFlags&LayoutMask)!==NoFlags&&firstChild!==null){firstChild.return=fiber;nextEffect=firstChild;}else {commitLayoutMountEffects_complete(subtreeRoot,root,committedLanes);}}}function commitLayoutMountEffects_complete(subtreeRoot,root,committedLanes){while(nextEffect!==null){var fiber=nextEffect;if((fiber.flags&LayoutMask)!==NoFlags){var current=fiber.alternate;setCurrentFiber(fiber);try{commitLayoutEffectOnFiber(root,current,fiber,committedLanes);}catch(error){captureCommitPhaseError(fiber,fiber.return,error);}resetCurrentFiber();}if(fiber===subtreeRoot){nextEffect=null;return;}var sibling=fiber.sibling;if(sibling!==null){sibling.return=fiber.return;nextEffect=sibling;return;}nextEffect=fiber.return;}}function disappearLayoutEffects_begin(subtreeRoot){while(nextEffect!==null){var fiber=nextEffect;var firstChild=fiber.child;// TODO (Offscreen) Check: flags & (RefStatic | LayoutStatic)\n\tswitch(fiber.tag){case FunctionComponent:case ForwardRef:case MemoComponent:case SimpleMemoComponent:{if(fiber.mode&ProfileMode){try{startLayoutEffectTimer();commitHookEffectListUnmount(Layout,fiber,fiber.return);}finally{recordLayoutEffectDuration(fiber);}}else {commitHookEffectListUnmount(Layout,fiber,fiber.return);}break;}case ClassComponent:{// TODO (Offscreen) Check: flags & RefStatic\n\tsafelyDetachRef(fiber,fiber.return);var instance=fiber.stateNode;if(typeof instance.componentWillUnmount==='function'){safelyCallComponentWillUnmount(fiber,fiber.return,instance);}break;}case HostComponent:{safelyDetachRef(fiber,fiber.return);break;}case OffscreenComponent:{// Check if this is a\n\tvar isHidden=fiber.memoizedState!==null;if(isHidden){// Nested Offscreen tree is already hidden. Don't disappear\n\t// its effects.\n\tdisappearLayoutEffects_complete(subtreeRoot);continue;}break;}}// TODO (Offscreen) Check: subtreeFlags & LayoutStatic\n\tif(firstChild!==null){firstChild.return=fiber;nextEffect=firstChild;}else {disappearLayoutEffects_complete(subtreeRoot);}}}function disappearLayoutEffects_complete(subtreeRoot){while(nextEffect!==null){var fiber=nextEffect;if(fiber===subtreeRoot){nextEffect=null;return;}var sibling=fiber.sibling;if(sibling!==null){sibling.return=fiber.return;nextEffect=sibling;return;}nextEffect=fiber.return;}}function reappearLayoutEffects_begin(subtreeRoot){while(nextEffect!==null){var fiber=nextEffect;var firstChild=fiber.child;if(fiber.tag===OffscreenComponent){var isHidden=fiber.memoizedState!==null;if(isHidden){// Nested Offscreen tree is still hidden. Don't re-appear its effects.\n\treappearLayoutEffects_complete(subtreeRoot);continue;}}// TODO (Offscreen) Check: subtreeFlags & LayoutStatic\n\tif(firstChild!==null){// This node may have been reused from a previous render, so we can't\n\t// assume its return pointer is correct.\n\tfirstChild.return=fiber;nextEffect=firstChild;}else {reappearLayoutEffects_complete(subtreeRoot);}}}function reappearLayoutEffects_complete(subtreeRoot){while(nextEffect!==null){var fiber=nextEffect;// TODO (Offscreen) Check: flags & LayoutStatic\n\tsetCurrentFiber(fiber);try{reappearLayoutEffectsOnFiber(fiber);}catch(error){captureCommitPhaseError(fiber,fiber.return,error);}resetCurrentFiber();if(fiber===subtreeRoot){nextEffect=null;return;}var sibling=fiber.sibling;if(sibling!==null){// This node may have been reused from a previous render, so we can't\n\t// assume its return pointer is correct.\n\tsibling.return=fiber.return;nextEffect=sibling;return;}nextEffect=fiber.return;}}function commitPassiveMountEffects(root,finishedWork,committedLanes,committedTransitions){nextEffect=finishedWork;commitPassiveMountEffects_begin(finishedWork,root,committedLanes,committedTransitions);}function commitPassiveMountEffects_begin(subtreeRoot,root,committedLanes,committedTransitions){while(nextEffect!==null){var fiber=nextEffect;var firstChild=fiber.child;if((fiber.subtreeFlags&PassiveMask)!==NoFlags&&firstChild!==null){firstChild.return=fiber;nextEffect=firstChild;}else {commitPassiveMountEffects_complete(subtreeRoot,root,committedLanes,committedTransitions);}}}function commitPassiveMountEffects_complete(subtreeRoot,root,committedLanes,committedTransitions){while(nextEffect!==null){var fiber=nextEffect;if((fiber.flags&Passive)!==NoFlags){setCurrentFiber(fiber);try{commitPassiveMountOnFiber(root,fiber,committedLanes,committedTransitions);}catch(error){captureCommitPhaseError(fiber,fiber.return,error);}resetCurrentFiber();}if(fiber===subtreeRoot){nextEffect=null;return;}var sibling=fiber.sibling;if(sibling!==null){sibling.return=fiber.return;nextEffect=sibling;return;}nextEffect=fiber.return;}}function commitPassiveMountOnFiber(finishedRoot,finishedWork,committedLanes,committedTransitions){switch(finishedWork.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{if(finishedWork.mode&ProfileMode){startPassiveEffectTimer();try{commitHookEffectListMount(Passive$1|HasEffect,finishedWork);}finally{recordPassiveEffectDuration(finishedWork);}}else {commitHookEffectListMount(Passive$1|HasEffect,finishedWork);}break;}}}function commitPassiveUnmountEffects(firstChild){nextEffect=firstChild;commitPassiveUnmountEffects_begin();}function commitPassiveUnmountEffects_begin(){while(nextEffect!==null){var fiber=nextEffect;var child=fiber.child;if((nextEffect.flags&ChildDeletion)!==NoFlags){var deletions=fiber.deletions;if(deletions!==null){for(var i=0;i<deletions.length;i++){var fiberToDelete=deletions[i];nextEffect=fiberToDelete;commitPassiveUnmountEffectsInsideOfDeletedTree_begin(fiberToDelete,fiber);}{// A fiber was deleted from this parent fiber, but it's still part of\n\t// the previous (alternate) parent fiber's list of children. Because\n\t// children are a linked list, an earlier sibling that's still alive\n\t// will be connected to the deleted fiber via its `alternate`:\n\t//\n\t//   live fiber\n\t//   --alternate--> previous live fiber\n\t//   --sibling--> deleted fiber\n\t//\n\t// We can't disconnect `alternate` on nodes that haven't been deleted\n\t// yet, but we can disconnect the `sibling` and `child` pointers.\n\tvar previousFiber=fiber.alternate;if(previousFiber!==null){var detachedChild=previousFiber.child;if(detachedChild!==null){previousFiber.child=null;do{var detachedSibling=detachedChild.sibling;detachedChild.sibling=null;detachedChild=detachedSibling;}while(detachedChild!==null);}}}nextEffect=fiber;}}if((fiber.subtreeFlags&PassiveMask)!==NoFlags&&child!==null){child.return=fiber;nextEffect=child;}else {commitPassiveUnmountEffects_complete();}}}function commitPassiveUnmountEffects_complete(){while(nextEffect!==null){var fiber=nextEffect;if((fiber.flags&Passive)!==NoFlags){setCurrentFiber(fiber);commitPassiveUnmountOnFiber(fiber);resetCurrentFiber();}var sibling=fiber.sibling;if(sibling!==null){sibling.return=fiber.return;nextEffect=sibling;return;}nextEffect=fiber.return;}}function commitPassiveUnmountOnFiber(finishedWork){switch(finishedWork.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{if(finishedWork.mode&ProfileMode){startPassiveEffectTimer();commitHookEffectListUnmount(Passive$1|HasEffect,finishedWork,finishedWork.return);recordPassiveEffectDuration(finishedWork);}else {commitHookEffectListUnmount(Passive$1|HasEffect,finishedWork,finishedWork.return);}break;}}}function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot,nearestMountedAncestor){while(nextEffect!==null){var fiber=nextEffect;// Deletion effects fire in parent -> child order\n\t// TODO: Check if fiber has a PassiveStatic flag\n\tsetCurrentFiber(fiber);commitPassiveUnmountInsideDeletedTreeOnFiber(fiber,nearestMountedAncestor);resetCurrentFiber();var child=fiber.child;// TODO: Only traverse subtree if it has a PassiveStatic flag. (But, if we\n\t// do this, still need to handle `deletedTreeCleanUpLevel` correctly.)\n\tif(child!==null){child.return=fiber;nextEffect=child;}else {commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot);}}}function commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot){while(nextEffect!==null){var fiber=nextEffect;var sibling=fiber.sibling;var returnFiber=fiber.return;{// Recursively traverse the entire deleted tree and clean up fiber fields.\n\t// This is more aggressive than ideal, and the long term goal is to only\n\t// have to detach the deleted tree at the root.\n\tdetachFiberAfterEffects(fiber);if(fiber===deletedSubtreeRoot){nextEffect=null;return;}}if(sibling!==null){sibling.return=returnFiber;nextEffect=sibling;return;}nextEffect=returnFiber;}}function commitPassiveUnmountInsideDeletedTreeOnFiber(current,nearestMountedAncestor){switch(current.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{if(current.mode&ProfileMode){startPassiveEffectTimer();commitHookEffectListUnmount(Passive$1,current,nearestMountedAncestor);recordPassiveEffectDuration(current);}else {commitHookEffectListUnmount(Passive$1,current,nearestMountedAncestor);}break;}}}// TODO: Reuse reappearLayoutEffects traversal here?\n\tfunction invokeLayoutEffectMountInDEV(fiber){{// We don't need to re-check StrictEffectsMode here.\n\t// This function is only called if that check has already passed.\n\tswitch(fiber.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{try{commitHookEffectListMount(Layout|HasEffect,fiber);}catch(error){captureCommitPhaseError(fiber,fiber.return,error);}break;}case ClassComponent:{var instance=fiber.stateNode;try{instance.componentDidMount();}catch(error){captureCommitPhaseError(fiber,fiber.return,error);}break;}}}}function invokePassiveEffectMountInDEV(fiber){{// We don't need to re-check StrictEffectsMode here.\n\t// This function is only called if that check has already passed.\n\tswitch(fiber.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{try{commitHookEffectListMount(Passive$1|HasEffect,fiber);}catch(error){captureCommitPhaseError(fiber,fiber.return,error);}break;}}}}function invokeLayoutEffectUnmountInDEV(fiber){{// We don't need to re-check StrictEffectsMode here.\n\t// This function is only called if that check has already passed.\n\tswitch(fiber.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{try{commitHookEffectListUnmount(Layout|HasEffect,fiber,fiber.return);}catch(error){captureCommitPhaseError(fiber,fiber.return,error);}break;}case ClassComponent:{var instance=fiber.stateNode;if(typeof instance.componentWillUnmount==='function'){safelyCallComponentWillUnmount(fiber,fiber.return,instance);}break;}}}}function invokePassiveEffectUnmountInDEV(fiber){{// We don't need to re-check StrictEffectsMode here.\n\t// This function is only called if that check has already passed.\n\tswitch(fiber.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{try{commitHookEffectListUnmount(Passive$1|HasEffect,fiber,fiber.return);}catch(error){captureCommitPhaseError(fiber,fiber.return,error);}}}}}if(typeof Symbol==='function'&&Symbol.for){var symbolFor=Symbol.for;symbolFor('selector.component');symbolFor('selector.has_pseudo_class');symbolFor('selector.role');symbolFor('selector.test_id');symbolFor('selector.text');}var commitHooks=[];function onCommitRoot$1(){{commitHooks.forEach(function(commitHook){return commitHook();});}}var ReactCurrentActQueue=ReactSharedInternals.ReactCurrentActQueue;function isLegacyActEnvironment(fiber){{// Legacy mode. We preserve the behavior of React 17's act. It assumes an\n\t// act environment whenever `jest` is defined, but you can still turn off\n\t// spurious warnings by setting IS_REACT_ACT_ENVIRONMENT explicitly\n\t// to false.\n\tvar isReactActEnvironmentGlobal=// $FlowExpectedError – Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global\n\ttypeof IS_REACT_ACT_ENVIRONMENT!=='undefined'?IS_REACT_ACT_ENVIRONMENT:undefined;// $FlowExpectedError - Flow doesn't know about jest\n\tvar jestIsDefined=typeof jest!=='undefined';return jestIsDefined&&isReactActEnvironmentGlobal!==false;}}function isConcurrentActEnvironment(){{var isReactActEnvironmentGlobal=// $FlowExpectedError – Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global\n\ttypeof IS_REACT_ACT_ENVIRONMENT!=='undefined'?IS_REACT_ACT_ENVIRONMENT:undefined;if(!isReactActEnvironmentGlobal&&ReactCurrentActQueue.current!==null){// TODO: Include link to relevant documentation page.\n\terror('The current testing environment is not configured to support '+'act(...)');}return isReactActEnvironmentGlobal;}}var ceil=Math.ceil;var ReactCurrentDispatcher$2=ReactSharedInternals.ReactCurrentDispatcher,ReactCurrentOwner$2=ReactSharedInternals.ReactCurrentOwner,ReactCurrentBatchConfig$3=ReactSharedInternals.ReactCurrentBatchConfig,ReactCurrentActQueue$1=ReactSharedInternals.ReactCurrentActQueue;var NoContext=/*             */0;var BatchedContext=/*               */1;var RenderContext=/*                */2;var CommitContext=/*                */4;var RootInProgress=0;var RootFatalErrored=1;var RootErrored=2;var RootSuspended=3;var RootSuspendedWithDelay=4;var RootCompleted=5;var RootDidNotComplete=6;// Describes where we are in the React execution stack\n\tvar executionContext=NoContext;// The root we're working on\n\tvar workInProgressRoot=null;// The fiber we're working on\n\tvar workInProgress=null;// The lanes we're rendering\n\tvar workInProgressRootRenderLanes=NoLanes;// Stack that allows components to change the render lanes for its subtree\n\t// This is a superset of the lanes we started working on at the root. The only\n\t// case where it's different from `workInProgressRootRenderLanes` is when we\n\t// enter a subtree that is hidden and needs to be unhidden: Suspense and\n\t// Offscreen component.\n\t//\n\t// Most things in the work loop should deal with workInProgressRootRenderLanes.\n\t// Most things in begin/complete phases should deal with subtreeRenderLanes.\n\tvar subtreeRenderLanes=NoLanes;var subtreeRenderLanesCursor=createCursor(NoLanes);// Whether to root completed, errored, suspended, etc.\n\tvar workInProgressRootExitStatus=RootInProgress;// A fatal error, if one is thrown\n\tvar workInProgressRootFatalError=null;// \"Included\" lanes refer to lanes that were worked on during this render. It's\n\t// includes unprocessed updates, not work in bailed out children.\n\tvar workInProgressRootSkippedLanes=NoLanes;// Lanes that were updated (in an interleaved event) during this render.\n\tvar workInProgressRootInterleavedUpdatedLanes=NoLanes;// Lanes that were updated during the render phase (*not* an interleaved event).\n\tvar workInProgressRootPingedLanes=NoLanes;// Errors that are thrown during the render phase.\n\tvar workInProgressRootConcurrentErrors=null;// These are errors that we recovered from without surfacing them to the UI.\n\t// We will log them once the tree commits.\n\tvar workInProgressRootRecoverableErrors=null;// The most recent time we committed a fallback. This lets us ensure a train\n\t// model where we don't commit new loading states in too quick succession.\n\tvar globalMostRecentFallbackTime=0;var FALLBACK_THROTTLE_MS=500;// The absolute time for when we should start giving up on rendering\n\t// more and prefer CPU suspense heuristics instead.\n\tvar workInProgressRootRenderTargetTime=Infinity;// How long a render is supposed to take before we start following CPU\n\t// suspense heuristics and opt out of rendering more content.\n\tvar RENDER_TIMEOUT_MS=500;var workInProgressTransitions=null;function resetRenderTimer(){workInProgressRootRenderTargetTime=now()+RENDER_TIMEOUT_MS;}function getRenderTargetTime(){return workInProgressRootRenderTargetTime;}var hasUncaughtError=false;var firstUncaughtError=null;var legacyErrorBoundariesThatAlreadyFailed=null;// Only used when enableProfilerNestedUpdateScheduledHook is true;\n\tvar rootDoesHavePassiveEffects=false;var rootWithPendingPassiveEffects=null;var pendingPassiveEffectsLanes=NoLanes;var pendingPassiveProfilerEffects=[];var pendingPassiveTransitions=null;// Use these to prevent an infinite loop of nested updates\n\tvar NESTED_UPDATE_LIMIT=50;var nestedUpdateCount=0;var rootWithNestedUpdates=null;var isFlushingPassiveEffects=false;var didScheduleUpdateDuringPassiveEffects=false;var NESTED_PASSIVE_UPDATE_LIMIT=50;var nestedPassiveUpdateCount=0;var rootWithPassiveNestedUpdates=null;// If two updates are scheduled within the same event, we should treat their\n\t// event times as simultaneous, even if the actual clock time has advanced\n\t// between the first and second call.\n\tvar currentEventTime=NoTimestamp;var currentEventTransitionLane=NoLanes;var isRunningInsertionEffect=false;function getWorkInProgressRoot(){return workInProgressRoot;}function requestEventTime(){if((executionContext&(RenderContext|CommitContext))!==NoContext){// We're inside React, so it's fine to read the actual time.\n\treturn now();}// We're not inside React, so we may be in the middle of a browser event.\n\tif(currentEventTime!==NoTimestamp){// Use the same start time for all updates until we enter React again.\n\treturn currentEventTime;}// This is the first update since React yielded. Compute a new start time.\n\tcurrentEventTime=now();return currentEventTime;}function requestUpdateLane(fiber){// Special cases\n\tvar mode=fiber.mode;if((mode&ConcurrentMode)===NoMode){return SyncLane;}else if((executionContext&RenderContext)!==NoContext&&workInProgressRootRenderLanes!==NoLanes){// This is a render phase update. These are not officially supported. The\n\t// old behavior is to give this the same \"thread\" (lanes) as\n\t// whatever is currently rendering. So if you call `setState` on a component\n\t// that happens later in the same render, it will flush. Ideally, we want to\n\t// remove the special case and treat them as if they came from an\n\t// interleaved event. Regardless, this pattern is not officially supported.\n\t// This behavior is only a fallback. The flag only exists until we can roll\n\t// out the setState warning, since existing code might accidentally rely on\n\t// the current behavior.\n\treturn pickArbitraryLane(workInProgressRootRenderLanes);}var isTransition=requestCurrentTransition()!==NoTransition;if(isTransition){if(ReactCurrentBatchConfig$3.transition!==null){var transition=ReactCurrentBatchConfig$3.transition;if(!transition._updatedFibers){transition._updatedFibers=new Set();}transition._updatedFibers.add(fiber);}// The algorithm for assigning an update to a lane should be stable for all\n\t// updates at the same priority within the same event. To do this, the\n\t// inputs to the algorithm must be the same.\n\t//\n\t// The trick we use is to cache the first of each of these inputs within an\n\t// event. Then reset the cached values once we can be sure the event is\n\t// over. Our heuristic for that is whenever we enter a concurrent work loop.\n\tif(currentEventTransitionLane===NoLane){// All transitions within the same event are assigned the same lane.\n\tcurrentEventTransitionLane=claimNextTransitionLane();}return currentEventTransitionLane;}// Updates originating inside certain React methods, like flushSync, have\n\t// their priority set by tracking it with a context variable.\n\t//\n\t// The opaque type returned by the host config is internally a lane, so we can\n\t// use that directly.\n\t// TODO: Move this type conversion to the event priority module.\n\tvar updateLane=getCurrentUpdatePriority();if(updateLane!==NoLane){return updateLane;}// This update originated outside React. Ask the host environment for an\n\t// appropriate priority, based on the type of event.\n\t//\n\t// The opaque type returned by the host config is internally a lane, so we can\n\t// use that directly.\n\t// TODO: Move this type conversion to the event priority module.\n\tvar eventLane=getCurrentEventPriority();return eventLane;}function requestRetryLane(fiber){// This is a fork of `requestUpdateLane` designed specifically for Suspense\n\t// \"retries\" — a special update that attempts to flip a Suspense boundary\n\t// from its placeholder state to its primary/resolved state.\n\t// Special cases\n\tvar mode=fiber.mode;if((mode&ConcurrentMode)===NoMode){return SyncLane;}return claimNextRetryLane();}function scheduleUpdateOnFiber(root,fiber,lane,eventTime){checkForNestedUpdates();{if(isRunningInsertionEffect){error('useInsertionEffect must not schedule updates.');}}{if(isFlushingPassiveEffects){didScheduleUpdateDuringPassiveEffects=true;}}// Mark that the root has a pending update.\n\tmarkRootUpdated(root,lane,eventTime);if((executionContext&RenderContext)!==NoLanes&&root===workInProgressRoot){// This update was dispatched during the render phase. This is a mistake\n\t// if the update originates from user space (with the exception of local\n\t// hook updates, which are handled differently and don't reach this\n\t// function), but there are some internal React features that use this as\n\t// an implementation detail, like selective hydration.\n\twarnAboutRenderPhaseUpdatesInDEV(fiber);// Track lanes that were updated during the render phase\n\t}else {// This is a normal update, scheduled from outside the render phase. For\n\t// example, during an input event.\n\t{if(isDevToolsPresent){addFiberToLanesMap(root,fiber,lane);}}warnIfUpdatesNotWrappedWithActDEV(fiber);if(root===workInProgressRoot){// Received an update to a tree that's in the middle of rendering. Mark\n\t// that there was an interleaved update work on this root. Unless the\n\t// `deferRenderPhaseUpdateToNextBatch` flag is off and this is a render\n\t// phase update. In that case, we don't treat render phase updates as if\n\t// they were interleaved, for backwards compat reasons.\n\tif((executionContext&RenderContext)===NoContext){workInProgressRootInterleavedUpdatedLanes=mergeLanes(workInProgressRootInterleavedUpdatedLanes,lane);}if(workInProgressRootExitStatus===RootSuspendedWithDelay){// The root already suspended with a delay, which means this render\n\t// definitely won't finish. Since we have a new update, let's mark it as\n\t// suspended now, right before marking the incoming update. This has the\n\t// effect of interrupting the current render and switching to the update.\n\t// TODO: Make sure this doesn't override pings that happen while we've\n\t// already started rendering.\n\tmarkRootSuspended$1(root,workInProgressRootRenderLanes);}}ensureRootIsScheduled(root,eventTime);if(lane===SyncLane&&executionContext===NoContext&&(fiber.mode&ConcurrentMode)===NoMode&&// Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.\n\t!ReactCurrentActQueue$1.isBatchingLegacy){// Flush the synchronous work now, unless we're already working or inside\n\t// a batch. This is intentionally inside scheduleUpdateOnFiber instead of\n\t// scheduleCallbackForFiber to preserve the ability to schedule a callback\n\t// without immediately flushing it. We only do this for user-initiated\n\t// updates, to preserve historical behavior of legacy mode.\n\tresetRenderTimer();flushSyncCallbacksOnlyInLegacyMode();}}}function scheduleInitialHydrationOnRoot(root,lane,eventTime){// This is a special fork of scheduleUpdateOnFiber that is only used to\n\t// schedule the initial hydration of a root that has just been created. Most\n\t// of the stuff in scheduleUpdateOnFiber can be skipped.\n\t//\n\t// The main reason for this separate path, though, is to distinguish the\n\t// initial children from subsequent updates. In fully client-rendered roots\n\t// (createRoot instead of hydrateRoot), all top-level renders are modeled as\n\t// updates, but hydration roots are special because the initial render must\n\t// match what was rendered on the server.\n\tvar current=root.current;current.lanes=lane;markRootUpdated(root,lane,eventTime);ensureRootIsScheduled(root,eventTime);}function isUnsafeClassRenderPhaseUpdate(fiber){// Check if this is a render phase update. Only called by class components,\n\t// which special (deprecated) behavior for UNSAFE_componentWillReceive props.\n\treturn(// TODO: Remove outdated deferRenderPhaseUpdateToNextBatch experiment. We\n\t// decided not to enable it.\n\t(executionContext&RenderContext)!==NoContext);}// Use this function to schedule a task for a root. There's only one task per\n\t// root; if a task was already scheduled, we'll check to make sure the priority\n\t// of the existing task is the same as the priority of the next level that the\n\t// root has work on. This function is called on every update, and right before\n\t// exiting a task.\n\tfunction ensureRootIsScheduled(root,currentTime){var existingCallbackNode=root.callbackNode;// Check if any lanes are being starved by other work. If so, mark them as\n\t// expired so we know to work on those next.\n\tmarkStarvedLanesAsExpired(root,currentTime);// Determine the next lanes to work on, and their priority.\n\tvar nextLanes=getNextLanes(root,root===workInProgressRoot?workInProgressRootRenderLanes:NoLanes);if(nextLanes===NoLanes){// Special case: There's nothing to work on.\n\tif(existingCallbackNode!==null){cancelCallback$1(existingCallbackNode);}root.callbackNode=null;root.callbackPriority=NoLane;return;}// We use the highest priority lane to represent the priority of the callback.\n\tvar newCallbackPriority=getHighestPriorityLane(nextLanes);// Check if there's an existing task. We may be able to reuse it.\n\tvar existingCallbackPriority=root.callbackPriority;if(existingCallbackPriority===newCallbackPriority&&// Special case related to `act`. If the currently scheduled task is a\n\t// Scheduler task, rather than an `act` task, cancel it and re-scheduled\n\t// on the `act` queue.\n\t!(ReactCurrentActQueue$1.current!==null&&existingCallbackNode!==fakeActCallbackNode)){{// If we're going to re-use an existing task, it needs to exist.\n\t// Assume that discrete update microtasks are non-cancellable and null.\n\t// TODO: Temporary until we confirm this warning is not fired.\n\tif(existingCallbackNode==null&&existingCallbackPriority!==SyncLane){error('Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.');}}// The priority hasn't changed. We can reuse the existing task. Exit.\n\treturn;}if(existingCallbackNode!=null){// Cancel the existing callback. We'll schedule a new one below.\n\tcancelCallback$1(existingCallbackNode);}// Schedule a new callback.\n\tvar newCallbackNode;if(newCallbackPriority===SyncLane){// Special case: Sync React callbacks are scheduled on a special\n\t// internal queue\n\tif(root.tag===LegacyRoot){if(ReactCurrentActQueue$1.isBatchingLegacy!==null){ReactCurrentActQueue$1.didScheduleLegacyUpdate=true;}scheduleLegacySyncCallback(performSyncWorkOnRoot.bind(null,root));}else {scheduleSyncCallback(performSyncWorkOnRoot.bind(null,root));}{// Flush the queue in a microtask.\n\tif(ReactCurrentActQueue$1.current!==null){// Inside `act`, use our internal `act` queue so that these get flushed\n\t// at the end of the current scope even when using the sync version\n\t// of `act`.\n\tReactCurrentActQueue$1.current.push(flushSyncCallbacks);}else {scheduleMicrotask(function(){// In Safari, appending an iframe forces microtasks to run.\n\t// https://github.com/facebook/react/issues/22459\n\t// We don't support running callbacks in the middle of render\n\t// or commit so we need to check against that.\n\tif((executionContext&(RenderContext|CommitContext))===NoContext){// Note that this would still prematurely flush the callbacks\n\t// if this happens outside render or commit phase (e.g. in an event).\n\tflushSyncCallbacks();}});}}newCallbackNode=null;}else {var schedulerPriorityLevel;switch(lanesToEventPriority(nextLanes)){case DiscreteEventPriority:schedulerPriorityLevel=ImmediatePriority;break;case ContinuousEventPriority:schedulerPriorityLevel=UserBlockingPriority;break;case DefaultEventPriority:schedulerPriorityLevel=NormalPriority;break;case IdleEventPriority:schedulerPriorityLevel=IdlePriority;break;default:schedulerPriorityLevel=NormalPriority;break;}newCallbackNode=scheduleCallback$1(schedulerPriorityLevel,performConcurrentWorkOnRoot.bind(null,root));}root.callbackPriority=newCallbackPriority;root.callbackNode=newCallbackNode;}// This is the entry point for every concurrent task, i.e. anything that\n\t// goes through Scheduler.\n\tfunction performConcurrentWorkOnRoot(root,didTimeout){{resetNestedUpdateFlag();}// Since we know we're in a React event, we can clear the current\n\t// event time. The next update will compute a new event time.\n\tcurrentEventTime=NoTimestamp;currentEventTransitionLane=NoLanes;if((executionContext&(RenderContext|CommitContext))!==NoContext){throw new Error('Should not already be working.');}// Flush any pending passive effects before deciding which lanes to work on,\n\t// in case they schedule additional work.\n\tvar originalCallbackNode=root.callbackNode;var didFlushPassiveEffects=flushPassiveEffects();if(didFlushPassiveEffects){// Something in the passive effect phase may have canceled the current task.\n\t// Check if the task node for this root was changed.\n\tif(root.callbackNode!==originalCallbackNode){// The current task was canceled. Exit. We don't need to call\n\t// `ensureRootIsScheduled` because the check above implies either that\n\t// there's a new task, or that there's no remaining work on this root.\n\treturn null;}}// Determine the next lanes to work on, using the fields stored\n\t// on the root.\n\tvar lanes=getNextLanes(root,root===workInProgressRoot?workInProgressRootRenderLanes:NoLanes);if(lanes===NoLanes){// Defensive coding. This is never expected to happen.\n\treturn null;}// We disable time-slicing in some cases: if the work has been CPU-bound\n\t// for too long (\"expired\" work, to prevent starvation), or we're in\n\t// sync-updates-by-default mode.\n\t// TODO: We only check `didTimeout` defensively, to account for a Scheduler\n\t// bug we're still investigating. Once the bug in Scheduler is fixed,\n\t// we can remove this, since we track expiration ourselves.\n\tvar shouldTimeSlice=!includesBlockingLane(root,lanes)&&!includesExpiredLane(root,lanes)&&!didTimeout;var exitStatus=shouldTimeSlice?renderRootConcurrent(root,lanes):renderRootSync(root,lanes);if(exitStatus!==RootInProgress){if(exitStatus===RootErrored){// If something threw an error, try rendering one more time. We'll\n\t// render synchronously to block concurrent data mutations, and we'll\n\t// includes all pending updates are included. If it still fails after\n\t// the second attempt, we'll give up and commit the resulting tree.\n\tvar errorRetryLanes=getLanesToRetrySynchronouslyOnError(root);if(errorRetryLanes!==NoLanes){lanes=errorRetryLanes;exitStatus=recoverFromConcurrentError(root,errorRetryLanes);}}if(exitStatus===RootFatalErrored){var fatalError=workInProgressRootFatalError;prepareFreshStack(root,NoLanes);markRootSuspended$1(root,lanes);ensureRootIsScheduled(root,now());throw fatalError;}if(exitStatus===RootDidNotComplete){// The render unwound without completing the tree. This happens in special\n\t// cases where need to exit the current render without producing a\n\t// consistent tree or committing.\n\t//\n\t// This should only happen during a concurrent render, not a discrete or\n\t// synchronous update. We should have already checked for this when we\n\t// unwound the stack.\n\tmarkRootSuspended$1(root,lanes);}else {// The render completed.\n\t// Check if this render may have yielded to a concurrent event, and if so,\n\t// confirm that any newly rendered stores are consistent.\n\t// TODO: It's possible that even a concurrent render may never have yielded\n\t// to the main thread, if it was fast enough, or if it expired. We could\n\t// skip the consistency check in that case, too.\n\tvar renderWasConcurrent=!includesBlockingLane(root,lanes);var finishedWork=root.current.alternate;if(renderWasConcurrent&&!isRenderConsistentWithExternalStores(finishedWork)){// A store was mutated in an interleaved event. Render again,\n\t// synchronously, to block further mutations.\n\texitStatus=renderRootSync(root,lanes);// We need to check again if something threw\n\tif(exitStatus===RootErrored){var _errorRetryLanes=getLanesToRetrySynchronouslyOnError(root);if(_errorRetryLanes!==NoLanes){lanes=_errorRetryLanes;exitStatus=recoverFromConcurrentError(root,_errorRetryLanes);// We assume the tree is now consistent because we didn't yield to any\n\t// concurrent events.\n\t}}if(exitStatus===RootFatalErrored){var _fatalError=workInProgressRootFatalError;prepareFreshStack(root,NoLanes);markRootSuspended$1(root,lanes);ensureRootIsScheduled(root,now());throw _fatalError;}}// We now have a consistent tree. The next step is either to commit it,\n\t// or, if something suspended, wait to commit it after a timeout.\n\troot.finishedWork=finishedWork;root.finishedLanes=lanes;finishConcurrentRender(root,exitStatus,lanes);}}ensureRootIsScheduled(root,now());if(root.callbackNode===originalCallbackNode){// The task node scheduled for this root is the same one that's\n\t// currently executed. Need to return a continuation.\n\treturn performConcurrentWorkOnRoot.bind(null,root);}return null;}function recoverFromConcurrentError(root,errorRetryLanes){// If an error occurred during hydration, discard server response and fall\n\t// back to client side render.\n\t// Before rendering again, save the errors from the previous attempt.\n\tvar errorsFromFirstAttempt=workInProgressRootConcurrentErrors;if(isRootDehydrated(root)){// The shell failed to hydrate. Set a flag to force a client rendering\n\t// during the next attempt. To do this, we call prepareFreshStack now\n\t// to create the root work-in-progress fiber. This is a bit weird in terms\n\t// of factoring, because it relies on renderRootSync not calling\n\t// prepareFreshStack again in the call below, which happens because the\n\t// root and lanes haven't changed.\n\t//\n\t// TODO: I think what we should do is set ForceClientRender inside\n\t// throwException, like we do for nested Suspense boundaries. The reason\n\t// it's here instead is so we can switch to the synchronous work loop, too.\n\t// Something to consider for a future refactor.\n\tvar rootWorkInProgress=prepareFreshStack(root,errorRetryLanes);rootWorkInProgress.flags|=ForceClientRender;{errorHydratingContainer(root.containerInfo);}}var exitStatus=renderRootSync(root,errorRetryLanes);if(exitStatus!==RootErrored){// Successfully finished rendering on retry\n\t// The errors from the failed first attempt have been recovered. Add\n\t// them to the collection of recoverable errors. We'll log them in the\n\t// commit phase.\n\tvar errorsFromSecondAttempt=workInProgressRootRecoverableErrors;workInProgressRootRecoverableErrors=errorsFromFirstAttempt;// The errors from the second attempt should be queued after the errors\n\t// from the first attempt, to preserve the causal sequence.\n\tif(errorsFromSecondAttempt!==null){queueRecoverableErrors(errorsFromSecondAttempt);}}return exitStatus;}function queueRecoverableErrors(errors){if(workInProgressRootRecoverableErrors===null){workInProgressRootRecoverableErrors=errors;}else {workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors,errors);}}function finishConcurrentRender(root,exitStatus,lanes){switch(exitStatus){case RootInProgress:case RootFatalErrored:{throw new Error('Root did not complete. This is a bug in React.');}// Flow knows about invariant, so it complains if I add a break\n\t// statement, but eslint doesn't know about invariant, so it complains\n\t// if I do. eslint-disable-next-line no-fallthrough\n\tcase RootErrored:{// We should have already attempted to retry this tree. If we reached\n\t// this point, it errored again. Commit it.\n\tcommitRoot(root,workInProgressRootRecoverableErrors,workInProgressTransitions);break;}case RootSuspended:{markRootSuspended$1(root,lanes);// We have an acceptable loading state. We need to figure out if we\n\t// should immediately commit it or wait a bit.\n\tif(includesOnlyRetries(lanes)&&// do not delay if we're inside an act() scope\n\t!shouldForceFlushFallbacksInDEV()){// This render only included retries, no updates. Throttle committing\n\t// retries so that we don't show too many loading states too quickly.\n\tvar msUntilTimeout=globalMostRecentFallbackTime+FALLBACK_THROTTLE_MS-now();// Don't bother with a very short suspense time.\n\tif(msUntilTimeout>10){var nextLanes=getNextLanes(root,NoLanes);if(nextLanes!==NoLanes){// There's additional work on this root.\n\tbreak;}var suspendedLanes=root.suspendedLanes;if(!isSubsetOfLanes(suspendedLanes,lanes)){// We should prefer to render the fallback of at the last\n\t// suspended level. Ping the last suspended level to try\n\t// rendering it again.\n\t// FIXME: What if the suspended lanes are Idle? Should not restart.\n\trequestEventTime();markRootPinged(root,suspendedLanes);break;}// The render is suspended, it hasn't timed out, and there's no\n\t// lower priority work to do. Instead of committing the fallback\n\t// immediately, wait for more data to arrive.\n\troot.timeoutHandle=scheduleTimeout(commitRoot.bind(null,root,workInProgressRootRecoverableErrors,workInProgressTransitions),msUntilTimeout);break;}}// The work expired. Commit immediately.\n\tcommitRoot(root,workInProgressRootRecoverableErrors,workInProgressTransitions);break;}case RootSuspendedWithDelay:{markRootSuspended$1(root,lanes);if(includesOnlyTransitions(lanes)){// This is a transition, so we should exit without committing a\n\t// placeholder and without scheduling a timeout. Delay indefinitely\n\t// until we receive more data.\n\tbreak;}if(!shouldForceFlushFallbacksInDEV()){// This is not a transition, but we did trigger an avoided state.\n\t// Schedule a placeholder to display after a short delay, using the Just\n\t// Noticeable Difference.\n\t// TODO: Is the JND optimization worth the added complexity? If this is\n\t// the only reason we track the event time, then probably not.\n\t// Consider removing.\n\tvar mostRecentEventTime=getMostRecentEventTime(root,lanes);var eventTimeMs=mostRecentEventTime;var timeElapsedMs=now()-eventTimeMs;var _msUntilTimeout=jnd(timeElapsedMs)-timeElapsedMs;// Don't bother with a very short suspense time.\n\tif(_msUntilTimeout>10){// Instead of committing the fallback immediately, wait for more data\n\t// to arrive.\n\troot.timeoutHandle=scheduleTimeout(commitRoot.bind(null,root,workInProgressRootRecoverableErrors,workInProgressTransitions),_msUntilTimeout);break;}}// Commit the placeholder.\n\tcommitRoot(root,workInProgressRootRecoverableErrors,workInProgressTransitions);break;}case RootCompleted:{// The work completed. Ready to commit.\n\tcommitRoot(root,workInProgressRootRecoverableErrors,workInProgressTransitions);break;}default:{throw new Error('Unknown root exit status.');}}}function isRenderConsistentWithExternalStores(finishedWork){// Search the rendered tree for external store reads, and check whether the\n\t// stores were mutated in a concurrent event. Intentionally using an iterative\n\t// loop instead of recursion so we can exit early.\n\tvar node=finishedWork;while(true){if(node.flags&StoreConsistency){var updateQueue=node.updateQueue;if(updateQueue!==null){var checks=updateQueue.stores;if(checks!==null){for(var i=0;i<checks.length;i++){var check=checks[i];var getSnapshot=check.getSnapshot;var renderedValue=check.value;try{if(!objectIs(getSnapshot(),renderedValue)){// Found an inconsistent store.\n\treturn false;}}catch(error){// If `getSnapshot` throws, return `false`. This will schedule\n\t// a re-render, and the error will be rethrown during render.\n\treturn false;}}}}}var child=node.child;if(node.subtreeFlags&StoreConsistency&&child!==null){child.return=node;node=child;continue;}if(node===finishedWork){return true;}while(node.sibling===null){if(node.return===null||node.return===finishedWork){return true;}node=node.return;}node.sibling.return=node.return;node=node.sibling;}// Flow doesn't know this is unreachable, but eslint does\n\t// eslint-disable-next-line no-unreachable\n\treturn true;}function markRootSuspended$1(root,suspendedLanes){// When suspending, we should always exclude lanes that were pinged or (more\n\t// rarely, since we try to avoid it) updated during the render phase.\n\t// TODO: Lol maybe there's a better way to factor this besides this\n\t// obnoxiously named function :)\n\tsuspendedLanes=removeLanes(suspendedLanes,workInProgressRootPingedLanes);suspendedLanes=removeLanes(suspendedLanes,workInProgressRootInterleavedUpdatedLanes);markRootSuspended(root,suspendedLanes);}// This is the entry point for synchronous tasks that don't go\n\t// through Scheduler\n\tfunction performSyncWorkOnRoot(root){{syncNestedUpdateFlag();}if((executionContext&(RenderContext|CommitContext))!==NoContext){throw new Error('Should not already be working.');}flushPassiveEffects();var lanes=getNextLanes(root,NoLanes);if(!includesSomeLane(lanes,SyncLane)){// There's no remaining sync work left.\n\tensureRootIsScheduled(root,now());return null;}var exitStatus=renderRootSync(root,lanes);if(root.tag!==LegacyRoot&&exitStatus===RootErrored){// If something threw an error, try rendering one more time. We'll render\n\t// synchronously to block concurrent data mutations, and we'll includes\n\t// all pending updates are included. If it still fails after the second\n\t// attempt, we'll give up and commit the resulting tree.\n\tvar errorRetryLanes=getLanesToRetrySynchronouslyOnError(root);if(errorRetryLanes!==NoLanes){lanes=errorRetryLanes;exitStatus=recoverFromConcurrentError(root,errorRetryLanes);}}if(exitStatus===RootFatalErrored){var fatalError=workInProgressRootFatalError;prepareFreshStack(root,NoLanes);markRootSuspended$1(root,lanes);ensureRootIsScheduled(root,now());throw fatalError;}if(exitStatus===RootDidNotComplete){throw new Error('Root did not complete. This is a bug in React.');}// We now have a consistent tree. Because this is a sync render, we\n\t// will commit it even if something suspended.\n\tvar finishedWork=root.current.alternate;root.finishedWork=finishedWork;root.finishedLanes=lanes;commitRoot(root,workInProgressRootRecoverableErrors,workInProgressTransitions);// Before exiting, make sure there's a callback scheduled for the next\n\t// pending level.\n\tensureRootIsScheduled(root,now());return null;}function flushRoot(root,lanes){if(lanes!==NoLanes){markRootEntangled(root,mergeLanes(lanes,SyncLane));ensureRootIsScheduled(root,now());if((executionContext&(RenderContext|CommitContext))===NoContext){resetRenderTimer();flushSyncCallbacks();}}}function batchedUpdates$1(fn,a){var prevExecutionContext=executionContext;executionContext|=BatchedContext;try{return fn(a);}finally{executionContext=prevExecutionContext;// If there were legacy sync updates, flush them at the end of the outer\n\t// most batchedUpdates-like method.\n\tif(executionContext===NoContext&&// Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.\n\t!ReactCurrentActQueue$1.isBatchingLegacy){resetRenderTimer();flushSyncCallbacksOnlyInLegacyMode();}}}function discreteUpdates(fn,a,b,c,d){var previousPriority=getCurrentUpdatePriority();var prevTransition=ReactCurrentBatchConfig$3.transition;try{ReactCurrentBatchConfig$3.transition=null;setCurrentUpdatePriority(DiscreteEventPriority);return fn(a,b,c,d);}finally{setCurrentUpdatePriority(previousPriority);ReactCurrentBatchConfig$3.transition=prevTransition;if(executionContext===NoContext){resetRenderTimer();}}}// Overload the definition to the two valid signatures.\n\t// Warning, this opts-out of checking the function body.\n\t// eslint-disable-next-line no-redeclare\n\tfunction flushSync(fn){// In legacy mode, we flush pending passive effects at the beginning of the\n\t// next event, not at the end of the previous one.\n\tif(rootWithPendingPassiveEffects!==null&&rootWithPendingPassiveEffects.tag===LegacyRoot&&(executionContext&(RenderContext|CommitContext))===NoContext){flushPassiveEffects();}var prevExecutionContext=executionContext;executionContext|=BatchedContext;var prevTransition=ReactCurrentBatchConfig$3.transition;var previousPriority=getCurrentUpdatePriority();try{ReactCurrentBatchConfig$3.transition=null;setCurrentUpdatePriority(DiscreteEventPriority);if(fn){return fn();}else {return undefined;}}finally{setCurrentUpdatePriority(previousPriority);ReactCurrentBatchConfig$3.transition=prevTransition;executionContext=prevExecutionContext;// Flush the immediate callbacks that were scheduled during this batch.\n\t// Note that this will happen even if batchedUpdates is higher up\n\t// the stack.\n\tif((executionContext&(RenderContext|CommitContext))===NoContext){flushSyncCallbacks();}}}function isAlreadyRendering(){// Used by the renderer to print a warning if certain APIs are called from\n\t// the wrong context.\n\treturn (executionContext&(RenderContext|CommitContext))!==NoContext;}function pushRenderLanes(fiber,lanes){push(subtreeRenderLanesCursor,subtreeRenderLanes,fiber);subtreeRenderLanes=mergeLanes(subtreeRenderLanes,lanes);}function popRenderLanes(fiber){subtreeRenderLanes=subtreeRenderLanesCursor.current;pop(subtreeRenderLanesCursor,fiber);}function prepareFreshStack(root,lanes){root.finishedWork=null;root.finishedLanes=NoLanes;var timeoutHandle=root.timeoutHandle;if(timeoutHandle!==noTimeout){// The root previous suspended and scheduled a timeout to commit a fallback\n\t// state. Now that we have additional work, cancel the timeout.\n\troot.timeoutHandle=noTimeout;// $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above\n\tcancelTimeout(timeoutHandle);}if(workInProgress!==null){var interruptedWork=workInProgress.return;while(interruptedWork!==null){var current=interruptedWork.alternate;unwindInterruptedWork(current,interruptedWork);interruptedWork=interruptedWork.return;}}workInProgressRoot=root;var rootWorkInProgress=createWorkInProgress(root.current,null);workInProgress=rootWorkInProgress;workInProgressRootRenderLanes=subtreeRenderLanes=lanes;workInProgressRootExitStatus=RootInProgress;workInProgressRootFatalError=null;workInProgressRootSkippedLanes=NoLanes;workInProgressRootInterleavedUpdatedLanes=NoLanes;workInProgressRootPingedLanes=NoLanes;workInProgressRootConcurrentErrors=null;workInProgressRootRecoverableErrors=null;finishQueueingConcurrentUpdates();{ReactStrictModeWarnings.discardPendingWarnings();}return rootWorkInProgress;}function handleError(root,thrownValue){do{var erroredWork=workInProgress;try{// Reset module-level state that was set during the render phase.\n\tresetContextDependencies();resetHooksAfterThrow();resetCurrentFiber();// TODO: I found and added this missing line while investigating a\n\t// separate issue. Write a regression test using string refs.\n\tReactCurrentOwner$2.current=null;if(erroredWork===null||erroredWork.return===null){// Expected to be working on a non-root fiber. This is a fatal error\n\t// because there's no ancestor that can handle it; the root is\n\t// supposed to capture all errors that weren't caught by an error\n\t// boundary.\n\tworkInProgressRootExitStatus=RootFatalErrored;workInProgressRootFatalError=thrownValue;// Set `workInProgress` to null. This represents advancing to the next\n\t// sibling, or the parent if there are no siblings. But since the root\n\t// has no siblings nor a parent, we set it to null. Usually this is\n\t// handled by `completeUnitOfWork` or `unwindWork`, but since we're\n\t// intentionally not calling those, we need set it here.\n\t// TODO: Consider calling `unwindWork` to pop the contexts.\n\tworkInProgress=null;return;}if(enableProfilerTimer&&erroredWork.mode&ProfileMode){// Record the time spent rendering before an error was thrown. This\n\t// avoids inaccurate Profiler durations in the case of a\n\t// suspended render.\n\tstopProfilerTimerIfRunningAndRecordDelta(erroredWork,true);}if(enableSchedulingProfiler){markComponentRenderStopped();if(thrownValue!==null&&typeof thrownValue==='object'&&typeof thrownValue.then==='function'){var wakeable=thrownValue;markComponentSuspended(erroredWork,wakeable,workInProgressRootRenderLanes);}else {markComponentErrored(erroredWork,thrownValue,workInProgressRootRenderLanes);}}throwException(root,erroredWork.return,erroredWork,thrownValue,workInProgressRootRenderLanes);completeUnitOfWork(erroredWork);}catch(yetAnotherThrownValue){// Something in the return path also threw.\n\tthrownValue=yetAnotherThrownValue;if(workInProgress===erroredWork&&erroredWork!==null){// If this boundary has already errored, then we had trouble processing\n\t// the error. Bubble it to the next boundary.\n\terroredWork=erroredWork.return;workInProgress=erroredWork;}else {erroredWork=workInProgress;}continue;}// Return to the normal work loop.\n\treturn;}while(true);}function pushDispatcher(){var prevDispatcher=ReactCurrentDispatcher$2.current;ReactCurrentDispatcher$2.current=ContextOnlyDispatcher;if(prevDispatcher===null){// The React isomorphic package does not include a default dispatcher.\n\t// Instead the first renderer will lazily attach one, in order to give\n\t// nicer error messages.\n\treturn ContextOnlyDispatcher;}else {return prevDispatcher;}}function popDispatcher(prevDispatcher){ReactCurrentDispatcher$2.current=prevDispatcher;}function markCommitTimeOfFallback(){globalMostRecentFallbackTime=now();}function markSkippedUpdateLanes(lane){workInProgressRootSkippedLanes=mergeLanes(lane,workInProgressRootSkippedLanes);}function renderDidSuspend(){if(workInProgressRootExitStatus===RootInProgress){workInProgressRootExitStatus=RootSuspended;}}function renderDidSuspendDelayIfPossible(){if(workInProgressRootExitStatus===RootInProgress||workInProgressRootExitStatus===RootSuspended||workInProgressRootExitStatus===RootErrored){workInProgressRootExitStatus=RootSuspendedWithDelay;}// Check if there are updates that we skipped tree that might have unblocked\n\t// this render.\n\tif(workInProgressRoot!==null&&(includesNonIdleWork(workInProgressRootSkippedLanes)||includesNonIdleWork(workInProgressRootInterleavedUpdatedLanes))){// Mark the current render as suspended so that we switch to working on\n\t// the updates that were skipped. Usually we only suspend at the end of\n\t// the render phase.\n\t// TODO: We should probably always mark the root as suspended immediately\n\t// (inside this function), since by suspending at the end of the render\n\t// phase introduces a potential mistake where we suspend lanes that were\n\t// pinged or updated while we were rendering.\n\tmarkRootSuspended$1(workInProgressRoot,workInProgressRootRenderLanes);}}function renderDidError(error){if(workInProgressRootExitStatus!==RootSuspendedWithDelay){workInProgressRootExitStatus=RootErrored;}if(workInProgressRootConcurrentErrors===null){workInProgressRootConcurrentErrors=[error];}else {workInProgressRootConcurrentErrors.push(error);}}// Called during render to determine if anything has suspended.\n\t// Returns false if we're not sure.\n\tfunction renderHasNotSuspendedYet(){// If something errored or completed, we can't really be sure,\n\t// so those are false.\n\treturn workInProgressRootExitStatus===RootInProgress;}function renderRootSync(root,lanes){var prevExecutionContext=executionContext;executionContext|=RenderContext;var prevDispatcher=pushDispatcher();// If the root or lanes have changed, throw out the existing stack\n\t// and prepare a fresh one. Otherwise we'll continue where we left off.\n\tif(workInProgressRoot!==root||workInProgressRootRenderLanes!==lanes){{if(isDevToolsPresent){var memoizedUpdaters=root.memoizedUpdaters;if(memoizedUpdaters.size>0){restorePendingUpdaters(root,workInProgressRootRenderLanes);memoizedUpdaters.clear();}// At this point, move Fibers that scheduled the upcoming work from the Map to the Set.\n\t// If we bailout on this work, we'll move them back (like above).\n\t// It's important to move them now in case the work spawns more work at the same priority with different updaters.\n\t// That way we can keep the current update and future updates separate.\n\tmovePendingFibersToMemoized(root,lanes);}}workInProgressTransitions=getTransitionsForLanes();prepareFreshStack(root,lanes);}{markRenderStarted(lanes);}do{try{workLoopSync();break;}catch(thrownValue){handleError(root,thrownValue);}}while(true);resetContextDependencies();executionContext=prevExecutionContext;popDispatcher(prevDispatcher);if(workInProgress!==null){// This is a sync render, so we should have finished the whole tree.\n\tthrow new Error('Cannot commit an incomplete root. This error is likely caused by a '+'bug in React. Please file an issue.');}{markRenderStopped();}// Set this to null to indicate there's no in-progress render.\n\tworkInProgressRoot=null;workInProgressRootRenderLanes=NoLanes;return workInProgressRootExitStatus;}// The work loop is an extremely hot path. Tell Closure not to inline it.\n\t/** @noinline */function workLoopSync(){// Already timed out, so perform work without checking if we need to yield.\n\twhile(workInProgress!==null){performUnitOfWork(workInProgress);}}function renderRootConcurrent(root,lanes){var prevExecutionContext=executionContext;executionContext|=RenderContext;var prevDispatcher=pushDispatcher();// If the root or lanes have changed, throw out the existing stack\n\t// and prepare a fresh one. Otherwise we'll continue where we left off.\n\tif(workInProgressRoot!==root||workInProgressRootRenderLanes!==lanes){{if(isDevToolsPresent){var memoizedUpdaters=root.memoizedUpdaters;if(memoizedUpdaters.size>0){restorePendingUpdaters(root,workInProgressRootRenderLanes);memoizedUpdaters.clear();}// At this point, move Fibers that scheduled the upcoming work from the Map to the Set.\n\t// If we bailout on this work, we'll move them back (like above).\n\t// It's important to move them now in case the work spawns more work at the same priority with different updaters.\n\t// That way we can keep the current update and future updates separate.\n\tmovePendingFibersToMemoized(root,lanes);}}workInProgressTransitions=getTransitionsForLanes();resetRenderTimer();prepareFreshStack(root,lanes);}{markRenderStarted(lanes);}do{try{workLoopConcurrent();break;}catch(thrownValue){handleError(root,thrownValue);}}while(true);resetContextDependencies();popDispatcher(prevDispatcher);executionContext=prevExecutionContext;if(workInProgress!==null){// Still work remaining.\n\t{markRenderYielded();}return RootInProgress;}else {// Completed the tree.\n\t{markRenderStopped();}// Set this to null to indicate there's no in-progress render.\n\tworkInProgressRoot=null;workInProgressRootRenderLanes=NoLanes;// Return the final exit status.\n\treturn workInProgressRootExitStatus;}}/** @noinline */function workLoopConcurrent(){// Perform work until Scheduler asks us to yield\n\twhile(workInProgress!==null&&!shouldYield()){performUnitOfWork(workInProgress);}}function performUnitOfWork(unitOfWork){// The current, flushed, state of this fiber is the alternate. Ideally\n\t// nothing should rely on this, but relying on it here means that we don't\n\t// need an additional field on the work in progress.\n\tvar current=unitOfWork.alternate;setCurrentFiber(unitOfWork);var next;if((unitOfWork.mode&ProfileMode)!==NoMode){startProfilerTimer(unitOfWork);next=beginWork$1(current,unitOfWork,subtreeRenderLanes);stopProfilerTimerIfRunningAndRecordDelta(unitOfWork,true);}else {next=beginWork$1(current,unitOfWork,subtreeRenderLanes);}resetCurrentFiber();unitOfWork.memoizedProps=unitOfWork.pendingProps;if(next===null){// If this doesn't spawn new work, complete the current work.\n\tcompleteUnitOfWork(unitOfWork);}else {workInProgress=next;}ReactCurrentOwner$2.current=null;}function completeUnitOfWork(unitOfWork){// Attempt to complete the current unit of work, then move to the next\n\t// sibling. If there are no more siblings, return to the parent fiber.\n\tvar completedWork=unitOfWork;do{// The current, flushed, state of this fiber is the alternate. Ideally\n\t// nothing should rely on this, but relying on it here means that we don't\n\t// need an additional field on the work in progress.\n\tvar current=completedWork.alternate;var returnFiber=completedWork.return;// Check if the work completed or if something threw.\n\tif((completedWork.flags&Incomplete)===NoFlags){setCurrentFiber(completedWork);var next=void 0;if((completedWork.mode&ProfileMode)===NoMode){next=completeWork(current,completedWork,subtreeRenderLanes);}else {startProfilerTimer(completedWork);next=completeWork(current,completedWork,subtreeRenderLanes);// Update render duration assuming we didn't error.\n\tstopProfilerTimerIfRunningAndRecordDelta(completedWork,false);}resetCurrentFiber();if(next!==null){// Completing this fiber spawned new work. Work on that next.\n\tworkInProgress=next;return;}}else {// This fiber did not complete because something threw. Pop values off\n\t// the stack without entering the complete phase. If this is a boundary,\n\t// capture values if possible.\n\tvar _next=unwindWork(current,completedWork);// Because this fiber did not complete, don't reset its lanes.\n\tif(_next!==null){// If completing this work spawned new work, do that next. We'll come\n\t// back here again.\n\t// Since we're restarting, remove anything that is not a host effect\n\t// from the effect tag.\n\t_next.flags&=HostEffectMask;workInProgress=_next;return;}if((completedWork.mode&ProfileMode)!==NoMode){// Record the render duration for the fiber that errored.\n\tstopProfilerTimerIfRunningAndRecordDelta(completedWork,false);// Include the time spent working on failed children before continuing.\n\tvar actualDuration=completedWork.actualDuration;var child=completedWork.child;while(child!==null){actualDuration+=child.actualDuration;child=child.sibling;}completedWork.actualDuration=actualDuration;}if(returnFiber!==null){// Mark the parent fiber as incomplete and clear its subtree flags.\n\treturnFiber.flags|=Incomplete;returnFiber.subtreeFlags=NoFlags;returnFiber.deletions=null;}else {// We've unwound all the way to the root.\n\tworkInProgressRootExitStatus=RootDidNotComplete;workInProgress=null;return;}}var siblingFiber=completedWork.sibling;if(siblingFiber!==null){// If there is more work to do in this returnFiber, do that next.\n\tworkInProgress=siblingFiber;return;}// Otherwise, return to the parent\n\tcompletedWork=returnFiber;// Update the next thing we're working on in case something throws.\n\tworkInProgress=completedWork;}while(completedWork!==null);// We've reached the root.\n\tif(workInProgressRootExitStatus===RootInProgress){workInProgressRootExitStatus=RootCompleted;}}function commitRoot(root,recoverableErrors,transitions){// TODO: This no longer makes any sense. We already wrap the mutation and\n\t// layout phases. Should be able to remove.\n\tvar previousUpdateLanePriority=getCurrentUpdatePriority();var prevTransition=ReactCurrentBatchConfig$3.transition;try{ReactCurrentBatchConfig$3.transition=null;setCurrentUpdatePriority(DiscreteEventPriority);commitRootImpl(root,recoverableErrors,transitions,previousUpdateLanePriority);}finally{ReactCurrentBatchConfig$3.transition=prevTransition;setCurrentUpdatePriority(previousUpdateLanePriority);}return null;}function commitRootImpl(root,recoverableErrors,transitions,renderPriorityLevel){do{// `flushPassiveEffects` will call `flushSyncUpdateQueue` at the end, which\n\t// means `flushPassiveEffects` will sometimes result in additional\n\t// passive effects. So we need to keep flushing in a loop until there are\n\t// no more pending effects.\n\t// TODO: Might be better if `flushPassiveEffects` did not automatically\n\t// flush synchronous work at the end, to avoid factoring hazards like this.\n\tflushPassiveEffects();}while(rootWithPendingPassiveEffects!==null);flushRenderPhaseStrictModeWarningsInDEV();if((executionContext&(RenderContext|CommitContext))!==NoContext){throw new Error('Should not already be working.');}var finishedWork=root.finishedWork;var lanes=root.finishedLanes;{markCommitStarted(lanes);}if(finishedWork===null){{markCommitStopped();}return null;}else {{if(lanes===NoLanes){error('root.finishedLanes should not be empty during a commit. This is a '+'bug in React.');}}}root.finishedWork=null;root.finishedLanes=NoLanes;if(finishedWork===root.current){throw new Error('Cannot commit the same tree as before. This error is likely caused by '+'a bug in React. Please file an issue.');}// commitRoot never returns a continuation; it always finishes synchronously.\n\t// So we can clear these now to allow a new callback to be scheduled.\n\troot.callbackNode=null;root.callbackPriority=NoLane;// Update the first and last pending times on this root. The new first\n\t// pending time is whatever is left on the root fiber.\n\tvar remainingLanes=mergeLanes(finishedWork.lanes,finishedWork.childLanes);markRootFinished(root,remainingLanes);if(root===workInProgressRoot){// We can reset these now that they are finished.\n\tworkInProgressRoot=null;workInProgress=null;workInProgressRootRenderLanes=NoLanes;}// If there are pending passive effects, schedule a callback to process them.\n\t// Do this as early as possible, so it is queued before anything else that\n\t// might get scheduled in the commit phase. (See #16714.)\n\t// TODO: Delete all other places that schedule the passive effect callback\n\t// They're redundant.\n\tif((finishedWork.subtreeFlags&PassiveMask)!==NoFlags||(finishedWork.flags&PassiveMask)!==NoFlags){if(!rootDoesHavePassiveEffects){rootDoesHavePassiveEffects=true;// to store it in pendingPassiveTransitions until they get processed\n\t// We need to pass this through as an argument to commitRoot\n\t// because workInProgressTransitions might have changed between\n\t// the previous render and commit if we throttle the commit\n\t// with setTimeout\n\tpendingPassiveTransitions=transitions;scheduleCallback$1(NormalPriority,function(){flushPassiveEffects();// This render triggered passive effects: release the root cache pool\n\t// *after* passive effects fire to avoid freeing a cache pool that may\n\t// be referenced by a node in the tree (HostRoot, Cache boundary etc)\n\treturn null;});}}// Check if there are any effects in the whole tree.\n\t// TODO: This is left over from the effect list implementation, where we had\n\t// to check for the existence of `firstEffect` to satisfy Flow. I think the\n\t// only other reason this optimization exists is because it affects profiling.\n\t// Reconsider whether this is necessary.\n\tvar subtreeHasEffects=(finishedWork.subtreeFlags&(BeforeMutationMask|MutationMask|LayoutMask|PassiveMask))!==NoFlags;var rootHasEffect=(finishedWork.flags&(BeforeMutationMask|MutationMask|LayoutMask|PassiveMask))!==NoFlags;if(subtreeHasEffects||rootHasEffect){var prevTransition=ReactCurrentBatchConfig$3.transition;ReactCurrentBatchConfig$3.transition=null;var previousPriority=getCurrentUpdatePriority();setCurrentUpdatePriority(DiscreteEventPriority);var prevExecutionContext=executionContext;executionContext|=CommitContext;// Reset this to null before calling lifecycles\n\tReactCurrentOwner$2.current=null;// The commit phase is broken into several sub-phases. We do a separate pass\n\t// of the effect list for each phase: all mutation effects come before all\n\t// layout effects, and so on.\n\t// The first phase a \"before mutation\" phase. We use this phase to read the\n\t// state of the host tree right before we mutate it. This is where\n\t// getSnapshotBeforeUpdate is called.\n\tcommitBeforeMutationEffects(root,finishedWork);{// Mark the current commit time to be shared by all Profilers in this\n\t// batch. This enables them to be grouped later.\n\trecordCommitTime();}commitMutationEffects(root,finishedWork,lanes);resetAfterCommit(root.containerInfo);// The work-in-progress tree is now the current tree. This must come after\n\t// the mutation phase, so that the previous tree is still current during\n\t// componentWillUnmount, but before the layout phase, so that the finished\n\t// work is current during componentDidMount/Update.\n\troot.current=finishedWork;// The next phase is the layout phase, where we call effects that read\n\t{markLayoutEffectsStarted(lanes);}commitLayoutEffects(finishedWork,root,lanes);{markLayoutEffectsStopped();}// opportunity to paint.\n\trequestPaint();executionContext=prevExecutionContext;// Reset the priority to the previous non-sync value.\n\tsetCurrentUpdatePriority(previousPriority);ReactCurrentBatchConfig$3.transition=prevTransition;}else {// No effects.\n\troot.current=finishedWork;// Measure these anyway so the flamegraph explicitly shows that there were\n\t// no effects.\n\t// TODO: Maybe there's a better way to report this.\n\t{recordCommitTime();}}var rootDidHavePassiveEffects=rootDoesHavePassiveEffects;if(rootDoesHavePassiveEffects){// This commit has passive effects. Stash a reference to them. But don't\n\t// schedule a callback until after flushing layout work.\n\trootDoesHavePassiveEffects=false;rootWithPendingPassiveEffects=root;pendingPassiveEffectsLanes=lanes;}else {{nestedPassiveUpdateCount=0;rootWithPassiveNestedUpdates=null;}}// Read this again, since an effect might have updated it\n\tremainingLanes=root.pendingLanes;// Check if there's remaining work on this root\n\t// TODO: This is part of the `componentDidCatch` implementation. Its purpose\n\t// is to detect whether something might have called setState inside\n\t// `componentDidCatch`. The mechanism is known to be flawed because `setState`\n\t// inside `componentDidCatch` is itself flawed — that's why we recommend\n\t// `getDerivedStateFromError` instead. However, it could be improved by\n\t// checking if remainingLanes includes Sync work, instead of whether there's\n\t// any work remaining at all (which would also include stuff like Suspense\n\t// retries or transitions). It's been like this for a while, though, so fixing\n\t// it probably isn't that urgent.\n\tif(remainingLanes===NoLanes){// If there's no remaining work, we can clear the set of already failed\n\t// error boundaries.\n\tlegacyErrorBoundariesThatAlreadyFailed=null;}{if(!rootDidHavePassiveEffects){commitDoubleInvokeEffectsInDEV(root.current,false);}}onCommitRoot(finishedWork.stateNode,renderPriorityLevel);{if(isDevToolsPresent){root.memoizedUpdaters.clear();}}{onCommitRoot$1();}// Always call this before exiting `commitRoot`, to ensure that any\n\t// additional work on this root is scheduled.\n\tensureRootIsScheduled(root,now());if(recoverableErrors!==null){// There were errors during this render, but recovered from them without\n\t// needing to surface it to the UI. We log them here.\n\tvar onRecoverableError=root.onRecoverableError;for(var i=0;i<recoverableErrors.length;i++){var recoverableError=recoverableErrors[i];var componentStack=recoverableError.stack;var digest=recoverableError.digest;onRecoverableError(recoverableError.value,{componentStack:componentStack,digest:digest});}}if(hasUncaughtError){hasUncaughtError=false;var error$1=firstUncaughtError;firstUncaughtError=null;throw error$1;}// If the passive effects are the result of a discrete render, flush them\n\t// synchronously at the end of the current task so that the result is\n\t// immediately observable. Otherwise, we assume that they are not\n\t// order-dependent and do not need to be observed by external systems, so we\n\t// can wait until after paint.\n\t// TODO: We can optimize this by not scheduling the callback earlier. Since we\n\t// currently schedule the callback in multiple places, will wait until those\n\t// are consolidated.\n\tif(includesSomeLane(pendingPassiveEffectsLanes,SyncLane)&&root.tag!==LegacyRoot){flushPassiveEffects();}// Read this again, since a passive effect might have updated it\n\tremainingLanes=root.pendingLanes;if(includesSomeLane(remainingLanes,SyncLane)){{markNestedUpdateScheduled();}// Count the number of times the root synchronously re-renders without\n\t// finishing. If there are too many, it indicates an infinite update loop.\n\tif(root===rootWithNestedUpdates){nestedUpdateCount++;}else {nestedUpdateCount=0;rootWithNestedUpdates=root;}}else {nestedUpdateCount=0;}// If layout work was scheduled, flush it now.\n\tflushSyncCallbacks();{markCommitStopped();}return null;}function flushPassiveEffects(){// Returns whether passive effects were flushed.\n\t// TODO: Combine this check with the one in flushPassiveEFfectsImpl. We should\n\t// probably just combine the two functions. I believe they were only separate\n\t// in the first place because we used to wrap it with\n\t// `Scheduler.runWithPriority`, which accepts a function. But now we track the\n\t// priority within React itself, so we can mutate the variable directly.\n\tif(rootWithPendingPassiveEffects!==null){var renderPriority=lanesToEventPriority(pendingPassiveEffectsLanes);var priority=lowerEventPriority(DefaultEventPriority,renderPriority);var prevTransition=ReactCurrentBatchConfig$3.transition;var previousPriority=getCurrentUpdatePriority();try{ReactCurrentBatchConfig$3.transition=null;setCurrentUpdatePriority(priority);return flushPassiveEffectsImpl();}finally{setCurrentUpdatePriority(previousPriority);ReactCurrentBatchConfig$3.transition=prevTransition;// Once passive effects have run for the tree - giving components a\n\t}}return false;}function enqueuePendingPassiveProfilerEffect(fiber){{pendingPassiveProfilerEffects.push(fiber);if(!rootDoesHavePassiveEffects){rootDoesHavePassiveEffects=true;scheduleCallback$1(NormalPriority,function(){flushPassiveEffects();return null;});}}}function flushPassiveEffectsImpl(){if(rootWithPendingPassiveEffects===null){return false;}// Cache and clear the transitions flag\n\tvar transitions=pendingPassiveTransitions;pendingPassiveTransitions=null;var root=rootWithPendingPassiveEffects;var lanes=pendingPassiveEffectsLanes;rootWithPendingPassiveEffects=null;// TODO: This is sometimes out of sync with rootWithPendingPassiveEffects.\n\t// Figure out why and fix it. It's not causing any known issues (probably\n\t// because it's only used for profiling), but it's a refactor hazard.\n\tpendingPassiveEffectsLanes=NoLanes;if((executionContext&(RenderContext|CommitContext))!==NoContext){throw new Error('Cannot flush passive effects while already rendering.');}{isFlushingPassiveEffects=true;didScheduleUpdateDuringPassiveEffects=false;}{markPassiveEffectsStarted(lanes);}var prevExecutionContext=executionContext;executionContext|=CommitContext;commitPassiveUnmountEffects(root.current);commitPassiveMountEffects(root,root.current,lanes,transitions);// TODO: Move to commitPassiveMountEffects\n\t{var profilerEffects=pendingPassiveProfilerEffects;pendingPassiveProfilerEffects=[];for(var i=0;i<profilerEffects.length;i++){var _fiber=profilerEffects[i];commitPassiveEffectDurations(root,_fiber);}}{markPassiveEffectsStopped();}{commitDoubleInvokeEffectsInDEV(root.current,true);}executionContext=prevExecutionContext;flushSyncCallbacks();{// If additional passive effects were scheduled, increment a counter. If this\n\t// exceeds the limit, we'll fire a warning.\n\tif(didScheduleUpdateDuringPassiveEffects){if(root===rootWithPassiveNestedUpdates){nestedPassiveUpdateCount++;}else {nestedPassiveUpdateCount=0;rootWithPassiveNestedUpdates=root;}}else {nestedPassiveUpdateCount=0;}isFlushingPassiveEffects=false;didScheduleUpdateDuringPassiveEffects=false;}// TODO: Move to commitPassiveMountEffects\n\tonPostCommitRoot(root);{var stateNode=root.current.stateNode;stateNode.effectDuration=0;stateNode.passiveEffectDuration=0;}return true;}function isAlreadyFailedLegacyErrorBoundary(instance){return legacyErrorBoundariesThatAlreadyFailed!==null&&legacyErrorBoundariesThatAlreadyFailed.has(instance);}function markLegacyErrorBoundaryAsFailed(instance){if(legacyErrorBoundariesThatAlreadyFailed===null){legacyErrorBoundariesThatAlreadyFailed=new Set([instance]);}else {legacyErrorBoundariesThatAlreadyFailed.add(instance);}}function prepareToThrowUncaughtError(error){if(!hasUncaughtError){hasUncaughtError=true;firstUncaughtError=error;}}var onUncaughtError=prepareToThrowUncaughtError;function captureCommitPhaseErrorOnRoot(rootFiber,sourceFiber,error){var errorInfo=createCapturedValueAtFiber(error,sourceFiber);var update=createRootErrorUpdate(rootFiber,errorInfo,SyncLane);var root=enqueueUpdate(rootFiber,update,SyncLane);var eventTime=requestEventTime();if(root!==null){markRootUpdated(root,SyncLane,eventTime);ensureRootIsScheduled(root,eventTime);}}function captureCommitPhaseError(sourceFiber,nearestMountedAncestor,error$1){{reportUncaughtErrorInDEV(error$1);setIsRunningInsertionEffect(false);}if(sourceFiber.tag===HostRoot){// Error was thrown at the root. There is no parent, so the root\n\t// itself should capture it.\n\tcaptureCommitPhaseErrorOnRoot(sourceFiber,sourceFiber,error$1);return;}var fiber=null;{fiber=nearestMountedAncestor;}while(fiber!==null){if(fiber.tag===HostRoot){captureCommitPhaseErrorOnRoot(fiber,sourceFiber,error$1);return;}else if(fiber.tag===ClassComponent){var ctor=fiber.type;var instance=fiber.stateNode;if(typeof ctor.getDerivedStateFromError==='function'||typeof instance.componentDidCatch==='function'&&!isAlreadyFailedLegacyErrorBoundary(instance)){var errorInfo=createCapturedValueAtFiber(error$1,sourceFiber);var update=createClassErrorUpdate(fiber,errorInfo,SyncLane);var root=enqueueUpdate(fiber,update,SyncLane);var eventTime=requestEventTime();if(root!==null){markRootUpdated(root,SyncLane,eventTime);ensureRootIsScheduled(root,eventTime);}return;}}fiber=fiber.return;}{// TODO: Until we re-land skipUnmountedBoundaries (see #20147), this warning\n\t// will fire for errors that are thrown by destroy functions inside deleted\n\t// trees. What it should instead do is propagate the error to the parent of\n\t// the deleted tree. In the meantime, do not add this warning to the\n\t// allowlist; this is only for our internal use.\n\terror('Internal React error: Attempted to capture a commit phase error '+'inside a detached tree. This indicates a bug in React. Likely '+'causes include deleting the same fiber more than once, committing an '+'already-finished tree, or an inconsistent return pointer.\\n\\n'+'Error message:\\n\\n%s',error$1);}}function pingSuspendedRoot(root,wakeable,pingedLanes){var pingCache=root.pingCache;if(pingCache!==null){// The wakeable resolved, so we no longer need to memoize, because it will\n\t// never be thrown again.\n\tpingCache.delete(wakeable);}var eventTime=requestEventTime();markRootPinged(root,pingedLanes);warnIfSuspenseResolutionNotWrappedWithActDEV(root);if(workInProgressRoot===root&&isSubsetOfLanes(workInProgressRootRenderLanes,pingedLanes)){// Received a ping at the same priority level at which we're currently\n\t// rendering. We might want to restart this render. This should mirror\n\t// the logic of whether or not a root suspends once it completes.\n\t// TODO: If we're rendering sync either due to Sync, Batched or expired,\n\t// we should probably never restart.\n\t// If we're suspended with delay, or if it's a retry, we'll always suspend\n\t// so we can always restart.\n\tif(workInProgressRootExitStatus===RootSuspendedWithDelay||workInProgressRootExitStatus===RootSuspended&&includesOnlyRetries(workInProgressRootRenderLanes)&&now()-globalMostRecentFallbackTime<FALLBACK_THROTTLE_MS){// Restart from the root.\n\tprepareFreshStack(root,NoLanes);}else {// Even though we can't restart right now, we might get an\n\t// opportunity later. So we mark this render as having a ping.\n\tworkInProgressRootPingedLanes=mergeLanes(workInProgressRootPingedLanes,pingedLanes);}}ensureRootIsScheduled(root,eventTime);}function retryTimedOutBoundary(boundaryFiber,retryLane){// The boundary fiber (a Suspense component or SuspenseList component)\n\t// previously was rendered in its fallback state. One of the promises that\n\t// suspended it has resolved, which means at least part of the tree was\n\t// likely unblocked. Try rendering again, at a new lanes.\n\tif(retryLane===NoLane){// TODO: Assign this to `suspenseState.retryLane`? to avoid\n\t// unnecessary entanglement?\n\tretryLane=requestRetryLane(boundaryFiber);}// TODO: Special case idle priority?\n\tvar eventTime=requestEventTime();var root=enqueueConcurrentRenderForLane(boundaryFiber,retryLane);if(root!==null){markRootUpdated(root,retryLane,eventTime);ensureRootIsScheduled(root,eventTime);}}function retryDehydratedSuspenseBoundary(boundaryFiber){var suspenseState=boundaryFiber.memoizedState;var retryLane=NoLane;if(suspenseState!==null){retryLane=suspenseState.retryLane;}retryTimedOutBoundary(boundaryFiber,retryLane);}function resolveRetryWakeable(boundaryFiber,wakeable){var retryLane=NoLane;// Default\n\tvar retryCache;switch(boundaryFiber.tag){case SuspenseComponent:retryCache=boundaryFiber.stateNode;var suspenseState=boundaryFiber.memoizedState;if(suspenseState!==null){retryLane=suspenseState.retryLane;}break;case SuspenseListComponent:retryCache=boundaryFiber.stateNode;break;default:throw new Error('Pinged unknown suspense boundary type. '+'This is probably a bug in React.');}if(retryCache!==null){// The wakeable resolved, so we no longer need to memoize, because it will\n\t// never be thrown again.\n\tretryCache.delete(wakeable);}retryTimedOutBoundary(boundaryFiber,retryLane);}// Computes the next Just Noticeable Difference (JND) boundary.\n\t// The theory is that a person can't tell the difference between small differences in time.\n\t// Therefore, if we wait a bit longer than necessary that won't translate to a noticeable\n\t// difference in the experience. However, waiting for longer might mean that we can avoid\n\t// showing an intermediate loading state. The longer we have already waited, the harder it\n\t// is to tell small differences in time. Therefore, the longer we've already waited,\n\t// the longer we can wait additionally. At some point we have to give up though.\n\t// We pick a train model where the next boundary commits at a consistent schedule.\n\t// These particular numbers are vague estimates. We expect to adjust them based on research.\n\tfunction jnd(timeElapsed){return timeElapsed<120?120:timeElapsed<480?480:timeElapsed<1080?1080:timeElapsed<1920?1920:timeElapsed<3000?3000:timeElapsed<4320?4320:ceil(timeElapsed/1960)*1960;}function checkForNestedUpdates(){if(nestedUpdateCount>NESTED_UPDATE_LIMIT){nestedUpdateCount=0;rootWithNestedUpdates=null;throw new Error('Maximum update depth exceeded. This can happen when a component '+'repeatedly calls setState inside componentWillUpdate or '+'componentDidUpdate. React limits the number of nested updates to '+'prevent infinite loops.');}{if(nestedPassiveUpdateCount>NESTED_PASSIVE_UPDATE_LIMIT){nestedPassiveUpdateCount=0;rootWithPassiveNestedUpdates=null;error('Maximum update depth exceeded. This can happen when a component '+\"calls setState inside useEffect, but useEffect either doesn't \"+'have a dependency array, or one of the dependencies changes on '+'every render.');}}}function flushRenderPhaseStrictModeWarningsInDEV(){{ReactStrictModeWarnings.flushLegacyContextWarning();{ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();}}}function commitDoubleInvokeEffectsInDEV(fiber,hasPassiveEffects){{// TODO (StrictEffects) Should we set a marker on the root if it contains strict effects\n\t// so we don't traverse unnecessarily? similar to subtreeFlags but just at the root level.\n\t// Maybe not a big deal since this is DEV only behavior.\n\tsetCurrentFiber(fiber);invokeEffectsInDev(fiber,MountLayoutDev,invokeLayoutEffectUnmountInDEV);if(hasPassiveEffects){invokeEffectsInDev(fiber,MountPassiveDev,invokePassiveEffectUnmountInDEV);}invokeEffectsInDev(fiber,MountLayoutDev,invokeLayoutEffectMountInDEV);if(hasPassiveEffects){invokeEffectsInDev(fiber,MountPassiveDev,invokePassiveEffectMountInDEV);}resetCurrentFiber();}}function invokeEffectsInDev(firstChild,fiberFlags,invokeEffectFn){{// We don't need to re-check StrictEffectsMode here.\n\t// This function is only called if that check has already passed.\n\tvar current=firstChild;var subtreeRoot=null;while(current!==null){var primarySubtreeFlag=current.subtreeFlags&fiberFlags;if(current!==subtreeRoot&&current.child!==null&&primarySubtreeFlag!==NoFlags){current=current.child;}else {if((current.flags&fiberFlags)!==NoFlags){invokeEffectFn(current);}if(current.sibling!==null){current=current.sibling;}else {current=subtreeRoot=current.return;}}}}}var didWarnStateUpdateForNotYetMountedComponent=null;function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber){{if((executionContext&RenderContext)!==NoContext){// We let the other warning about render phase updates deal with this one.\n\treturn;}if(!(fiber.mode&ConcurrentMode)){return;}var tag=fiber.tag;if(tag!==IndeterminateComponent&&tag!==HostRoot&&tag!==ClassComponent&&tag!==FunctionComponent&&tag!==ForwardRef&&tag!==MemoComponent&&tag!==SimpleMemoComponent){// Only warn for user-defined components, not internal ones like Suspense.\n\treturn;}// We show the whole stack but dedupe on the top component's name because\n\t// the problematic code almost always lies inside that component.\n\tvar componentName=getComponentNameFromFiber(fiber)||'ReactComponent';if(didWarnStateUpdateForNotYetMountedComponent!==null){if(didWarnStateUpdateForNotYetMountedComponent.has(componentName)){return;}didWarnStateUpdateForNotYetMountedComponent.add(componentName);}else {didWarnStateUpdateForNotYetMountedComponent=new Set([componentName]);}var previousFiber=current;try{setCurrentFiber(fiber);error(\"Can't perform a React state update on a component that hasn't mounted yet. \"+'This indicates that you have a side-effect in your render function that '+'asynchronously later calls tries to update the component. Move this work to '+'useEffect instead.');}finally{if(previousFiber){setCurrentFiber(fiber);}else {resetCurrentFiber();}}}}var beginWork$1;{var dummyFiber=null;beginWork$1=function(current,unitOfWork,lanes){// If a component throws an error, we replay it again in a synchronously\n\t// dispatched event, so that the debugger will treat it as an uncaught\n\t// error See ReactErrorUtils for more information.\n\t// Before entering the begin phase, copy the work-in-progress onto a dummy\n\t// fiber. If beginWork throws, we'll use this to reset the state.\n\tvar originalWorkInProgressCopy=assignFiberPropertiesInDEV(dummyFiber,unitOfWork);try{return beginWork(current,unitOfWork,lanes);}catch(originalError){if(didSuspendOrErrorWhileHydratingDEV()||originalError!==null&&typeof originalError==='object'&&typeof originalError.then==='function'){// Don't replay promises.\n\t// Don't replay errors if we are hydrating and have already suspended or handled an error\n\tthrow originalError;}// Keep this code in sync with handleError; any changes here must have\n\t// corresponding changes there.\n\tresetContextDependencies();resetHooksAfterThrow();// Don't reset current debug fiber, since we're about to work on the\n\t// same fiber again.\n\t// Unwind the failed stack frame\n\tunwindInterruptedWork(current,unitOfWork);// Restore the original properties of the fiber.\n\tassignFiberPropertiesInDEV(unitOfWork,originalWorkInProgressCopy);if(unitOfWork.mode&ProfileMode){// Reset the profiler timer.\n\tstartProfilerTimer(unitOfWork);}// Run beginWork again.\n\tinvokeGuardedCallback(null,beginWork,null,current,unitOfWork,lanes);if(hasCaughtError()){var replayError=clearCaughtError();if(typeof replayError==='object'&&replayError!==null&&replayError._suppressLogging&&typeof originalError==='object'&&originalError!==null&&!originalError._suppressLogging){// If suppressed, let the flag carry over to the original error which is the one we'll rethrow.\n\toriginalError._suppressLogging=true;}}// We always throw the original error in case the second render pass is not idempotent.\n\t// This can happen if a memoized function or CommonJS module doesn't throw after first invocation.\n\tthrow originalError;}};}var didWarnAboutUpdateInRender=false;var didWarnAboutUpdateInRenderForAnotherComponent;{didWarnAboutUpdateInRenderForAnotherComponent=new Set();}function warnAboutRenderPhaseUpdatesInDEV(fiber){{if(isRendering&&!getIsUpdatingOpaqueValueInRenderPhaseInDEV()){switch(fiber.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{var renderingComponentName=workInProgress&&getComponentNameFromFiber(workInProgress)||'Unknown';// Dedupe by the rendering component because it's the one that needs to be fixed.\n\tvar dedupeKey=renderingComponentName;if(!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)){didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);var setStateComponentName=getComponentNameFromFiber(fiber)||'Unknown';error('Cannot update a component (`%s`) while rendering a '+'different component (`%s`). To locate the bad setState() call inside `%s`, '+'follow the stack trace as described in https://reactjs.org/link/setstate-in-render',setStateComponentName,renderingComponentName,renderingComponentName);}break;}case ClassComponent:{if(!didWarnAboutUpdateInRender){error('Cannot update during an existing state transition (such as '+'within `render`). Render methods should be a pure '+'function of props and state.');didWarnAboutUpdateInRender=true;}break;}}}}}function restorePendingUpdaters(root,lanes){{if(isDevToolsPresent){var memoizedUpdaters=root.memoizedUpdaters;memoizedUpdaters.forEach(function(schedulingFiber){addFiberToLanesMap(root,schedulingFiber,lanes);});// This function intentionally does not clear memoized updaters.\n\t// Those may still be relevant to the current commit\n\t// and a future one (e.g. Suspense).\n\t}}}var fakeActCallbackNode={};function scheduleCallback$1(priorityLevel,callback){{// If we're currently inside an `act` scope, bypass Scheduler and push to\n\t// the `act` queue instead.\n\tvar actQueue=ReactCurrentActQueue$1.current;if(actQueue!==null){actQueue.push(callback);return fakeActCallbackNode;}else {return scheduleCallback(priorityLevel,callback);}}}function cancelCallback$1(callbackNode){if(callbackNode===fakeActCallbackNode){return;}// In production, always call Scheduler. This function will be stripped out.\n\treturn cancelCallback(callbackNode);}function shouldForceFlushFallbacksInDEV(){// Never force flush in production. This function should get stripped out.\n\treturn ReactCurrentActQueue$1.current!==null;}function warnIfUpdatesNotWrappedWithActDEV(fiber){{if(fiber.mode&ConcurrentMode){if(!isConcurrentActEnvironment()){// Not in an act environment. No need to warn.\n\treturn;}}else {// Legacy mode has additional cases where we suppress a warning.\n\tif(!isLegacyActEnvironment()){// Not in an act environment. No need to warn.\n\treturn;}if(executionContext!==NoContext){// Legacy mode doesn't warn if the update is batched, i.e.\n\t// batchedUpdates or flushSync.\n\treturn;}if(fiber.tag!==FunctionComponent&&fiber.tag!==ForwardRef&&fiber.tag!==SimpleMemoComponent){// For backwards compatibility with pre-hooks code, legacy mode only\n\t// warns for updates that originate from a hook.\n\treturn;}}if(ReactCurrentActQueue$1.current===null){var previousFiber=current;try{setCurrentFiber(fiber);error('An update to %s inside a test was not wrapped in act(...).\\n\\n'+'When testing, code that causes React state updates should be '+'wrapped into act(...):\\n\\n'+'act(() => {\\n'+'  /* fire events that update state */\\n'+'});\\n'+'/* assert on the output */\\n\\n'+\"This ensures that you're testing the behavior the user would see \"+'in the browser.'+' Learn more at https://reactjs.org/link/wrap-tests-with-act',getComponentNameFromFiber(fiber));}finally{if(previousFiber){setCurrentFiber(fiber);}else {resetCurrentFiber();}}}}}function warnIfSuspenseResolutionNotWrappedWithActDEV(root){{if(root.tag!==LegacyRoot&&isConcurrentActEnvironment()&&ReactCurrentActQueue$1.current===null){error('A suspended resource finished loading inside a test, but the event '+'was not wrapped in act(...).\\n\\n'+'When testing, code that resolves suspended data should be wrapped '+'into act(...):\\n\\n'+'act(() => {\\n'+'  /* finish loading suspended data */\\n'+'});\\n'+'/* assert on the output */\\n\\n'+\"This ensures that you're testing the behavior the user would see \"+'in the browser.'+' Learn more at https://reactjs.org/link/wrap-tests-with-act');}}}function setIsRunningInsertionEffect(isRunning){{isRunningInsertionEffect=isRunning;}}/* eslint-disable react-internal/prod-error-codes */var resolveFamily=null;// $FlowFixMe Flow gets confused by a WeakSet feature check below.\n\tvar failedBoundaries=null;var setRefreshHandler=function(handler){{resolveFamily=handler;}};function resolveFunctionForHotReloading(type){{if(resolveFamily===null){// Hot reloading is disabled.\n\treturn type;}var family=resolveFamily(type);if(family===undefined){return type;}// Use the latest known implementation.\n\treturn family.current;}}function resolveClassForHotReloading(type){// No implementation differences.\n\treturn resolveFunctionForHotReloading(type);}function resolveForwardRefForHotReloading(type){{if(resolveFamily===null){// Hot reloading is disabled.\n\treturn type;}var family=resolveFamily(type);if(family===undefined){// Check if we're dealing with a real forwardRef. Don't want to crash early.\n\tif(type!==null&&type!==undefined&&typeof type.render==='function'){// ForwardRef is special because its resolved .type is an object,\n\t// but it's possible that we only have its inner render function in the map.\n\t// If that inner render function is different, we'll build a new forwardRef type.\n\tvar currentRender=resolveFunctionForHotReloading(type.render);if(type.render!==currentRender){var syntheticType={$$typeof:REACT_FORWARD_REF_TYPE,render:currentRender};if(type.displayName!==undefined){syntheticType.displayName=type.displayName;}return syntheticType;}}return type;}// Use the latest known implementation.\n\treturn family.current;}}function isCompatibleFamilyForHotReloading(fiber,element){{if(resolveFamily===null){// Hot reloading is disabled.\n\treturn false;}var prevType=fiber.elementType;var nextType=element.type;// If we got here, we know types aren't === equal.\n\tvar needsCompareFamilies=false;var $$typeofNextType=typeof nextType==='object'&&nextType!==null?nextType.$$typeof:null;switch(fiber.tag){case ClassComponent:{if(typeof nextType==='function'){needsCompareFamilies=true;}break;}case FunctionComponent:{if(typeof nextType==='function'){needsCompareFamilies=true;}else if($$typeofNextType===REACT_LAZY_TYPE){// We don't know the inner type yet.\n\t// We're going to assume that the lazy inner type is stable,\n\t// and so it is sufficient to avoid reconciling it away.\n\t// We're not going to unwrap or actually use the new lazy type.\n\tneedsCompareFamilies=true;}break;}case ForwardRef:{if($$typeofNextType===REACT_FORWARD_REF_TYPE){needsCompareFamilies=true;}else if($$typeofNextType===REACT_LAZY_TYPE){needsCompareFamilies=true;}break;}case MemoComponent:case SimpleMemoComponent:{if($$typeofNextType===REACT_MEMO_TYPE){// TODO: if it was but can no longer be simple,\n\t// we shouldn't set this.\n\tneedsCompareFamilies=true;}else if($$typeofNextType===REACT_LAZY_TYPE){needsCompareFamilies=true;}break;}default:return false;}// Check if both types have a family and it's the same one.\n\tif(needsCompareFamilies){// Note: memo() and forwardRef() we'll compare outer rather than inner type.\n\t// This means both of them need to be registered to preserve state.\n\t// If we unwrapped and compared the inner types for wrappers instead,\n\t// then we would risk falsely saying two separate memo(Foo)\n\t// calls are equivalent because they wrap the same Foo function.\n\tvar prevFamily=resolveFamily(prevType);if(prevFamily!==undefined&&prevFamily===resolveFamily(nextType)){return true;}}return false;}}function markFailedErrorBoundaryForHotReloading(fiber){{if(resolveFamily===null){// Hot reloading is disabled.\n\treturn;}if(typeof WeakSet!=='function'){return;}if(failedBoundaries===null){failedBoundaries=new WeakSet();}failedBoundaries.add(fiber);}}var scheduleRefresh=function(root,update){{if(resolveFamily===null){// Hot reloading is disabled.\n\treturn;}var staleFamilies=update.staleFamilies,updatedFamilies=update.updatedFamilies;flushPassiveEffects();flushSync(function(){scheduleFibersWithFamiliesRecursively(root.current,updatedFamilies,staleFamilies);});}};var scheduleRoot=function(root,element){{if(root.context!==emptyContextObject){// Super edge case: root has a legacy _renderSubtree context\n\t// but we don't know the parentComponent so we can't pass it.\n\t// Just ignore. We'll delete this with _renderSubtree code path later.\n\treturn;}flushPassiveEffects();flushSync(function(){updateContainer(element,root,null,null);});}};function scheduleFibersWithFamiliesRecursively(fiber,updatedFamilies,staleFamilies){{var alternate=fiber.alternate,child=fiber.child,sibling=fiber.sibling,tag=fiber.tag,type=fiber.type;var candidateType=null;switch(tag){case FunctionComponent:case SimpleMemoComponent:case ClassComponent:candidateType=type;break;case ForwardRef:candidateType=type.render;break;}if(resolveFamily===null){throw new Error('Expected resolveFamily to be set during hot reload.');}var needsRender=false;var needsRemount=false;if(candidateType!==null){var family=resolveFamily(candidateType);if(family!==undefined){if(staleFamilies.has(family)){needsRemount=true;}else if(updatedFamilies.has(family)){if(tag===ClassComponent){needsRemount=true;}else {needsRender=true;}}}}if(failedBoundaries!==null){if(failedBoundaries.has(fiber)||alternate!==null&&failedBoundaries.has(alternate)){needsRemount=true;}}if(needsRemount){fiber._debugNeedsRemount=true;}if(needsRemount||needsRender){var _root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(_root!==null){scheduleUpdateOnFiber(_root,fiber,SyncLane,NoTimestamp);}}if(child!==null&&!needsRemount){scheduleFibersWithFamiliesRecursively(child,updatedFamilies,staleFamilies);}if(sibling!==null){scheduleFibersWithFamiliesRecursively(sibling,updatedFamilies,staleFamilies);}}}var findHostInstancesForRefresh=function(root,families){{var hostInstances=new Set();var types=new Set(families.map(function(family){return family.current;}));findHostInstancesForMatchingFibersRecursively(root.current,types,hostInstances);return hostInstances;}};function findHostInstancesForMatchingFibersRecursively(fiber,types,hostInstances){{var child=fiber.child,sibling=fiber.sibling,tag=fiber.tag,type=fiber.type;var candidateType=null;switch(tag){case FunctionComponent:case SimpleMemoComponent:case ClassComponent:candidateType=type;break;case ForwardRef:candidateType=type.render;break;}var didMatch=false;if(candidateType!==null){if(types.has(candidateType)){didMatch=true;}}if(didMatch){// We have a match. This only drills down to the closest host components.\n\t// There's no need to search deeper because for the purpose of giving\n\t// visual feedback, \"flashing\" outermost parent rectangles is sufficient.\n\tfindHostInstancesForFiberShallowly(fiber,hostInstances);}else {// If there's no match, maybe there will be one further down in the child tree.\n\tif(child!==null){findHostInstancesForMatchingFibersRecursively(child,types,hostInstances);}}if(sibling!==null){findHostInstancesForMatchingFibersRecursively(sibling,types,hostInstances);}}}function findHostInstancesForFiberShallowly(fiber,hostInstances){{var foundHostInstances=findChildHostInstancesForFiberShallowly(fiber,hostInstances);if(foundHostInstances){return;}// If we didn't find any host children, fallback to closest host parent.\n\tvar node=fiber;while(true){switch(node.tag){case HostComponent:hostInstances.add(node.stateNode);return;case HostPortal:hostInstances.add(node.stateNode.containerInfo);return;case HostRoot:hostInstances.add(node.stateNode.containerInfo);return;}if(node.return===null){throw new Error('Expected to reach root first.');}node=node.return;}}}function findChildHostInstancesForFiberShallowly(fiber,hostInstances){{var node=fiber;var foundHostInstances=false;while(true){if(node.tag===HostComponent){// We got a match.\n\tfoundHostInstances=true;hostInstances.add(node.stateNode);// There may still be more, so keep searching.\n\t}else if(node.child!==null){node.child.return=node;node=node.child;continue;}if(node===fiber){return foundHostInstances;}while(node.sibling===null){if(node.return===null||node.return===fiber){return foundHostInstances;}node=node.return;}node.sibling.return=node.return;node=node.sibling;}}return false;}var hasBadMapPolyfill;{hasBadMapPolyfill=false;try{var nonExtensibleObject=Object.preventExtensions({});/* eslint-disable no-new */new Map([[nonExtensibleObject,null]]);new Set([nonExtensibleObject]);/* eslint-enable no-new */}catch(e){// TODO: Consider warning about bad polyfills\n\thasBadMapPolyfill=true;}}function FiberNode(tag,pendingProps,key,mode){// Instance\n\tthis.tag=tag;this.key=key;this.elementType=null;this.type=null;this.stateNode=null;// Fiber\n\tthis.return=null;this.child=null;this.sibling=null;this.index=0;this.ref=null;this.pendingProps=pendingProps;this.memoizedProps=null;this.updateQueue=null;this.memoizedState=null;this.dependencies=null;this.mode=mode;// Effects\n\tthis.flags=NoFlags;this.subtreeFlags=NoFlags;this.deletions=null;this.lanes=NoLanes;this.childLanes=NoLanes;this.alternate=null;{// Note: The following is done to avoid a v8 performance cliff.\n\t//\n\t// Initializing the fields below to smis and later updating them with\n\t// double values will cause Fibers to end up having separate shapes.\n\t// This behavior/bug has something to do with Object.preventExtension().\n\t// Fortunately this only impacts DEV builds.\n\t// Unfortunately it makes React unusably slow for some applications.\n\t// To work around this, initialize the fields below with doubles.\n\t//\n\t// Learn more about this here:\n\t// https://github.com/facebook/react/issues/14365\n\t// https://bugs.chromium.org/p/v8/issues/detail?id=8538\n\tthis.actualDuration=Number.NaN;this.actualStartTime=Number.NaN;this.selfBaseDuration=Number.NaN;this.treeBaseDuration=Number.NaN;// It's okay to replace the initial doubles with smis after initialization.\n\t// This won't trigger the performance cliff mentioned above,\n\t// and it simplifies other profiler code (including DevTools).\n\tthis.actualDuration=0;this.actualStartTime=-1;this.selfBaseDuration=0;this.treeBaseDuration=0;}{// This isn't directly used but is handy for debugging internals:\n\tthis._debugSource=null;this._debugOwner=null;this._debugNeedsRemount=false;this._debugHookTypes=null;if(!hasBadMapPolyfill&&typeof Object.preventExtensions==='function'){Object.preventExtensions(this);}}}// This is a constructor function, rather than a POJO constructor, still\n\t// please ensure we do the following:\n\t// 1) Nobody should add any instance methods on this. Instance methods can be\n\t//    more difficult to predict when they get optimized and they are almost\n\t//    never inlined properly in static compilers.\n\t// 2) Nobody should rely on `instanceof Fiber` for type testing. We should\n\t//    always know when it is a fiber.\n\t// 3) We might want to experiment with using numeric keys since they are easier\n\t//    to optimize in a non-JIT environment.\n\t// 4) We can easily go from a constructor to a createFiber object literal if that\n\t//    is faster.\n\t// 5) It should be easy to port this to a C struct and keep a C implementation\n\t//    compatible.\n\tvar createFiber=function(tag,pendingProps,key,mode){// $FlowFixMe: the shapes are exact here but Flow doesn't like constructors\n\treturn new FiberNode(tag,pendingProps,key,mode);};function shouldConstruct$1(Component){var prototype=Component.prototype;return !!(prototype&&prototype.isReactComponent);}function isSimpleFunctionComponent(type){return typeof type==='function'&&!shouldConstruct$1(type)&&type.defaultProps===undefined;}function resolveLazyComponentTag(Component){if(typeof Component==='function'){return shouldConstruct$1(Component)?ClassComponent:FunctionComponent;}else if(Component!==undefined&&Component!==null){var $$typeof=Component.$$typeof;if($$typeof===REACT_FORWARD_REF_TYPE){return ForwardRef;}if($$typeof===REACT_MEMO_TYPE){return MemoComponent;}}return IndeterminateComponent;}// This is used to create an alternate fiber to do work on.\n\tfunction createWorkInProgress(current,pendingProps){var workInProgress=current.alternate;if(workInProgress===null){// We use a double buffering pooling technique because we know that we'll\n\t// only ever need at most two versions of a tree. We pool the \"other\" unused\n\t// node that we're free to reuse. This is lazily created to avoid allocating\n\t// extra objects for things that are never updated. It also allow us to\n\t// reclaim the extra memory if needed.\n\tworkInProgress=createFiber(current.tag,pendingProps,current.key,current.mode);workInProgress.elementType=current.elementType;workInProgress.type=current.type;workInProgress.stateNode=current.stateNode;{// DEV-only fields\n\tworkInProgress._debugSource=current._debugSource;workInProgress._debugOwner=current._debugOwner;workInProgress._debugHookTypes=current._debugHookTypes;}workInProgress.alternate=current;current.alternate=workInProgress;}else {workInProgress.pendingProps=pendingProps;// Needed because Blocks store data on type.\n\tworkInProgress.type=current.type;// We already have an alternate.\n\t// Reset the effect tag.\n\tworkInProgress.flags=NoFlags;// The effects are no longer valid.\n\tworkInProgress.subtreeFlags=NoFlags;workInProgress.deletions=null;{// We intentionally reset, rather than copy, actualDuration & actualStartTime.\n\t// This prevents time from endlessly accumulating in new commits.\n\t// This has the downside of resetting values for different priority renders,\n\t// But works for yielding (the common case) and should support resuming.\n\tworkInProgress.actualDuration=0;workInProgress.actualStartTime=-1;}}// Reset all effects except static ones.\n\t// Static effects are not specific to a render.\n\tworkInProgress.flags=current.flags&StaticMask;workInProgress.childLanes=current.childLanes;workInProgress.lanes=current.lanes;workInProgress.child=current.child;workInProgress.memoizedProps=current.memoizedProps;workInProgress.memoizedState=current.memoizedState;workInProgress.updateQueue=current.updateQueue;// Clone the dependencies object. This is mutated during the render phase, so\n\t// it cannot be shared with the current fiber.\n\tvar currentDependencies=current.dependencies;workInProgress.dependencies=currentDependencies===null?null:{lanes:currentDependencies.lanes,firstContext:currentDependencies.firstContext};// These will be overridden during the parent's reconciliation\n\tworkInProgress.sibling=current.sibling;workInProgress.index=current.index;workInProgress.ref=current.ref;{workInProgress.selfBaseDuration=current.selfBaseDuration;workInProgress.treeBaseDuration=current.treeBaseDuration;}{workInProgress._debugNeedsRemount=current._debugNeedsRemount;switch(workInProgress.tag){case IndeterminateComponent:case FunctionComponent:case SimpleMemoComponent:workInProgress.type=resolveFunctionForHotReloading(current.type);break;case ClassComponent:workInProgress.type=resolveClassForHotReloading(current.type);break;case ForwardRef:workInProgress.type=resolveForwardRefForHotReloading(current.type);break;}}return workInProgress;}// Used to reuse a Fiber for a second pass.\n\tfunction resetWorkInProgress(workInProgress,renderLanes){// This resets the Fiber to what createFiber or createWorkInProgress would\n\t// have set the values to before during the first pass. Ideally this wouldn't\n\t// be necessary but unfortunately many code paths reads from the workInProgress\n\t// when they should be reading from current and writing to workInProgress.\n\t// We assume pendingProps, index, key, ref, return are still untouched to\n\t// avoid doing another reconciliation.\n\t// Reset the effect flags but keep any Placement tags, since that's something\n\t// that child fiber is setting, not the reconciliation.\n\tworkInProgress.flags&=StaticMask|Placement;// The effects are no longer valid.\n\tvar current=workInProgress.alternate;if(current===null){// Reset to createFiber's initial values.\n\tworkInProgress.childLanes=NoLanes;workInProgress.lanes=renderLanes;workInProgress.child=null;workInProgress.subtreeFlags=NoFlags;workInProgress.memoizedProps=null;workInProgress.memoizedState=null;workInProgress.updateQueue=null;workInProgress.dependencies=null;workInProgress.stateNode=null;{// Note: We don't reset the actualTime counts. It's useful to accumulate\n\t// actual time across multiple render passes.\n\tworkInProgress.selfBaseDuration=0;workInProgress.treeBaseDuration=0;}}else {// Reset to the cloned values that createWorkInProgress would've.\n\tworkInProgress.childLanes=current.childLanes;workInProgress.lanes=current.lanes;workInProgress.child=current.child;workInProgress.subtreeFlags=NoFlags;workInProgress.deletions=null;workInProgress.memoizedProps=current.memoizedProps;workInProgress.memoizedState=current.memoizedState;workInProgress.updateQueue=current.updateQueue;// Needed because Blocks store data on type.\n\tworkInProgress.type=current.type;// Clone the dependencies object. This is mutated during the render phase, so\n\t// it cannot be shared with the current fiber.\n\tvar currentDependencies=current.dependencies;workInProgress.dependencies=currentDependencies===null?null:{lanes:currentDependencies.lanes,firstContext:currentDependencies.firstContext};{// Note: We don't reset the actualTime counts. It's useful to accumulate\n\t// actual time across multiple render passes.\n\tworkInProgress.selfBaseDuration=current.selfBaseDuration;workInProgress.treeBaseDuration=current.treeBaseDuration;}}return workInProgress;}function createHostRootFiber(tag,isStrictMode,concurrentUpdatesByDefaultOverride){var mode;if(tag===ConcurrentRoot){mode=ConcurrentMode;if(isStrictMode===true){mode|=StrictLegacyMode;{mode|=StrictEffectsMode;}}}else {mode=NoMode;}if(isDevToolsPresent){// Always collect profile timings when DevTools are present.\n\t// This enables DevTools to start capturing timing at any point–\n\t// Without some nodes in the tree having empty base times.\n\tmode|=ProfileMode;}return createFiber(HostRoot,null,null,mode);}function createFiberFromTypeAndProps(type,// React$ElementType\n\tkey,pendingProps,owner,mode,lanes){var fiberTag=IndeterminateComponent;// The resolved type is set if we know what the final type will be. I.e. it's not lazy.\n\tvar resolvedType=type;if(typeof type==='function'){if(shouldConstruct$1(type)){fiberTag=ClassComponent;{resolvedType=resolveClassForHotReloading(resolvedType);}}else {{resolvedType=resolveFunctionForHotReloading(resolvedType);}}}else if(typeof type==='string'){fiberTag=HostComponent;}else {getTag:switch(type){case REACT_FRAGMENT_TYPE:return createFiberFromFragment(pendingProps.children,mode,lanes,key);case REACT_STRICT_MODE_TYPE:fiberTag=Mode;mode|=StrictLegacyMode;if((mode&ConcurrentMode)!==NoMode){// Strict effects should never run on legacy roots\n\tmode|=StrictEffectsMode;}break;case REACT_PROFILER_TYPE:return createFiberFromProfiler(pendingProps,mode,lanes,key);case REACT_SUSPENSE_TYPE:return createFiberFromSuspense(pendingProps,mode,lanes,key);case REACT_SUSPENSE_LIST_TYPE:return createFiberFromSuspenseList(pendingProps,mode,lanes,key);case REACT_OFFSCREEN_TYPE:return createFiberFromOffscreen(pendingProps,mode,lanes,key);case REACT_LEGACY_HIDDEN_TYPE:// eslint-disable-next-line no-fallthrough\n\tcase REACT_SCOPE_TYPE:// eslint-disable-next-line no-fallthrough\n\tcase REACT_CACHE_TYPE:// eslint-disable-next-line no-fallthrough\n\tcase REACT_TRACING_MARKER_TYPE:// eslint-disable-next-line no-fallthrough\n\tcase REACT_DEBUG_TRACING_MODE_TYPE:// eslint-disable-next-line no-fallthrough\n\tdefault:{if(typeof type==='object'&&type!==null){switch(type.$$typeof){case REACT_PROVIDER_TYPE:fiberTag=ContextProvider;break getTag;case REACT_CONTEXT_TYPE:// This is a consumer\n\tfiberTag=ContextConsumer;break getTag;case REACT_FORWARD_REF_TYPE:fiberTag=ForwardRef;{resolvedType=resolveForwardRefForHotReloading(resolvedType);}break getTag;case REACT_MEMO_TYPE:fiberTag=MemoComponent;break getTag;case REACT_LAZY_TYPE:fiberTag=LazyComponent;resolvedType=null;break getTag;}}var info='';{if(type===undefined||typeof type==='object'&&type!==null&&Object.keys(type).length===0){info+=' You likely forgot to export your component from the file '+\"it's defined in, or you might have mixed up default and \"+'named imports.';}var ownerName=owner?getComponentNameFromFiber(owner):null;if(ownerName){info+='\\n\\nCheck the render method of `'+ownerName+'`.';}}throw new Error('Element type is invalid: expected a string (for built-in '+'components) or a class/function (for composite components) '+(\"but got: \"+(type==null?type:typeof type)+\".\"+info));}}}var fiber=createFiber(fiberTag,pendingProps,key,mode);fiber.elementType=type;fiber.type=resolvedType;fiber.lanes=lanes;{fiber._debugOwner=owner;}return fiber;}function createFiberFromElement(element,mode,lanes){var owner=null;{owner=element._owner;}var type=element.type;var key=element.key;var pendingProps=element.props;var fiber=createFiberFromTypeAndProps(type,key,pendingProps,owner,mode,lanes);{fiber._debugSource=element._source;fiber._debugOwner=element._owner;}return fiber;}function createFiberFromFragment(elements,mode,lanes,key){var fiber=createFiber(Fragment,elements,key,mode);fiber.lanes=lanes;return fiber;}function createFiberFromProfiler(pendingProps,mode,lanes,key){{if(typeof pendingProps.id!=='string'){error('Profiler must specify an \"id\" of type `string` as a prop. Received the type `%s` instead.',typeof pendingProps.id);}}var fiber=createFiber(Profiler,pendingProps,key,mode|ProfileMode);fiber.elementType=REACT_PROFILER_TYPE;fiber.lanes=lanes;{fiber.stateNode={effectDuration:0,passiveEffectDuration:0};}return fiber;}function createFiberFromSuspense(pendingProps,mode,lanes,key){var fiber=createFiber(SuspenseComponent,pendingProps,key,mode);fiber.elementType=REACT_SUSPENSE_TYPE;fiber.lanes=lanes;return fiber;}function createFiberFromSuspenseList(pendingProps,mode,lanes,key){var fiber=createFiber(SuspenseListComponent,pendingProps,key,mode);fiber.elementType=REACT_SUSPENSE_LIST_TYPE;fiber.lanes=lanes;return fiber;}function createFiberFromOffscreen(pendingProps,mode,lanes,key){var fiber=createFiber(OffscreenComponent,pendingProps,key,mode);fiber.elementType=REACT_OFFSCREEN_TYPE;fiber.lanes=lanes;var primaryChildInstance={isHidden:false};fiber.stateNode=primaryChildInstance;return fiber;}function createFiberFromText(content,mode,lanes){var fiber=createFiber(HostText,content,null,mode);fiber.lanes=lanes;return fiber;}function createFiberFromHostInstanceForDeletion(){var fiber=createFiber(HostComponent,null,null,NoMode);fiber.elementType='DELETED';return fiber;}function createFiberFromDehydratedFragment(dehydratedNode){var fiber=createFiber(DehydratedFragment,null,null,NoMode);fiber.stateNode=dehydratedNode;return fiber;}function createFiberFromPortal(portal,mode,lanes){var pendingProps=portal.children!==null?portal.children:[];var fiber=createFiber(HostPortal,pendingProps,portal.key,mode);fiber.lanes=lanes;fiber.stateNode={containerInfo:portal.containerInfo,pendingChildren:null,// Used by persistent updates\n\timplementation:portal.implementation};return fiber;}// Used for stashing WIP properties to replay failed work in DEV.\n\tfunction assignFiberPropertiesInDEV(target,source){if(target===null){// This Fiber's initial properties will always be overwritten.\n\t// We only use a Fiber to ensure the same hidden class so DEV isn't slow.\n\ttarget=createFiber(IndeterminateComponent,null,null,NoMode);}// This is intentionally written as a list of all properties.\n\t// We tried to use Object.assign() instead but this is called in\n\t// the hottest path, and Object.assign() was too slow:\n\t// https://github.com/facebook/react/issues/12502\n\t// This code is DEV-only so size is not a concern.\n\ttarget.tag=source.tag;target.key=source.key;target.elementType=source.elementType;target.type=source.type;target.stateNode=source.stateNode;target.return=source.return;target.child=source.child;target.sibling=source.sibling;target.index=source.index;target.ref=source.ref;target.pendingProps=source.pendingProps;target.memoizedProps=source.memoizedProps;target.updateQueue=source.updateQueue;target.memoizedState=source.memoizedState;target.dependencies=source.dependencies;target.mode=source.mode;target.flags=source.flags;target.subtreeFlags=source.subtreeFlags;target.deletions=source.deletions;target.lanes=source.lanes;target.childLanes=source.childLanes;target.alternate=source.alternate;{target.actualDuration=source.actualDuration;target.actualStartTime=source.actualStartTime;target.selfBaseDuration=source.selfBaseDuration;target.treeBaseDuration=source.treeBaseDuration;}target._debugSource=source._debugSource;target._debugOwner=source._debugOwner;target._debugNeedsRemount=source._debugNeedsRemount;target._debugHookTypes=source._debugHookTypes;return target;}function FiberRootNode(containerInfo,tag,hydrate,identifierPrefix,onRecoverableError){this.tag=tag;this.containerInfo=containerInfo;this.pendingChildren=null;this.current=null;this.pingCache=null;this.finishedWork=null;this.timeoutHandle=noTimeout;this.context=null;this.pendingContext=null;this.callbackNode=null;this.callbackPriority=NoLane;this.eventTimes=createLaneMap(NoLanes);this.expirationTimes=createLaneMap(NoTimestamp);this.pendingLanes=NoLanes;this.suspendedLanes=NoLanes;this.pingedLanes=NoLanes;this.expiredLanes=NoLanes;this.mutableReadLanes=NoLanes;this.finishedLanes=NoLanes;this.entangledLanes=NoLanes;this.entanglements=createLaneMap(NoLanes);this.identifierPrefix=identifierPrefix;this.onRecoverableError=onRecoverableError;{this.mutableSourceEagerHydrationData=null;}{this.effectDuration=0;this.passiveEffectDuration=0;}{this.memoizedUpdaters=new Set();var pendingUpdatersLaneMap=this.pendingUpdatersLaneMap=[];for(var _i=0;_i<TotalLanes;_i++){pendingUpdatersLaneMap.push(new Set());}}{switch(tag){case ConcurrentRoot:this._debugRootType=hydrate?'hydrateRoot()':'createRoot()';break;case LegacyRoot:this._debugRootType=hydrate?'hydrate()':'render()';break;}}}function createFiberRoot(containerInfo,tag,hydrate,initialChildren,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,// TODO: We have several of these arguments that are conceptually part of the\n\t// host config, but because they are passed in at runtime, we have to thread\n\t// them through the root constructor. Perhaps we should put them all into a\n\t// single type, like a DynamicHostConfig that is defined by the renderer.\n\tidentifierPrefix,onRecoverableError,transitionCallbacks){var root=new FiberRootNode(containerInfo,tag,hydrate,identifierPrefix,onRecoverableError);// stateNode is any.\n\tvar uninitializedFiber=createHostRootFiber(tag,isStrictMode);root.current=uninitializedFiber;uninitializedFiber.stateNode=root;{var _initialState={element:initialChildren,isDehydrated:hydrate,cache:null,// not enabled yet\n\ttransitions:null,pendingSuspenseBoundaries:null};uninitializedFiber.memoizedState=_initialState;}initializeUpdateQueue(uninitializedFiber);return root;}var ReactVersion='18.2.0';function createPortal(children,containerInfo,// TODO: figure out the API for cross-renderer implementation.\n\timplementation){var key=arguments.length>3&&arguments[3]!==undefined?arguments[3]:null;{checkKeyStringCoercion(key);}return {// This tag allow us to uniquely identify this as a React Portal\n\t$$typeof:REACT_PORTAL_TYPE,key:key==null?null:''+key,children:children,containerInfo:containerInfo,implementation:implementation};}var didWarnAboutNestedUpdates;var didWarnAboutFindNodeInStrictMode;{didWarnAboutNestedUpdates=false;didWarnAboutFindNodeInStrictMode={};}function getContextForSubtree(parentComponent){if(!parentComponent){return emptyContextObject;}var fiber=get(parentComponent);var parentContext=findCurrentUnmaskedContext(fiber);if(fiber.tag===ClassComponent){var Component=fiber.type;if(isContextProvider(Component)){return processChildContext(fiber,Component,parentContext);}}return parentContext;}function findHostInstanceWithWarning(component,methodName){{var fiber=get(component);if(fiber===undefined){if(typeof component.render==='function'){throw new Error('Unable to find node on an unmounted component.');}else {var keys=Object.keys(component).join(',');throw new Error(\"Argument appears to not be a ReactComponent. Keys: \"+keys);}}var hostFiber=findCurrentHostFiber(fiber);if(hostFiber===null){return null;}if(hostFiber.mode&StrictLegacyMode){var componentName=getComponentNameFromFiber(fiber)||'Component';if(!didWarnAboutFindNodeInStrictMode[componentName]){didWarnAboutFindNodeInStrictMode[componentName]=true;var previousFiber=current;try{setCurrentFiber(hostFiber);if(fiber.mode&StrictLegacyMode){error('%s is deprecated in StrictMode. '+'%s was passed an instance of %s which is inside StrictMode. '+'Instead, add a ref directly to the element you want to reference. '+'Learn more about using refs safely here: '+'https://reactjs.org/link/strict-mode-find-node',methodName,methodName,componentName);}else {error('%s is deprecated in StrictMode. '+'%s was passed an instance of %s which renders StrictMode children. '+'Instead, add a ref directly to the element you want to reference. '+'Learn more about using refs safely here: '+'https://reactjs.org/link/strict-mode-find-node',methodName,methodName,componentName);}}finally{// Ideally this should reset to previous but this shouldn't be called in\n\t// render and there's another warning for that anyway.\n\tif(previousFiber){setCurrentFiber(previousFiber);}else {resetCurrentFiber();}}}}return hostFiber.stateNode;}}function createContainer(containerInfo,tag,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError,transitionCallbacks){var hydrate=false;var initialChildren=null;return createFiberRoot(containerInfo,tag,hydrate,initialChildren,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError);}function createHydrationContainer(initialChildren,// TODO: Remove `callback` when we delete legacy mode.\n\tcallback,containerInfo,tag,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError,transitionCallbacks){var hydrate=true;var root=createFiberRoot(containerInfo,tag,hydrate,initialChildren,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError);// TODO: Move this to FiberRoot constructor\n\troot.context=getContextForSubtree(null);// Schedule the initial render. In a hydration root, this is different from\n\t// a regular update because the initial render must match was was rendered\n\t// on the server.\n\t// NOTE: This update intentionally doesn't have a payload. We're only using\n\t// the update to schedule work on the root fiber (and, for legacy roots, to\n\t// enqueue the callback if one is provided).\n\tvar current=root.current;var eventTime=requestEventTime();var lane=requestUpdateLane(current);var update=createUpdate(eventTime,lane);update.callback=callback!==undefined&&callback!==null?callback:null;enqueueUpdate(current,update,lane);scheduleInitialHydrationOnRoot(root,lane,eventTime);return root;}function updateContainer(element,container,parentComponent,callback){{onScheduleRoot(container,element);}var current$1=container.current;var eventTime=requestEventTime();var lane=requestUpdateLane(current$1);{markRenderScheduled(lane);}var context=getContextForSubtree(parentComponent);if(container.context===null){container.context=context;}else {container.pendingContext=context;}{if(isRendering&&current!==null&&!didWarnAboutNestedUpdates){didWarnAboutNestedUpdates=true;error('Render methods should be a pure function of props and state; '+'triggering nested component updates from render is not allowed. '+'If necessary, trigger nested updates in componentDidUpdate.\\n\\n'+'Check the render method of %s.',getComponentNameFromFiber(current)||'Unknown');}}var update=createUpdate(eventTime,lane);// Caution: React DevTools currently depends on this property\n\t// being called \"element\".\n\tupdate.payload={element:element};callback=callback===undefined?null:callback;if(callback!==null){{if(typeof callback!=='function'){error('render(...): Expected the last optional `callback` argument to be a '+'function. Instead received: %s.',callback);}}update.callback=callback;}var root=enqueueUpdate(current$1,update,lane);if(root!==null){scheduleUpdateOnFiber(root,current$1,lane,eventTime);entangleTransitions(root,current$1,lane);}return lane;}function getPublicRootInstance(container){var containerFiber=container.current;if(!containerFiber.child){return null;}switch(containerFiber.child.tag){case HostComponent:return getPublicInstance(containerFiber.child.stateNode);default:return containerFiber.child.stateNode;}}function attemptSynchronousHydration$1(fiber){switch(fiber.tag){case HostRoot:{var root=fiber.stateNode;if(isRootDehydrated(root)){// Flush the first scheduled \"update\".\n\tvar lanes=getHighestPriorityPendingLanes(root);flushRoot(root,lanes);}break;}case SuspenseComponent:{flushSync(function(){var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){var eventTime=requestEventTime();scheduleUpdateOnFiber(root,fiber,SyncLane,eventTime);}});// If we're still blocked after this, we need to increase\n\t// the priority of any promises resolving within this\n\t// boundary so that they next attempt also has higher pri.\n\tvar retryLane=SyncLane;markRetryLaneIfNotHydrated(fiber,retryLane);break;}}}function markRetryLaneImpl(fiber,retryLane){var suspenseState=fiber.memoizedState;if(suspenseState!==null&&suspenseState.dehydrated!==null){suspenseState.retryLane=higherPriorityLane(suspenseState.retryLane,retryLane);}}// Increases the priority of thenables when they resolve within this boundary.\n\tfunction markRetryLaneIfNotHydrated(fiber,retryLane){markRetryLaneImpl(fiber,retryLane);var alternate=fiber.alternate;if(alternate){markRetryLaneImpl(alternate,retryLane);}}function attemptContinuousHydration$1(fiber){if(fiber.tag!==SuspenseComponent){// We ignore HostRoots here because we can't increase\n\t// their priority and they should not suspend on I/O,\n\t// since you have to wrap anything that might suspend in\n\t// Suspense.\n\treturn;}var lane=SelectiveHydrationLane;var root=enqueueConcurrentRenderForLane(fiber,lane);if(root!==null){var eventTime=requestEventTime();scheduleUpdateOnFiber(root,fiber,lane,eventTime);}markRetryLaneIfNotHydrated(fiber,lane);}function attemptHydrationAtCurrentPriority$1(fiber){if(fiber.tag!==SuspenseComponent){// We ignore HostRoots here because we can't increase\n\t// their priority other than synchronously flush it.\n\treturn;}var lane=requestUpdateLane(fiber);var root=enqueueConcurrentRenderForLane(fiber,lane);if(root!==null){var eventTime=requestEventTime();scheduleUpdateOnFiber(root,fiber,lane,eventTime);}markRetryLaneIfNotHydrated(fiber,lane);}function findHostInstanceWithNoPortals(fiber){var hostFiber=findCurrentHostFiberWithNoPortals(fiber);if(hostFiber===null){return null;}return hostFiber.stateNode;}var shouldErrorImpl=function(fiber){return null;};function shouldError(fiber){return shouldErrorImpl(fiber);}var shouldSuspendImpl=function(fiber){return false;};function shouldSuspend(fiber){return shouldSuspendImpl(fiber);}var overrideHookState=null;var overrideHookStateDeletePath=null;var overrideHookStateRenamePath=null;var overrideProps=null;var overridePropsDeletePath=null;var overridePropsRenamePath=null;var scheduleUpdate=null;var setErrorHandler=null;var setSuspenseHandler=null;{var copyWithDeleteImpl=function(obj,path,index){var key=path[index];var updated=isArray(obj)?obj.slice():assign({},obj);if(index+1===path.length){if(isArray(updated)){updated.splice(key,1);}else {delete updated[key];}return updated;}// $FlowFixMe number or string is fine here\n\tupdated[key]=copyWithDeleteImpl(obj[key],path,index+1);return updated;};var copyWithDelete=function(obj,path){return copyWithDeleteImpl(obj,path,0);};var copyWithRenameImpl=function(obj,oldPath,newPath,index){var oldKey=oldPath[index];var updated=isArray(obj)?obj.slice():assign({},obj);if(index+1===oldPath.length){var newKey=newPath[index];// $FlowFixMe number or string is fine here\n\tupdated[newKey]=updated[oldKey];if(isArray(updated)){updated.splice(oldKey,1);}else {delete updated[oldKey];}}else {// $FlowFixMe number or string is fine here\n\tupdated[oldKey]=copyWithRenameImpl(// $FlowFixMe number or string is fine here\n\tobj[oldKey],oldPath,newPath,index+1);}return updated;};var copyWithRename=function(obj,oldPath,newPath){if(oldPath.length!==newPath.length){warn('copyWithRename() expects paths of the same length');return;}else {for(var i=0;i<newPath.length-1;i++){if(oldPath[i]!==newPath[i]){warn('copyWithRename() expects paths to be the same except for the deepest key');return;}}}return copyWithRenameImpl(obj,oldPath,newPath,0);};var copyWithSetImpl=function(obj,path,index,value){if(index>=path.length){return value;}var key=path[index];var updated=isArray(obj)?obj.slice():assign({},obj);// $FlowFixMe number or string is fine here\n\tupdated[key]=copyWithSetImpl(obj[key],path,index+1,value);return updated;};var copyWithSet=function(obj,path,value){return copyWithSetImpl(obj,path,0,value);};var findHook=function(fiber,id){// For now, the \"id\" of stateful hooks is just the stateful hook index.\n\t// This may change in the future with e.g. nested hooks.\n\tvar currentHook=fiber.memoizedState;while(currentHook!==null&&id>0){currentHook=currentHook.next;id--;}return currentHook;};// Support DevTools editable values for useState and useReducer.\n\toverrideHookState=function(fiber,id,path,value){var hook=findHook(fiber,id);if(hook!==null){var newState=copyWithSet(hook.memoizedState,path,value);hook.memoizedState=newState;hook.baseState=newState;// We aren't actually adding an update to the queue,\n\t// because there is no update we can add for useReducer hooks that won't trigger an error.\n\t// (There's no appropriate action type for DevTools overrides.)\n\t// As a result though, React will see the scheduled update as a noop and bailout.\n\t// Shallow cloning props works as a workaround for now to bypass the bailout check.\n\tfiber.memoizedProps=assign({},fiber.memoizedProps);var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){scheduleUpdateOnFiber(root,fiber,SyncLane,NoTimestamp);}}};overrideHookStateDeletePath=function(fiber,id,path){var hook=findHook(fiber,id);if(hook!==null){var newState=copyWithDelete(hook.memoizedState,path);hook.memoizedState=newState;hook.baseState=newState;// We aren't actually adding an update to the queue,\n\t// because there is no update we can add for useReducer hooks that won't trigger an error.\n\t// (There's no appropriate action type for DevTools overrides.)\n\t// As a result though, React will see the scheduled update as a noop and bailout.\n\t// Shallow cloning props works as a workaround for now to bypass the bailout check.\n\tfiber.memoizedProps=assign({},fiber.memoizedProps);var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){scheduleUpdateOnFiber(root,fiber,SyncLane,NoTimestamp);}}};overrideHookStateRenamePath=function(fiber,id,oldPath,newPath){var hook=findHook(fiber,id);if(hook!==null){var newState=copyWithRename(hook.memoizedState,oldPath,newPath);hook.memoizedState=newState;hook.baseState=newState;// We aren't actually adding an update to the queue,\n\t// because there is no update we can add for useReducer hooks that won't trigger an error.\n\t// (There's no appropriate action type for DevTools overrides.)\n\t// As a result though, React will see the scheduled update as a noop and bailout.\n\t// Shallow cloning props works as a workaround for now to bypass the bailout check.\n\tfiber.memoizedProps=assign({},fiber.memoizedProps);var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){scheduleUpdateOnFiber(root,fiber,SyncLane,NoTimestamp);}}};// Support DevTools props for function components, forwardRef, memo, host components, etc.\n\toverrideProps=function(fiber,path,value){fiber.pendingProps=copyWithSet(fiber.memoizedProps,path,value);if(fiber.alternate){fiber.alternate.pendingProps=fiber.pendingProps;}var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){scheduleUpdateOnFiber(root,fiber,SyncLane,NoTimestamp);}};overridePropsDeletePath=function(fiber,path){fiber.pendingProps=copyWithDelete(fiber.memoizedProps,path);if(fiber.alternate){fiber.alternate.pendingProps=fiber.pendingProps;}var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){scheduleUpdateOnFiber(root,fiber,SyncLane,NoTimestamp);}};overridePropsRenamePath=function(fiber,oldPath,newPath){fiber.pendingProps=copyWithRename(fiber.memoizedProps,oldPath,newPath);if(fiber.alternate){fiber.alternate.pendingProps=fiber.pendingProps;}var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){scheduleUpdateOnFiber(root,fiber,SyncLane,NoTimestamp);}};scheduleUpdate=function(fiber){var root=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root!==null){scheduleUpdateOnFiber(root,fiber,SyncLane,NoTimestamp);}};setErrorHandler=function(newShouldErrorImpl){shouldErrorImpl=newShouldErrorImpl;};setSuspenseHandler=function(newShouldSuspendImpl){shouldSuspendImpl=newShouldSuspendImpl;};}function findHostInstanceByFiber(fiber){var hostFiber=findCurrentHostFiber(fiber);if(hostFiber===null){return null;}return hostFiber.stateNode;}function emptyFindFiberByHostInstance(instance){return null;}function getCurrentFiberForDevTools(){return current;}function injectIntoDevTools(devToolsConfig){var findFiberByHostInstance=devToolsConfig.findFiberByHostInstance;var ReactCurrentDispatcher=ReactSharedInternals.ReactCurrentDispatcher;return injectInternals({bundleType:devToolsConfig.bundleType,version:devToolsConfig.version,rendererPackageName:devToolsConfig.rendererPackageName,rendererConfig:devToolsConfig.rendererConfig,overrideHookState:overrideHookState,overrideHookStateDeletePath:overrideHookStateDeletePath,overrideHookStateRenamePath:overrideHookStateRenamePath,overrideProps:overrideProps,overridePropsDeletePath:overridePropsDeletePath,overridePropsRenamePath:overridePropsRenamePath,setErrorHandler:setErrorHandler,setSuspenseHandler:setSuspenseHandler,scheduleUpdate:scheduleUpdate,currentDispatcherRef:ReactCurrentDispatcher,findHostInstanceByFiber:findHostInstanceByFiber,findFiberByHostInstance:findFiberByHostInstance||emptyFindFiberByHostInstance,// React Refresh\n\tfindHostInstancesForRefresh:findHostInstancesForRefresh,scheduleRefresh:scheduleRefresh,scheduleRoot:scheduleRoot,setRefreshHandler:setRefreshHandler,// Enables DevTools to append owner stacks to error messages in DEV mode.\n\tgetCurrentFiber:getCurrentFiberForDevTools,// Enables DevTools to detect reconciler version rather than renderer version\n\t// which may not match for third party renderers.\n\treconcilerVersion:ReactVersion});}/* global reportError */var defaultOnRecoverableError=typeof reportError==='function'?// In modern browsers, reportError will dispatch an error event,\n\t// emulating an uncaught JavaScript error.\n\treportError:function(error){// In older browsers and test environments, fallback to console.error.\n\t// eslint-disable-next-line react-internal/no-production-logging\n\tconsole['error'](error);};function ReactDOMRoot(internalRoot){this._internalRoot=internalRoot;}ReactDOMHydrationRoot.prototype.render=ReactDOMRoot.prototype.render=function(children){var root=this._internalRoot;if(root===null){throw new Error('Cannot update an unmounted root.');}{if(typeof arguments[1]==='function'){error('render(...): does not support the second callback argument. '+'To execute a side effect after rendering, declare it in a component body with useEffect().');}else if(isValidContainer(arguments[1])){error('You passed a container to the second argument of root.render(...). '+\"You don't need to pass it again since you already passed it to create the root.\");}else if(typeof arguments[1]!=='undefined'){error('You passed a second argument to root.render(...) but it only accepts '+'one argument.');}var container=root.containerInfo;if(container.nodeType!==COMMENT_NODE){var hostInstance=findHostInstanceWithNoPortals(root.current);if(hostInstance){if(hostInstance.parentNode!==container){error('render(...): It looks like the React-rendered content of the '+'root container was removed without using React. This is not '+'supported and will cause errors. Instead, call '+\"root.unmount() to empty a root's container.\");}}}}updateContainer(children,root,null,null);};ReactDOMHydrationRoot.prototype.unmount=ReactDOMRoot.prototype.unmount=function(){{if(typeof arguments[0]==='function'){error('unmount(...): does not support a callback argument. '+'To execute a side effect after rendering, declare it in a component body with useEffect().');}}var root=this._internalRoot;if(root!==null){this._internalRoot=null;var container=root.containerInfo;{if(isAlreadyRendering()){error('Attempted to synchronously unmount a root while React was already '+'rendering. React cannot finish unmounting the root until the '+'current render has completed, which may lead to a race condition.');}}flushSync(function(){updateContainer(null,root,null,null);});unmarkContainerAsRoot(container);}};function createRoot(container,options){if(!isValidContainer(container)){throw new Error('createRoot(...): Target container is not a DOM element.');}warnIfReactDOMContainerInDEV(container);var isStrictMode=false;var concurrentUpdatesByDefaultOverride=false;var identifierPrefix='';var onRecoverableError=defaultOnRecoverableError;if(options!==null&&options!==undefined){{if(options.hydrate){warn('hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.');}else {if(typeof options==='object'&&options!==null&&options.$$typeof===REACT_ELEMENT_TYPE){error('You passed a JSX element to createRoot. You probably meant to '+'call root.render instead. '+'Example usage:\\n\\n'+'  let root = createRoot(domContainer);\\n'+'  root.render(<App />);');}}}if(options.unstable_strictMode===true){isStrictMode=true;}if(options.identifierPrefix!==undefined){identifierPrefix=options.identifierPrefix;}if(options.onRecoverableError!==undefined){onRecoverableError=options.onRecoverableError;}if(options.transitionCallbacks!==undefined){options.transitionCallbacks;}}var root=createContainer(container,ConcurrentRoot,null,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError);markContainerAsRoot(root.current,container);var rootContainerElement=container.nodeType===COMMENT_NODE?container.parentNode:container;listenToAllSupportedEvents(rootContainerElement);return new ReactDOMRoot(root);}function ReactDOMHydrationRoot(internalRoot){this._internalRoot=internalRoot;}function scheduleHydration(target){if(target){queueExplicitHydrationTarget(target);}}ReactDOMHydrationRoot.prototype.unstable_scheduleHydration=scheduleHydration;function hydrateRoot(container,initialChildren,options){if(!isValidContainer(container)){throw new Error('hydrateRoot(...): Target container is not a DOM element.');}warnIfReactDOMContainerInDEV(container);{if(initialChildren===undefined){error('Must provide initial children as second argument to hydrateRoot. '+'Example usage: hydrateRoot(domContainer, <App />)');}}// For now we reuse the whole bag of options since they contain\n\t// the hydration callbacks.\n\tvar hydrationCallbacks=options!=null?options:null;// TODO: Delete this option\n\tvar mutableSources=options!=null&&options.hydratedSources||null;var isStrictMode=false;var concurrentUpdatesByDefaultOverride=false;var identifierPrefix='';var onRecoverableError=defaultOnRecoverableError;if(options!==null&&options!==undefined){if(options.unstable_strictMode===true){isStrictMode=true;}if(options.identifierPrefix!==undefined){identifierPrefix=options.identifierPrefix;}if(options.onRecoverableError!==undefined){onRecoverableError=options.onRecoverableError;}}var root=createHydrationContainer(initialChildren,null,container,ConcurrentRoot,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError);markContainerAsRoot(root.current,container);// This can't be a comment node since hydration doesn't work on comment nodes anyway.\n\tlistenToAllSupportedEvents(container);if(mutableSources){for(var i=0;i<mutableSources.length;i++){var mutableSource=mutableSources[i];registerMutableSourceForHydration(root,mutableSource);}}return new ReactDOMHydrationRoot(root);}function isValidContainer(node){return !!(node&&(node.nodeType===ELEMENT_NODE||node.nodeType===DOCUMENT_NODE||node.nodeType===DOCUMENT_FRAGMENT_NODE||!disableCommentsAsDOMContainers));}// TODO: Remove this function which also includes comment nodes.\n\t// We only use it in places that are currently more relaxed.\n\tfunction isValidContainerLegacy(node){return !!(node&&(node.nodeType===ELEMENT_NODE||node.nodeType===DOCUMENT_NODE||node.nodeType===DOCUMENT_FRAGMENT_NODE||node.nodeType===COMMENT_NODE&&node.nodeValue===' react-mount-point-unstable '));}function warnIfReactDOMContainerInDEV(container){{if(container.nodeType===ELEMENT_NODE&&container.tagName&&container.tagName.toUpperCase()==='BODY'){error('createRoot(): Creating roots directly with document.body is '+'discouraged, since its children are often manipulated by third-party '+'scripts and browser extensions. This may lead to subtle '+'reconciliation issues. Try using a container element created '+'for your app.');}if(isContainerMarkedAsRoot(container)){if(container._reactRootContainer){error('You are calling ReactDOMClient.createRoot() on a container that was previously '+'passed to ReactDOM.render(). This is not supported.');}else {error('You are calling ReactDOMClient.createRoot() on a container that '+'has already been passed to createRoot() before. Instead, call '+'root.render() on the existing root instead if you want to update it.');}}}}var ReactCurrentOwner$3=ReactSharedInternals.ReactCurrentOwner;var topLevelUpdateWarnings;{topLevelUpdateWarnings=function(container){if(container._reactRootContainer&&container.nodeType!==COMMENT_NODE){var hostInstance=findHostInstanceWithNoPortals(container._reactRootContainer.current);if(hostInstance){if(hostInstance.parentNode!==container){error('render(...): It looks like the React-rendered content of this '+'container was removed without using React. This is not '+'supported and will cause errors. Instead, call '+'ReactDOM.unmountComponentAtNode to empty a container.');}}}var isRootRenderedBySomeReact=!!container._reactRootContainer;var rootEl=getReactRootElementInContainer(container);var hasNonRootReactChild=!!(rootEl&&getInstanceFromNode(rootEl));if(hasNonRootReactChild&&!isRootRenderedBySomeReact){error('render(...): Replacing React-rendered children with a new root '+'component. If you intended to update the children of this node, '+'you should instead have the existing children update their state '+'and render the new components instead of calling ReactDOM.render.');}if(container.nodeType===ELEMENT_NODE&&container.tagName&&container.tagName.toUpperCase()==='BODY'){error('render(): Rendering components directly into document.body is '+'discouraged, since its children are often manipulated by third-party '+'scripts and browser extensions. This may lead to subtle '+'reconciliation issues. Try rendering into a container element created '+'for your app.');}};}function getReactRootElementInContainer(container){if(!container){return null;}if(container.nodeType===DOCUMENT_NODE){return container.documentElement;}else {return container.firstChild;}}function noopOnRecoverableError(){// This isn't reachable because onRecoverableError isn't called in the\n\t// legacy API.\n\t}function legacyCreateRootFromDOMContainer(container,initialChildren,parentComponent,callback,isHydrationContainer){if(isHydrationContainer){if(typeof callback==='function'){var originalCallback=callback;callback=function(){var instance=getPublicRootInstance(root);originalCallback.call(instance);};}var root=createHydrationContainer(initialChildren,callback,container,LegacyRoot,null,// hydrationCallbacks\n\tfalse,// isStrictMode\n\tfalse,// concurrentUpdatesByDefaultOverride,\n\t'',// identifierPrefix\n\tnoopOnRecoverableError);container._reactRootContainer=root;markContainerAsRoot(root.current,container);var rootContainerElement=container.nodeType===COMMENT_NODE?container.parentNode:container;listenToAllSupportedEvents(rootContainerElement);flushSync();return root;}else {// First clear any existing content.\n\tvar rootSibling;while(rootSibling=container.lastChild){container.removeChild(rootSibling);}if(typeof callback==='function'){var _originalCallback=callback;callback=function(){var instance=getPublicRootInstance(_root);_originalCallback.call(instance);};}var _root=createContainer(container,LegacyRoot,null,// hydrationCallbacks\n\tfalse,// isStrictMode\n\tfalse,// concurrentUpdatesByDefaultOverride,\n\t'',// identifierPrefix\n\tnoopOnRecoverableError);container._reactRootContainer=_root;markContainerAsRoot(_root.current,container);var _rootContainerElement=container.nodeType===COMMENT_NODE?container.parentNode:container;listenToAllSupportedEvents(_rootContainerElement);// Initial mount should not be batched.\n\tflushSync(function(){updateContainer(initialChildren,_root,parentComponent,callback);});return _root;}}function warnOnInvalidCallback$1(callback,callerName){{if(callback!==null&&typeof callback!=='function'){error('%s(...): Expected the last optional `callback` argument to be a '+'function. Instead received: %s.',callerName,callback);}}}function legacyRenderSubtreeIntoContainer(parentComponent,children,container,forceHydrate,callback){{topLevelUpdateWarnings(container);warnOnInvalidCallback$1(callback===undefined?null:callback,'render');}var maybeRoot=container._reactRootContainer;var root;if(!maybeRoot){// Initial mount\n\troot=legacyCreateRootFromDOMContainer(container,children,parentComponent,callback,forceHydrate);}else {root=maybeRoot;if(typeof callback==='function'){var originalCallback=callback;callback=function(){var instance=getPublicRootInstance(root);originalCallback.call(instance);};}// Update\n\tupdateContainer(children,root,parentComponent,callback);}return getPublicRootInstance(root);}function findDOMNode(componentOrElement){{var owner=ReactCurrentOwner$3.current;if(owner!==null&&owner.stateNode!==null){var warnedAboutRefsInRender=owner.stateNode._warnedAboutRefsInRender;if(!warnedAboutRefsInRender){error('%s is accessing findDOMNode inside its render(). '+'render() should be a pure function of props and state. It should '+'never access something that requires stale data from the previous '+'render, such as refs. Move this logic to componentDidMount and '+'componentDidUpdate instead.',getComponentNameFromType(owner.type)||'A component');}owner.stateNode._warnedAboutRefsInRender=true;}}if(componentOrElement==null){return null;}if(componentOrElement.nodeType===ELEMENT_NODE){return componentOrElement;}{return findHostInstanceWithWarning(componentOrElement,'findDOMNode');}}function hydrate(element,container,callback){{error('ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot '+'instead. Until you switch to the new API, your app will behave as '+\"if it's running React 17. Learn \"+'more: https://reactjs.org/link/switch-to-createroot');}if(!isValidContainerLegacy(container)){throw new Error('Target container is not a DOM element.');}{var isModernRoot=isContainerMarkedAsRoot(container)&&container._reactRootContainer===undefined;if(isModernRoot){error('You are calling ReactDOM.hydrate() on a container that was previously '+'passed to ReactDOMClient.createRoot(). This is not supported. '+'Did you mean to call hydrateRoot(container, element)?');}}// TODO: throw or warn if we couldn't hydrate?\n\treturn legacyRenderSubtreeIntoContainer(null,element,container,true,callback);}function render(element,container,callback){{error('ReactDOM.render is no longer supported in React 18. Use createRoot '+'instead. Until you switch to the new API, your app will behave as '+\"if it's running React 17. Learn \"+'more: https://reactjs.org/link/switch-to-createroot');}if(!isValidContainerLegacy(container)){throw new Error('Target container is not a DOM element.');}{var isModernRoot=isContainerMarkedAsRoot(container)&&container._reactRootContainer===undefined;if(isModernRoot){error('You are calling ReactDOM.render() on a container that was previously '+'passed to ReactDOMClient.createRoot(). This is not supported. '+'Did you mean to call root.render(element)?');}}return legacyRenderSubtreeIntoContainer(null,element,container,false,callback);}function unstable_renderSubtreeIntoContainer(parentComponent,element,containerNode,callback){{error('ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported '+'in React 18. Consider using a portal instead. Until you switch to '+\"the createRoot API, your app will behave as if it's running React \"+'17. Learn more: https://reactjs.org/link/switch-to-createroot');}if(!isValidContainerLegacy(containerNode)){throw new Error('Target container is not a DOM element.');}if(parentComponent==null||!has(parentComponent)){throw new Error('parentComponent must be a valid React Component');}return legacyRenderSubtreeIntoContainer(parentComponent,element,containerNode,false,callback);}function unmountComponentAtNode(container){if(!isValidContainerLegacy(container)){throw new Error('unmountComponentAtNode(...): Target container is not a DOM element.');}{var isModernRoot=isContainerMarkedAsRoot(container)&&container._reactRootContainer===undefined;if(isModernRoot){error('You are calling ReactDOM.unmountComponentAtNode() on a container that was previously '+'passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?');}}if(container._reactRootContainer){{var rootEl=getReactRootElementInContainer(container);var renderedByDifferentReact=rootEl&&!getInstanceFromNode(rootEl);if(renderedByDifferentReact){error(\"unmountComponentAtNode(): The node you're attempting to unmount \"+'was rendered by another copy of React.');}}// Unmount should not be batched.\n\tflushSync(function(){legacyRenderSubtreeIntoContainer(null,null,container,false,function(){// $FlowFixMe This should probably use `delete container._reactRootContainer`\n\tcontainer._reactRootContainer=null;unmarkContainerAsRoot(container);});});// If you call unmountComponentAtNode twice in quick succession, you'll\n\t// get `true` twice. That's probably fine?\n\treturn true;}else {{var _rootEl=getReactRootElementInContainer(container);var hasNonRootReactChild=!!(_rootEl&&getInstanceFromNode(_rootEl));// Check if the container itself is a React root node.\n\tvar isContainerReactRoot=container.nodeType===ELEMENT_NODE&&isValidContainerLegacy(container.parentNode)&&!!container.parentNode._reactRootContainer;if(hasNonRootReactChild){error(\"unmountComponentAtNode(): The node you're attempting to unmount \"+'was rendered by React and is not a top-level container. %s',isContainerReactRoot?'You may have accidentally passed in a React root node instead '+'of its container.':'Instead, have the parent component update its state and '+'rerender in order to remove this component.');}}return false;}}setAttemptSynchronousHydration(attemptSynchronousHydration$1);setAttemptContinuousHydration(attemptContinuousHydration$1);setAttemptHydrationAtCurrentPriority(attemptHydrationAtCurrentPriority$1);setGetCurrentUpdatePriority(getCurrentUpdatePriority);setAttemptHydrationAtPriority(runWithPriority);{if(typeof Map!=='function'||// $FlowIssue Flow incorrectly thinks Map has no prototype\n\tMap.prototype==null||typeof Map.prototype.forEach!=='function'||typeof Set!=='function'||// $FlowIssue Flow incorrectly thinks Set has no prototype\n\tSet.prototype==null||typeof Set.prototype.clear!=='function'||typeof Set.prototype.forEach!=='function'){error('React depends on Map and Set built-in types. Make sure that you load a '+'polyfill in older browsers. https://reactjs.org/link/react-polyfills');}}setRestoreImplementation(restoreControlledState$3);setBatchingImplementation(batchedUpdates$1,discreteUpdates,flushSync);function createPortal$1(children,container){var key=arguments.length>2&&arguments[2]!==undefined?arguments[2]:null;if(!isValidContainer(container)){throw new Error('Target container is not a DOM element.');}// TODO: pass ReactDOM portal implementation as third argument\n\t// $FlowFixMe The Flow type is opaque but there's no way to actually create it.\n\treturn createPortal(children,container,null,key);}function renderSubtreeIntoContainer(parentComponent,element,containerNode,callback){return unstable_renderSubtreeIntoContainer(parentComponent,element,containerNode,callback);}var Internals={usingClientEntryPoint:false,// Keep in sync with ReactTestUtils.js.\n\t// This is an array for better minification.\n\tEvents:[getInstanceFromNode,getNodeFromInstance,getFiberCurrentPropsFromNode,enqueueStateRestore,restoreStateIfNeeded,batchedUpdates$1]};function createRoot$1(container,options){{if(!Internals.usingClientEntryPoint&&!false){error('You are importing createRoot from \"react-dom\" which is not supported. '+'You should instead import it from \"react-dom/client\".');}}return createRoot(container,options);}function hydrateRoot$1(container,initialChildren,options){{if(!Internals.usingClientEntryPoint&&!false){error('You are importing hydrateRoot from \"react-dom\" which is not supported. '+'You should instead import it from \"react-dom/client\".');}}return hydrateRoot(container,initialChildren,options);}// Overload the definition to the two valid signatures.\n\t// Warning, this opts-out of checking the function body.\n\t// eslint-disable-next-line no-redeclare\n\tfunction flushSync$1(fn){{if(isAlreadyRendering()){error('flushSync was called from inside a lifecycle method. React cannot '+'flush when React is already rendering. Consider moving this call to '+'a scheduler task or micro task.');}}return flushSync(fn);}var foundDevTools=injectIntoDevTools({findFiberByHostInstance:getClosestInstanceFromNode,bundleType:1,version:ReactVersion,rendererPackageName:'react-dom'});{if(!foundDevTools&&canUseDOM&&window.top===window.self){// If we're in Chrome or Firefox, provide a download link if not installed.\n\tif(navigator.userAgent.indexOf('Chrome')>-1&&navigator.userAgent.indexOf('Edge')===-1||navigator.userAgent.indexOf('Firefox')>-1){var protocol=window.location.protocol;// Don't warn in exotic cases like chrome-extension://.\n\tif(/^(https?|file):$/.test(protocol)){// eslint-disable-next-line react-internal/no-production-logging\n\tconsole.info('%cDownload the React DevTools '+'for a better development experience: '+'https://reactjs.org/link/react-devtools'+(protocol==='file:'?'\\nYou might need to use a local HTTP server (instead of file://): '+'https://reactjs.org/link/react-devtools-faq':''),'font-weight:bold');}}}}reactDom_development.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=Internals;reactDom_development.createPortal=createPortal$1;reactDom_development.createRoot=createRoot$1;reactDom_development.findDOMNode=findDOMNode;reactDom_development.flushSync=flushSync$1;reactDom_development.hydrate=hydrate;reactDom_development.hydrateRoot=hydrateRoot$1;reactDom_development.render=render;reactDom_development.unmountComponentAtNode=unmountComponentAtNode;reactDom_development.unstable_batchedUpdates=batchedUpdates$1;reactDom_development.unstable_renderSubtreeIntoContainer=renderSubtreeIntoContainer;reactDom_development.version=ReactVersion;/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__!=='undefined'&&typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop==='function'){__REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());}})();}\n\n\t(function (module) {\n\t\t{\n\t\t  module.exports = reactDom_development;\n\t\t}\n\t} (reactDom));\n\n\tvar index = /*@__PURE__*/getDefaultExportFromCjs(reactDomExports);\n\n\texports.React = index$1;\n\texports.ReactDom = index;\n\n}));\n//# sourceMappingURL=index.js.map\n"],"names":[],"sourceRoot":""}